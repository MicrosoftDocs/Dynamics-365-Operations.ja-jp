<?xml version="1.0" encoding="UTF-8"?>
<xliff xmlns:logoport="urn:logoport:xliffeditor:xliff-extras:1.0" xmlns:tilt="urn:logoport:xliffeditor:tilt-non-translatables:1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-US" original="contextual-data-entry-lookups.md" target-language="ja-JP">
    <header>
      <tool tool-company="Microsoft" tool-version="1.0-7889195" tool-name="mdxliff" tool-id="mdxliff"/>
      <xliffext:skl_file_name>contextual-data-entry-lookups.ec7fb7.e50e0cb4c196b26998256e24ee7d7d3e5425c331.skl</xliffext:skl_file_name>
      <xliffext:version>1.2</xliffext:version>
      <xliffext:ms.openlocfilehash>e50e0cb4c196b26998256e24ee7d7d3e5425c331</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit>9d4c7edd0ae2053c37c7d81cdd180b16bf3a9d3b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff>05/15/2019</xliffext:ms.lasthandoff>
      <xliffext:ms.openlocfilepath>articles\dev-itpro\user-interface\contextual-data-entry-lookups.md</xliffext:ms.openlocfilepath>
    </header>
    <body>
      <group extype="content" id="content">
        <trans-unit xml:space="preserve" translate="yes" id="101" restype="x-metadata">
          <source>Contextual data entry for lookups</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ルックアップのコンテキスト データ入力</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="102" restype="x-metadata">
          <source>In data entry scenarios, it is common for a user to attempt to identify an entity in terms of some more descriptive or natural language attribute if that entity is formally identified by a synthetic key, such as a number sequence.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">データ入力のシナリオでは、そのエンティティが番号順序などの統合キーによって正式に識別される場合、ユーザーは詳細な内容を示す属性や自然言語属性でエンティティを識別しようとすることが一般的です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="103" restype="x-metadata">
          <source>The contextual data entry feature allows users to type in either the synthetic key or a more descriptive attribute directly into a lookup field.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コンテキスト データ入力機能を使用すると、統合キーまたはより記述的な属性のいずれかを検索フィールドに直接入力できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="104" restype="x-metadata">
          <source>This page explains how contextual data entry works and also provides implementation details and tips for developers who want their lookups to have this behavior.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このページでは、コンテキスト データ入力の仕組みについて説明し、ルックアップにこの動作が必要な開発者向けの実装の詳細とヒントを提供します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="105">
          <source>Contextual data entry for lookups</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ルックアップのコンテキスト データ入力</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="106">
          <source>In data entry scenarios, it is common for a user to attempt to identify an entity in terms of some more descriptive or natural language attribute if that entity is formally identified by a synthetic key, such as a number sequence.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">データ入力のシナリオでは、そのエンティティが番号順序などの統合キーによって正式に識別される場合、ユーザーは詳細な内容を示す属性や自然言語属性でエンティティを識別しようとすることが一般的です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="107">
          <source>The contextual data entry feature allows users to type in either the synthetic key or a more descriptive attribute directly into a lookup field.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コンテキスト データ入力機能を使用すると、統合キーまたはより記述的な属性のいずれかを検索フィールドに直接入力できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="108">
          <source>This page explains how contextual data entry works and also provides implementation details and tips for developers who want their lookups to have this behavior.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このページでは、コンテキスト データ入力の仕組みについて説明し、ルックアップにこの動作が必要な開発者向けの実装の詳細とヒントを提供します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="109">
          <source>Introduction</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">はじめに</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="110">
          <source>In data entry scenarios, it is common for a user to attempt to identify an entity in terms of some more descriptive or natural language attribute if that entity is formally identified by a synthetic key, such as a number sequence.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">データ入力のシナリオでは、そのエンティティが番号順序などの統合キーによって正式に識別される場合、ユーザーは詳細な内容を示す属性や自然言語属性でエンティティを識別しようとすることが一般的です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="111">
          <source>A user will typically attempt to enter an <bpt id="p1">**</bpt>Account Name<ept id="p1">**</ept> instead of an <bpt id="p2">**</bpt>Account ID<ept id="p2">**</ept> for the <bpt id="p3">**</bpt>Customer Account<ept id="p3">**</ept> when creating a Sales Order.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ユーザーは、通常、Sales Order の作成時に<bpt id="p3">**</bpt>顧客口座<ept id="p3">**</ept>の<bpt id="p2">**</bpt>アカウント ID<ept id="p2">**</ept> の代わりに<bpt id="p1">**</bpt>アカウント名<ept id="p1">**</ept>を入力しようとします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="112">
          <source>This is because most interaction with a customer is done using their actual name instead of some synthetic identifier.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これは、顧客とのほとんどのやり取りは、何らかの統合識別子の代わりに実際の名前を使用して行われるためです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="113">
          <source>Unfortunately, any user’s attempt to enter an <bpt id="p1">**</bpt>Account Name<ept id="p1">**</ept> will fail because the <bpt id="p2">**</bpt>Customer account<ept id="p2">**</ept> control’s underlying foreign key relates to a field that is a synthetic key—a number sequence—and Dynamics AX 2012 (and older) will always attempt to validate the entered value directly.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、<bpt id="p2">**</bpt>顧客 ID<ept id="p2">**</ept> コントロールの基礎となる外部キーが、合成キー (数字のシーケンス) であるフィールドに関連するため、<bpt id="p1">**</bpt>アカウント名<ept id="p1">**</ept>を入力しようとすると失敗します。AX 2012 (およびそれ以前) は、入力された値を常に直接検証しようとします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="114">
          <source>Therefore, if the <bpt id="p1">**</bpt>Account ID<ept id="p1">**</ept> was unknown to the user, the user would be forced to perform some type of searching step, such as opening the <bpt id="p2">**</bpt>Customer account<ept id="p2">**</ept> control’s lookup and filtering on the <bpt id="p3">**</bpt>Account Name<ept id="p3">**</ept> column to identify the correct <bpt id="p4">**</bpt>Account ID<ept id="p4">**</ept> (see the image below).</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">したがって、正しい <bpt id="p4">**</bpt>アカウント ID<ept id="p4">**</ept> を特定するために、<bpt id="p2">**</bpt>顧客アカウント<ept id="p2">**</ept> コントロールのルックアップを開き、<bpt id="p3">**</bpt>アカウント名<ept id="p3">**</ept> 列をフィルタリングするなど、<bpt id="p1">**</bpt>アカウント ID<ept id="p1">**</ept> がユーザーに知られていない場合、ユーザーは何らかのタイプの検索ステップを実行することを余儀なくされます (次の画像を参照)。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="115">
          <source><bpt id="p1">[</bpt><ph id="ph1">![</ph>HowToContextualLookups (3)<ept id="p1">](./media/howtocontextuallookups-3.png)](./media/howtocontextuallookups-3.png)</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">[</bpt><ph id="ph1">![</ph>HowToContextualLookups(3)<ept id="p1">](./media/howtocontextuallookups-3.png)](./media/howtocontextuallookups-3.png)</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="116">
          <source>This user experience is not optimal and is being addressed by data entry efficiency and productivity.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このユーザー エクスペリエンスは最適ではないため、データ入力の効率性と生産性によって対処されています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="117">
          <source>The platform adds initial support for contextual data entry, where the system automatically attempts to understand whether the user’s entered data is in the context of the key field or some other more descriptive or well-understood field, and handle it appropriately.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このプラットフォームは、コンテキスト データ入力の初期サポートを追加します。コンテキスト データ入力では、システムは、ユーザーが入力したデータがキー フィールドであるか、あるいはその他のより記述的またはよく分かっているフィールドであるかという状況を理解し、それを適切に処理することを自動的に試みます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="118">
          <source><bpt id="p1">**</bpt>For the remainder of this document, we’ll generically refer to these types of fields as ID (synthetic) and NAME (descriptive) fields, respectively.<ept id="p1">**</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>このドキュメントの残りの部分では、これらのタイプのフィールドをそれぞれ ID (統合) フィールドと NAME (内容を示す) フィールドと総称して参照します。<ept id="p1">**</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="119">
          <source>Contextual lookup forms</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コンテキストのルックアップ フォーム</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="120">
          <source>Just like keyboard data entry, all system generated lookup forms are also now contextual, meaning that filtering and sorting occur in the context of the data the user has entered.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">キーボード データの入力と同じように、システムで生成されたすべてのルックアップ フォームでもコンテキストを持つようになり、ユーザーが入力したデータのコンテキストでフィルター処理および並べ替えが発生します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="121">
          <source>Using the create a Sales Order scenario as an example, the user will see the lookup shown below if an ID is entered.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">販売注文シナリオの作成を例として使用すると、ID が入力された場合、ユーザーには次のようにルックアップが表示されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="122">
          <source><bpt id="p1">[</bpt><ph id="ph1">![</ph>Customer account lookup form opened in the context of ID<ept id="p1">](./media/howtocontextuallookups-1.png)](./media/howtocontextuallookups-1.png)</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">[</bpt><ph id="ph1">![</ph>ID のコンテキストで開かれた顧客アカウントの検索フォーム<ept id="p1">](./media/howtocontextuallookups-1.png)](./media/howtocontextuallookups-1.png)</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="123">
          <source>If a NAME is entered, then the user will see the following lookup.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">NAME が入力された場合は、次のルックアップが表示されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="124">
          <source>Notice how the NAME column is moved first in the Grid, and how the lookup is sorted and filtered upon when the user’s data is in the context of NAME.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ユーザーのデータが名前のコンテキストにあるときに、グリッドで最初に名前の列が移動する方法と、ルックアップの並べ替えおよびフィルターの方法を確認します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="125">
          <source>Customer account lookup form opened in the context of NAME</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">顧客 ID のルックアップ フォームを名前のコンテキストで開く</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="126">
          <source>Contextual data entry implementation details</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コンテキスト データ入力の実装の詳細</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="127">
          <source>Behavior</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">動作</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="128">
          <source>In the context of the Sales order create scenario mentioned above, the contextual data entry feature will allow the user to be able to freely type in either the ID or NAME without performing any laborious search process.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">上記の販売注文の作成シナリオのコンテキストでは、コンテキストでのデータ入力機能により、ユーザーは手間のかかる検索プロセスを実行せずに ID または名前を自由に入力できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="129">
          <source>In detail, the following behaviors will occur:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">詳細には、次のような挙動が発生します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="130">
          <source>If the user enters a complete ID reference, the value will be taken directly.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">完全な ID の参照を入力すると、値が直接適用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="131">
          <source>If the user enters a complete and unique NAME reference, the value will be automatically translated into an ID and then processed.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ユーザーが完全且つ固有の名前の参照を入力すると、値は ID に自動的に変換され、処理されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="132">
          <source>If the user enters a non-complete ID or NAME reference (such as <bpt id="p1">*</bpt>Micro<ept id="p1">*</ept> instead of <bpt id="p2">*</bpt>Microsoft<ept id="p2">*</ept>), but it still uniquely matches either ID or NAME via a BEGINS WITH predicate, then the value will be translated into its complete ID and then processed.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ユーザーが完全でない ID または NAME 参照を入力した場合 (次のように <bpt id="p1">*</bpt>Micro<ept id="p1">*</ept> の代わりに <bpt id="p2">*</bpt>Microsoft<ept id="p2">*</ept>)、BEGINS WITH 述部を介して ID または NAME のいずれかと一意に一致する場合、その値は完全 ID に変換されて処理されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="133">
          <source>If the user enters a non-complete ID or a non-unique NAME and there are multiple matches, then a <bpt id="p1">*</bpt>disambiguation<ept id="p1">*</ept> lookup will be presented to the user to select which value was actually intended.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ユーザーが完全でない ID または一意ではない NAME を入力し、複数の一致がある場合、<bpt id="p1">*</bpt>一義化<ept id="p1">*</ept>ルックアップがユーザーに提示され、実際にどの値が意図されたかを選択します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="134">
          <source>See Appendix A for more detailed sample scenarios of contextual data entry.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コンテキスト データ入力の詳細な使用シナリオについては、付録 A を参照してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="135">
          <source>Prerequisites</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">前提条件</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="136">
          <source>To maintain functional correctness and reasonable performance, the following constraints were added to the application of the behaviors described in the previous section:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">機能の正確性と適切なパフォーマンスを管理するために、前のセクションで説明した動作の適用に以下の制約が追加されました。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="137">
          <source><bpt id="p1">**</bpt>Title Field 2<ept id="p1">**</ept> is the NAME field**.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>タイトル フィールド 2<ept id="p1">**</ept> が名前フィールドです**。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="138">
          <source>The NAME field must either be covered by an index <bpt id="p1">***</bpt>OR<ept id="p1">***</ept> belong to a Table whose <bpt id="p2">*</bpt>Cache Lookup<ept id="p2">*</ept> property is set to <bpt id="p3">*</bpt>EntireTable<ept id="p3">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">NAME フィールドは、インデックスがカバーするか、<bpt id="p1">***</bpt>または<ept id="p1">***</ept> <bpt id="p2">*</bpt>Cache Lookup<ept id="p2">*</ept> プロパティが <bpt id="p3">*</bpt>EntireTable<ept id="p3">*</ept> に設定されているテーブルに属する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="139">
          <source>All contextual lookup behavior will be disabled if this requirement is not met for performance reasons.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">すべてのコンテキスト ルックアップ動作がパフォーマンス上の理由でこの要件に満たされていない場合は無効になります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="140">
          <source><bpt id="p1">**</bpt>NOTE: An index should only be added for NON TRANSACTIONAL tables because of index maintenance costs<ept id="p1">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>注: インデックスの保守コストのために、NON TRANSACTIONAL テーブルに対してのみインデックスを追加する必要があります。<ept id="p1">**</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="141">
          <source>Also note that you will <bpt id="p1">**</bpt>likely want to mark this index as non-unique<ept id="p1">**</ept> (Allow Duplicates = Yes).</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">また<bpt id="p1">**</bpt>このインデックスを一意ではないとマークする可能性が高い<ept id="p1">**</ept> (重複を許可 = はい) に注意してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="142">
          <source>If a control is using a custom lookup form (such as SysTableLookup; FormHelp on an EDT) then the disambiguation behavior described previously will not be turned on by default.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コントロールでカスタム検索フォーム (EDT 上の SysTableLookup; FormHelp など) が使用されている場合、前述の曖昧さ回避の動作は既定でオンになりません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="143">
          <source>This is because these custom lookup forms (and even surrounding modified and lookup method overrides) can and will do advanced things such as presenting a dialog, which are not desirable in the context of contextual lookups.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これは、これらのカスタム ルックアップ フォーム (および周囲の修正メソッドやルックアップ メソッドのオーバーライドさえも) は、コンテキストのルックアップのコンテキストでは望ましくないダイアログを提示するなどの高度な処理を行うことができるためです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="144">
          <source>Handling custom lookup forms requires additional knowledge and will be covered in its own section.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">カスタム ルックアップ フォームの処理には追加の情報が必要で、独自のセクションで対象となります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="145">
          <source>Programming model additions</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">プログラミング モデルの追加</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="146">
          <source>The behaviors and rules expressed in <bpt id="p1">*</bpt>Listings 1<ept id="p1">*</ept> and <bpt id="p2">*</bpt>2<ept id="p2">*</ept> are contained primarily by a new X++ class called <bpt id="p3">*</bpt>FormControlAmbiguousReferenceResolver<ept id="p3">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">*</bpt>一覧 1<ept id="p1">*</ept> および<bpt id="p2">*</bpt>一覧 2<ept id="p2">*</ept> に表される動作およびルールは、<bpt id="p3">*</bpt>FormControlAmbiguousReferenceResolver<ept id="p3">*</ept> と呼ばれる新しい X++ クラスに主に含まれています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="147">
          <source><bpt id="p1">*</bpt>FormControlAmbiguousReferenceResolver<ept id="p1">*</ept> uptake in application code will be necessary in more advanced scenarios.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">*</bpt>FormControlAmbiguousReferenceResolver<ept id="p1">*</ept> より高度なシナリオでは、アプリケーション コードの取得が必要になります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="148">
          <source>Its use will be described later in the document.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">その使用についてはドキュメントの後半で説明します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="149">
          <source>In addition to the <bpt id="p1">*</bpt>FormControlAmbiguousReferenceResolver<ept id="p1">*</ept> class, a new control override called <bpt id="p2">*</bpt>resolveAmbiguousReference<ept id="p2">*</ept> has been added.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">*</bpt>FormControlAmbiguousReferenceResolver<ept id="p1">*</ept> クラスに加えて、<bpt id="p2">*</bpt>resolveAmbiguousReference<ept id="p2">*</ept> と呼ばれる新しいコントロールのオーバーライドが追加されました。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="150">
          <source>R<bpt id="p1">*</bpt>esolveAmbiguousReference<ept id="p1">*</ept> acts as a hook point in the system for translating what the user typed into a value that the system is expecting.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">R<bpt id="p1">*</bpt>esolveAmbiguousReference<ept id="p1">*</ept> は、システムで発生している値にユーザーが入力した内容を変換するために、システムでフック ポイントとして機能します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="151">
          <source>The basic flow is as follows:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">基本的なフローは次のとおりです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="152">
          <source>The user enters a value into a control and removes focus.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ユーザーがコントロールに値を入力し、フォーカスを削除します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="153">
          <source>An interaction is sent from the client to the server, indicating that a new value has been entered.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">インタラクションはクライアントからサーバーへ送信され、新しい値が入力されたことを示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="154">
          <source>The appropriate command is executed on the server.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">適切なコマンドがサーバーで実行されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="155">
          <source>Before the command attempts to process the value entered by the user, it makes a call to <bpt id="p1">*</bpt>resolveAmbiguousReference<ept id="p1">*</ept> to give the system a chance to translate the value into the expected domain.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コマンドがユーザーによって入力された値をプロセスしようとする前に、<bpt id="p1">*</bpt>resolveAmbiguousReference<ept id="p1">*</ept> を呼び出して、システムが値を予想されるドメインに変換できるようにします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="156">
          <source>The super implementation of resolveAmbiguousReference creates an instance of <bpt id="p1">*</bpt>FormControlAmbiguousReferenceResolver<ept id="p1">*</ept> which executes the rules described above.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">resolveAmbiguousReference のスーパー実装は、上記のルールを実行する <bpt id="p1">*</bpt>FormControlAmbiguousReferenceResolver<ept id="p1">*</ept> インスタンスを作成します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="157">
          <source>The value returned from <bpt id="p1">*</bpt>resolveAmbiguousReference<ept id="p1">*</ept> is used for the remainder of the command’s execution.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">*</bpt>resolveAmbiguousReference<ept id="p1">*</ept> から返される値は、コマンドの実行の残りの部分に使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="158">
          <source>Validate() and modified() operate against the returned value.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Validate() および modified() は、返された値に対して機能します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="159">
          <source>Standard lookup uptake</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">標準参照の取得</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="160">
          <source>Add an index that covers TitleField2</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">TitleField2 の対象となるインデックスの追加</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="161">
          <source><bpt id="p1">*</bpt>TitleField2<ept id="p1">*</ept> defines the default definition of NAME.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">*</bpt>TitleField2<ept id="p1">*</ept> 名前のデフォルト定義を定義します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="162">
          <source>In order to enable ID and NAME contextual data entry, <bpt id="p1">*</bpt>TitleField2<ept id="p1">*</ept> must be either indexed OR belong to a table with <bpt id="p2">*</bpt>CacheLookup<ept id="p2">*</ept> set to <bpt id="p3">*</bpt>EntireTable<ept id="p3">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ID と名前のコンテキストのデータ入力を有効にするために、<bpt id="p1">*</bpt>TitleField2<ept id="p1">*</ept> をインデックスするか、<bpt id="p3">*</bpt>EntireTable<ept id="p3">*</ept> に対して <bpt id="p2">*</bpt>CacheLookup<ept id="p2">*</ept> を設定したテーブルに含める必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="163">
          <source>If the table containing <bpt id="p1">*</bpt>TitleField2<ept id="p1">*</ept> does not yet define an index covering <bpt id="p2">*</bpt>TitleField2<ept id="p2">*</ept> <bpt id="p3">**</bpt>and, importantly, the table does not have a high volume of CUD (Creates/Updates/Deletes<ph id="ph1">\*</ph>)<ept id="p3">**</ept>, then add a <bpt id="p4">**</bpt>non-unique<ept id="p4">**</ept> index (Allow Duplicates = Yes) covering <bpt id="p5">*</bpt>TitleField2<ept id="p5">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">*</bpt>TitleField2<ept id="p1">*</ept> を含むテーブルで <bpt id="p2">*</bpt>TitleField2<ept id="p2">*</ept> <bpt id="p3">**</bpt>をカバーするインデックスを定義しない場合、重要な事は、テーブルに大量の CUD (作成/更新/削除<ph id="ph1">\*</ph>)<ept id="p3">**</ept> がないため、<bpt id="p5">*</bpt>TitleField2<ept id="p5">*</ept> をカバーする<bpt id="p4">**</bpt>一意ではない<ept id="p4">**</ept>インデックス (重複を許可する = はい) を追加します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="164">
          <source>This will cause the system to start executing the contextual data entry behavior, except for the custom lookup limitation described in the Prerequisites section.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これにより、前提条件のセクションで説明したカスタム ルックアップの制限を除いて、システムはコンテキスト データ入力動作の実行を開始します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="165">
          <source><ph id="ph1">\*</ph>Adding an index on high-volume transactional tables may incur a noticeable performance penalty due to index maintenance costs.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">\*</ph>大量のトランザクション テーブルにインデックスを追加すると、インデックス保守コストのために顕著なパフォーマンス ペナルティが発生する場合があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="166">
          <source>Enable disambiguation behavior for custom lookup scenarios</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">カスタム ルックアップ シナリオの曖昧性解消動作の有効化</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="167">
          <source>Custom lookup implementations can provide advanced or non-typical behaviors, such as presenting dialogs.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">カスタム ルックアップの実装では、ダイアログの提示など、高度な動作や非典型的な動作を提供できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="168">
          <source>Therefore, the system disables the default disambiguation behavior when a custom lookup scenario is detected.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">したがって、カスタム ルックアップ シナリオが検出されると、システムは既定の曖昧さ回避動作を無効にします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="169">
          <source>To opt into the default disambiguation behavior, override the <bpt id="p1">*</bpt>resolveAmbiguousReference<ept id="p1">*</ept> method (as shown below) <bpt id="p2">**</bpt>on the control hosting the lookup<ept id="p2">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">既定の曖昧性解消動作を有効にするには、<bpt id="p2">**</bpt>ルックアップをホストするコントロール<ept id="p2">**</ept> で <bpt id="p1">*</bpt>resolveAmbiguousReference<ept id="p1">*</ept> メソッド (下記参照) をオーバーライドします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="170">
          <source>Note that the second parameter to the <bpt id="p1">*</bpt>resolveAmbiguousReferenceForControl<ept id="p1">*</ept> call is what overrides the default behavior of not performing disambiguation for custom lookup scenarios.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">*</bpt>resolveAmbiguousReferenceForControl<ept id="p1">*</ept> の呼び出しに対する 2 つ目のパラメーターは、カスタム ルックアップ シナリオについて曖昧性解消を実行しないという既定の動作をオーバーライドするものであることに注意してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="171">
          <source>Make custom lookup forms contextual</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">カスタム ルックアップ フォームをコンテキストにする</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="172">
          <source>As mentioned earlier, all system generated lookup forms automatically consider the context of the data entered into their host control.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">先に述べたように、システム生成のルックアップ フォームはすべて、ホスト コントロールに入力されたデータのコンテキストを自動的に考慮します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="173">
          <source>This includes most lookup forms generated via <bpt id="p1">*</bpt>SysTableLookup<ept id="p1">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これには、<bpt id="p1">*</bpt>SysTableLookup<ept id="p1">*</ept> によって生成されるほとんどのルックアップ フォームが含まれます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="174">
          <source>Modeled custom lookup forms, by their nature, cannot be fully-handled by the system and must be modified to match the behavior and visuals of contextual lookups forms.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">モデル化されたカスタム ルックアップ フォームは、その性質によってシステムで完全に処理することはできず、コンテキストのルックアップ フォームの動作およびビジュアルと一致するように変更する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="175">
          <source>If the data contained by the host control is in the context of ID, then:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ホスト コントロールに含まれるデータが ID のコンテキスト内にある場合:</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="176">
          <source>Make the ID column first in the Grid.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">グリッドにまず ID 列を作成します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="177">
          <source>Sort and filter by ID.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ID により並べ替えてフィルター処理します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="178">
          <source>If the data contained by the host control is in the context of NAME, then:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ホスト コントロールに含まれるデータが NAME のコンテキスト内にある場合:</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="179">
          <source>Make the NAME column first in the Grid,</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">グリッドにまず名前列を作成します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="180">
          <source>Sort and filter by NAME,</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">NAME により並べ替えてフィルター処理します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="181">
          <source>The following scenarios illustrate some custom lookups, along with the recommendation for how to enable contextual data entry in these cases.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のシナリオでは、カスタム ルックアップと、これらの場合のコンテキストでのデータ入力を有効にする方法の推奨事項を示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="182">
          <source>Scenario 1: Custom lookup defined via the FormHelp property on an EDT</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">シナリオ 1: EDT で FormHelp プロパティ経由で定義されたユーザー設定のルックアップ</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="183">
          <source>Custom lookups defined via FormHelp (even though modeled) still go through normal kernel-based lookup generation routines.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">FormHelp で定義されたカスタム ルックアップ (モデル化されていても) は、通常のカーネル ベースのルックアップ生成ルーティンをそのまま使います。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="184">
          <source>Therefore, the kernel still has hooks to make some changes to the lookup form.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">したがって、カーネルには引き続きルックアップ フォームを変更するためのフックがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="185">
          <source>Specifically, the lookup system has enough information to apply the correct filters and sorts; however, it is NOT known which controls should be moved in the lookup's grid.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">具体的には、ルックアップ システムに、正しいフィルターおよび並べ替えを適用するための十分な情報があります。ただし、ルックアップのグリッドで移動すべきコントロールは既知ではありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="186">
          <source>(While an educated guess could be made based on bindings, that guess may be incorrect in more advanced lookup form designs.) If your custom lookup form is leveraging the <bpt id="p1">*</bpt>SysTableLookup::filterLookupPreRun<ept id="p1">*</ept> and <bpt id="p2">*</bpt>SysTableLookup::<ept id="p2">*</ept> <bpt id="p3">*</bpt>filterLookupPostRun<ept id="p3">*</ept> methods, then uptake the (new) optional parameters on <bpt id="p4">*</bpt>filterLookupPostRun<ept id="p4">*</ept> to have the NAME control moved automatically, as shown.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">(バインディングに基づいて推測することは可能ですが、その推測はより高度なルックアップ フォーム デザインでは不正確である可能性があります)。カスタム ルックアップ フォームが、<bpt id="p1">*</bpt>SysTableLookup::filterLookupPreRun<ept id="p1">*</ept> メソッドおよび <bpt id="p2">*</bpt>SysTableLookup::<ept id="p2">*</ept> <bpt id="p3">*</bpt>filterLookupPostRun<ept id="p3">*</ept> メソッドを利用している場合、<bpt id="p4">*</bpt>filterLookupPostRun<ept id="p4">*</ept> で (新しい) オプション パラメーターを取得して、名前コントロールを次のように自動的に移動させます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="187">
          <source>If your lookup form isn’t using the <bpt id="p1">*</bpt>SysTableLookup::filterLookup<ph id="ph1">\*</ph><ept id="p1">*</ept> methods, and you don’t want to uptake those methods, then you can simply add a control move as shown below.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ルックアップ フォームが <bpt id="p1">*</bpt>SysTableLookup::filterLookup<ph id="ph1">\*</ph><ept id="p1">*</ept> メソッドを使用しておらず、それらのメソッドを取得しない場合、以下のように、単にコントロール移動を追加することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="188">
          <source>Scenario 2: Override of lookup method manually launching a form</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">シナリオ 2: フォームを手動で起動するルックアップ メソッドの上書き</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="189">
          <source>Unlike Scenario 1, lookup forms launched by completely manual mechanisms, such as the class factory, have no kernel hooks.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">シナリオ 1 とは異なり、クラス ファクトリなどの完全な手動メカニズムによって起動されるルックアップ フォームにはカーネル フックはありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="190">
          <source>Therefore, it is the responsibility of the lookup form to adhere to the contextual data entry behaviors.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">したがって、コンテキスト データ入力動作を遵守するのはルックアップ フォームの責任です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="191">
          <source>The easiest way to do this is to leverage the SysTableLookup::filterLookup<ph id="ph1">\*</ph> methods (similar to Scenario 1) except include one additional parameter to indicate that sorting should also be maintained.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これを行う最も簡単な方法は、並べ替えを維持する必要があることを示す 1 つの追加パラメーターを含めることを除いて、(シナリオ 1 と同様の) SysTableLookup::filterLookup<ph id="ph1">\*</ph> メソッドを活用することです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="192">
          <source>An example is shown below.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例として以下に表示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="193">
          <source>Advanced lookup uptake</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">高度なルックアップの取得</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="194">
          <source>Scenario 1: Overriding ID and NAME bindings</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">シナリオ 1: ID と NAME バインドの上書き</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="195">
          <source>If you want to use a set of fields other than what is chosen by default, you must manually construct an instance of <bpt id="p1">*</bpt>FormControlAmbiguousReferenceResolver<ept id="p1">*</ept> and provide the optional parameters representing the custom bindings.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">既定で選択されている以外のフィールドのセットを使用する場合は、<bpt id="p1">*</bpt>FormControlAmbiguousReferenceResolver<ept id="p1">*</ept> のインスタンスを手動で構築し、カスタム バインドを表すオプションのパラメーターを指定する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="196">
          <source>This specialized instance must be used in an override of <bpt id="p1">*</bpt>resolveAmbiguousReference<ept id="p1">*</ept> and in a custom lookup form (including <bpt id="p2">*</bpt>SysTableLookup<ept id="p2">*</ept>, which also accepts an instance of <bpt id="p3">*</bpt>FormControlAmbiguousReferenceResolver<ept id="p3">*</ept>).</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この特別なインスタンスは、<bpt id="p1">*</bpt>resolveAmbiguousReference<ept id="p1">*</ept> のオーバーライドおよびカスタム ルックアップ フォーム (<bpt id="p3">*</bpt>FormControlAmbiguousReferenceResolver<ept id="p3">*</ept> のインスタンスも受け入れる <bpt id="p2">*</bpt>SysTableLookup<ept id="p2">*</ept>など) で使用する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="197">
          <source>A custom binding cannot currently be specified in kernel-generated lookups.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">カスタム バインディングは、現在カーネルによって生成されるルックアップで指定できません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="198">
          <source>Methods currently accepting custom ID and NAME bindings:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">現在カスタムの ID と名前のバインディングを受け入れているメソッド:</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="199">
          <source>FormControlAmbiguousReferenceResolver</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">FormControlAmbiguousReferenceResolver</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="200">
          <source>Constructor</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コンストラクター</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="201">
          <source>resolveAmbiguousReferenceForControl</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">resolveAmbiguousReferenceForControl</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="202">
          <source>surrogateFKHelperForAlternativeFieldMapping</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">surrogateFKHelperForAlternativeFieldMapping</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="203">
          <source>isControlValueMappedToAlternativeField</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">isControlValueMappedToAlternativeField</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="204">
          <source>Here's an end-to-end example of how to provide custom bindings.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">カスタム バインドを提供する方法のエンド ツー エンドの例を次に示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="205">
          <source>Scenario 2: Custom resolution logic</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">シナリオ 2: カスタム解像度ロジック</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="206">
          <source>It’s possible to use custom resolution logic by overriding resolveAmbiguousReference and leveraging something other than FormControlAmbiguousReferenceResolver.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">resolveAmbiguousReference をオーバーライドし、FormControlAmbiguousReferenceResolver 以外のものを活用することによってカスタム解決ロジックを使用できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="207">
          <source>Note that this logic needs to be common to the hosted lookup form so that keyboard and lookup based entry stay in sync.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このロジックは、キーボードおよびルックアップ ベースのエントリが常に同期されるように、ホストされているルックアップ フォームと共通にする必要があることに注意してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="208">
          <source>Appendix  Detailed usage scenarios for contextual data entry</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">付録コンテキスト データ入力の詳細な使用シナリオ</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="209">
          <source>For the scenarios, assume there is a table called "TableA" with PK field "ID" and index field "Name", with the FK we're trying to enter that is related to the ID (the user ultimately needs to pick an ID).</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">シナリオでは、PK フィールド「ID」およびインデックス フィールド「名」を持つ「TableA」と呼ばれるテーブルがあり、FK で ID (ユーザーは最終的には ID をピックする必要がある) に関連するものを入力しようとしていると仮定します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="210">
          <source>Note that any algorithms that depend on like/begins with are assuming string fields.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">類似または始まる値に依存するアルゴリズムは、文字列フィールドを想定していることに注意してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="211">
          <source>We won't be able to provide high fidelity resolution behavior on, for example, integral types.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">たとえば、整数型では、高品質の解決の動作を提供することはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="212">
          <source><bpt id="p1">**</bpt>Scenario 1: User enters a valid ID of "1234"<ept id="p1">**</ept> The super() implementation of resolveReference first queries against TableA.ID with the appropriate predicate.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>シナリオ 1: ユーザーが 有効な ID 「1234」を入力する<ept id="p1">**</ept> resolveReference の super() 実装は、適切な述部で TableA.ID を最初に照会します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="213">
          <source>The query finds a single record, and returns the user's entered value to be further processed by validate and modified.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クエリは単一のレコードを検索し、ユーザーの入力値を返して、検証および変更によって追加の処理に進みます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="214">
          <source>Validation passes and the user sees "1234" in the UI.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">検証が成功すると、UI に「1234」と表示されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="215">
          <source><bpt id="p1">**</bpt>Scenario 2: User enters an invalid ID of "4321"<ept id="p1">**</ept> The super() implementation of resolveReference first queries against TableA.ID.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>シナリオ 2: ユーザーが 無効な ID 「4321」を入力します<ept id="p1">**</ept> resolveReference の super() 実装が TableA.ID に対する最初のクエリを実行します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="216">
          <source>The query does not find any records, so a second query is performed against the Name field (SELECT TOP 2 FROM TableA WHERE TableA.Name LIKE "4321%").</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クエリはレコードを検索しないため、2 番目のクエリは Name フィールドに対して実行されます (SELECT TOP 2 FROM TableA WHERE TableA.Name LIKE "4321％")。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="217">
          <source>Still, no record is found, so "4321" is passed through to validation, which fails.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">それでもレコードが見つからないため、検証を通じて「4321」が渡されますが、失敗します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="218">
          <source>The user sees "4321" in the browser as well as a validation error.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ユーザーはブラウザーで「4321」と表示され、検証エラーが発生します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="219">
          <source><bpt id="p1">**</bpt>Scenario 3: User enters a valid Name of "ACME"<ept id="p1">**</ept> The super() implementation of resolveReference first queries against TableA.ID.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>シナリオ 3: ユーザーが「ACME」の有効な名前を入力する<ept id="p1">**</ept> resolveReference の super() 実装が TableA.ID に対する最初のクエリを実行します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="220">
          <source>The query does not find any records, so a second query is performed against the Name field (SELECT TOP 2 FROM TableA WHERE TableA.Name LIKE "ACME%").</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クエリはレコードを検索しないため、2 番目のクエリは Name フィールドに対して実行されます (SELECT TOP 2 FROM TableA WHERE TableA.Name LIKE "ACME％")。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="221">
          <source>This query does find a single record (unique reference), so the lookup automatically returns the corresponding TableA.ID.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このクエリは単一のレコード (一意の参照) を検索するので、ルックアップは対応する TableA.ID を自動的に返します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="222">
          <source>Validate and modified continue executing in the context of that value.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">その値のコンテキストでの実行を検証および変更継続します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="223">
          <source>Validation passes, and ultimately the user sees the ID value for ACME in the browser (for example, ACME would switch to 1234 in the browser).</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">検証が成功すると、最終的にはブラウザーに ACME の ID 値が表示されます (たとえば、ブラウザーで ACME は 1234 に切り替わります)。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="224">
          <source><bpt id="p1">**</bpt>Scenario 4: User enters an invalid Name of "ACNE"<ept id="p1">**</ept> The super() implementation of resolveReference first queries against TableA.ID.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>シナリオ 4: ユーザーが「ACNE」の無効な名前を入力する<ept id="p1">**</ept> resolveReference の super() 実装が TableA.ID に対する最初のクエリを実行します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="225">
          <source>The query does not find any records, so a second query is performed against the Name field (SELECT TOP 2 FROM TableA WHERE TableA.Name LIKE "ACNE%").</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クエリはレコードを検索しないため、2 番目のクエリは Name フィールドに対して実行されます (SELECT TOP 2 FROM TableA WHERE TableA.Name LIKE "ACNE％")。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="226">
          <source>This query does not find any records, so the lookup passes ACNE through to validation, which fails.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このクエリではレコードが見つからないため、ルックアップによって ACNE が検証に渡されますが検出できません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="227">
          <source>The user sees "ACNE" in the browser as well as a validation error.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ユーザーはブラウザーで「ACNE」と表示され、検証エラーが発生します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="228">
          <source><bpt id="p1">**</bpt>Scenario 5: User enters an ambiguous Name of "ACME"<ept id="p1">**</ept> In this case, assume there are two records in the database: one with Name "ACME W" and another with "ACME E".</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>シナリオ 5: ユーザーが「ACME」のあいまいな名前を入力する<ept id="p1">**</ept> この場合は、データベース内に 2 つのレコードがあると仮定 : 1 つは「ACME W」という名前で、もう 1 つは「ACME E」とします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="229">
          <source>The super() implementation of resolveReference first queries against TableA.ID.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">TableA.ID に対する resolveReference の最初のクエリの super() 実装。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="230">
          <source>The query does not find any records, so a second query is performed against the Name field (SELECT TOP 2 FROM TableA WHERE TableA.Name LIKE "ACME%").</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クエリはレコードを検索しないため、2 番目のクエリは Name フィールドに対して実行されます (SELECT TOP 2 FROM TableA WHERE TableA.Name LIKE "ACME％")。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="231">
          <source>This query finds two records, so it cannot make any further assumptions.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このクエリは 2 つのレコードを検出します。それ以上の仮定はできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="232">
          <source>A disambiguation lookup is presented to the user showing "ACME W" and "ACME E" as choices.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">曖昧性解消ルックアップは、"ACME W" と "ACME E" を示すユーザーに選択肢として表示されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="233">
          <source>The user picks "ACME E".</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ユーザーは「ACME E」を選択します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="234">
          <source>resolveReference then takes the records selected by the user and redirects it to the ID of "ACME E".</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">resolveReference を選択してから、選択したレコードを取得して "ACME E" の ID にリダイレクトします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="235">
          <source>Validate and modified continue execution in the context of the ID of "ACME E".</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">"ACME E" の ID コンテキストでの実行を検証および変更継続します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="236">
          <source>The browser ultimately displays the ID of "ACME E" (for example, 1234).</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ブラウザーは最終的に "ACME E" の ID を表示します (たとえば、1234)。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="237">
          <source><bpt id="p1">**</bpt>Scenario 6: User enters an ambiguous Name of "ACME" and doesn't make a choice in the disambiguation lookup<ept id="p1">**</ept> In this case, assume there are two records in the database: one with Name "ACME W" and another with "ACME E".</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>シナリオ 6: ユーザーが「ACME」のあいまいな名前を入力し、非不明瞭ルックアップで選択しないこと<ept id="p1">**</ept> この場合は、データベース内に 2 つのレコードがあると仮定 : 1 つは「ACME W」という名前で、もう 1 つは「ACME E」とします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="238">
          <source>The super() implementation of resolveReference first queries against TableA.ID.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">TableA.ID に対する resolveReference の最初のクエリの super() 実装。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="239">
          <source>The query does not find any records, so a second query is performed against the Name field (SELECT TOP 2 FROM TableA WHERE TableA.Name LIKE "ACME%").</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クエリはレコードを検索しないため、2 番目のクエリは Name フィールドに対して実行されます (SELECT TOP 2 FROM TableA WHERE TableA.Name LIKE "ACME％")。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="240">
          <source>This query finds two records, so it cannot make any further assumptions.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このクエリは 2 つのレコードを検出します。それ以上の仮定はできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="241">
          <source>A disambiguation lookup is presented to the user showing "ACME W" and "ACME E" as choices.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">曖昧性解消ルックアップは、"ACME W" と "ACME E" を示すユーザーに選択肢として表示されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="242">
          <source>The user doesn't make a selection from the lookup.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ユーザーはルックアップから選択しません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="243">
          <source>Therefore "ACME" is passed through to validate and modified.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">したがって、「ACME」が検証され、変更されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="244">
          <source>Validation fails and the user is presented with a validation failure message.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">検証が失敗し、ユーザーに検証エラー メッセージが表示されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="245">
          <source>The browser still displays a value of "ACME".</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ブラウザーには "ACME" という値が表示されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="246">
          <source><bpt id="p1">**</bpt>Scenario 7: User enters a "valid" ID of "12" and presents the lookup form<ept id="p1">**</ept> Prior to presenting the lookup, the system queries against TableA.ID (SELECT TOP 1 FROM TableA WHERE TableA.ID LIKE '12%').</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>シナリオ 7: ユーザーはが有効な ID「12」を入力し、ルックアップ フォームを提示します<ept id="p1">**</ept> ルックアップを提示する前に、システムは TableA.ID (「12%」のような TableA の ID からトップ 1 を選ぶ) に対して照会します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="247">
          <source>The query finds a record and therefore assumes the user must be operating in the context of ID.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クエリはレコードを検出するため、ユーザーが ID のコンテキストで操作しているものと想定されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="248">
          <source>It presents the lookup, filtering and sorting by ID.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これは、ID でのルックアップ、フィルターや並べ替えを提供します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="249">
          <source><bpt id="p1">**</bpt>Scenario 8: User enters an invalid ID of "4321" and presents the lookup form<ept id="p1">**</ept> Prior to presenting the lookup, the system queries against TableA.ID (SELECT TOP 1 FROM TableA WHERE TableA.ID LIKE '4321%').</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>シナリオ 8: ユーザーが無効な ID 「4321」を入力し、ルックアップ フォームを提示します<ept id="p1">**</ept> ルックアップを提示する前に、システムは TableA.ID (「4321%」 のような TableA の ID からトップ 1 を選ぶ) に対して照会します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="250">
          <source>The query does not find a matching record and therefore assumes the user is entering a Name.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クエリで一致するレコードが見つからないため、ユーザーが名前を入力していることを前提としています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="251">
          <source>The lookup is presented as filtered and sorted by Name (no records shown in this case).</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ルックアップは、フィルタリングされ、名前 (この場合はレコードは表示されません) で並べ替えられて表示されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="252">
          <source><bpt id="p1">**</bpt>Scenario 9: User enters a "valid" Name of "AC" and presents the lookup form<ept id="p1">**</ept> Prior to presenting the lookup, the system queries against TableA.ID (SELECT TOP 1 FROM TableA WHERE TableA.ID LIKE 'AC%').</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>シナリオ 9: ユーザーが「AC」の「有効な」名前を入力し、ルックアップ フォームを提示します<ept id="p1">**</ept> ルックアップを提示する前に、システムは TableA.ID(「AC%」のような TableA.ID からトップ 1 を選ぶ) に対して照会します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="253">
          <source>The query does not find a matching record and therefore assumes the user is entering a Name.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クエリで一致するレコードが見つからないため、ユーザーが名前を入力していることを前提としています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="254">
          <source>The lookup is presented as filtered (those records matching "begins with AC") and sorted by Name in alphabetical order.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ルックアップは、フィルタリングされたもの (「AC で始まる」に一致するレコード) とアルファベット順の名前で並べ替えられて表示されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="255">
          <source><bpt id="p1">**</bpt>Scenario 10: User enters an invalid Name of "EM" and presents the lookup form<ept id="p1">**</ept> Prior to presenting the lookup, the system queries against TableA.ID (SELECT TOP 1 FROM TableA WHERE TableA.ID LIKE 'EM%').</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>シナリオ 10: ユーザーが無効な「EM」という名前を入力し、ルックアップ フォームを提示します<ept id="p1">**</ept> ルックアップを提示する前に、システムは TableA.ID (「EM%」のような TableA の ID からトップ 1 を選ぶ)に対して照会します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="256">
          <source>The query does not find a matching record and therefore assumes the user is entering a Name.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クエリで一致するレコードが見つからないため、ユーザーが名前を入力していることを前提としています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="257">
          <source>The lookup is presented as filtered and sorted by Name.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ルックアップは、フィルタリングされ、名前で並べ替えられて表示されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="258">
          <source>No records are found and therefore the user is presented with an empty lookup.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">レコードが見つからないため、空白のルックアップがユーザーを表示されます。</target></trans-unit>
      </group>
    </body>
  </file>
</xliff>