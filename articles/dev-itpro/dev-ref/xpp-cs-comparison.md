<?xml version="1.0" encoding="UTF-8"?>
<xliff xmlns:logoport="urn:logoport:xliffeditor:xliff-extras:1.0" xmlns:tilt="urn:logoport:xliffeditor:tilt-non-translatables:1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-US" original="xpp-cs-comparison.md" target-language="ja-JP">
    <header>
      <tool tool-company="Microsoft" tool-version="1.0-7889195" tool-name="mdxliff" tool-id="mdxliff"/>
      <xliffext:skl_file_name>xpp-cs-comparison.cb7bec.49203a5a58947e36882fe2726b2c101103fd063a.skl</xliffext:skl_file_name>
      <xliffext:version>1.2</xliffext:version>
      <xliffext:ms.openlocfilehash>49203a5a58947e36882fe2726b2c101103fd063a</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit>574d4dda83dcab94728a3d35fc53ee7e2b90feb0</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff>05/22/2019</xliffext:ms.lasthandoff>
      <xliffext:ms.openlocfilepath>articles\dev-itpro\dev-ref\xpp-cs-comparison.md</xliffext:ms.openlocfilepath>
    </header>
    <body>
      <group extype="content" id="content">
        <trans-unit xml:space="preserve" translate="yes" id="101" restype="x-metadata">
          <source>X++ and C# comparison</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ と C# の比較</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="102" restype="x-metadata">
          <source>This topic compares X++ and C# syntax and programming.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このトピックでは、X++ と C# の構文とプログラミングを比較します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="103">
          <source>X++ and C# comparison</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ と C# の比較</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="104">
          <source>This topic compares X++ and C# syntax and programming.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このトピックでは、X++ と C# の構文とプログラミングを比較します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="105">
          <source>X++, C# Comparison: Hello World</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++、C# の比較: Hello World</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="106">
          <source>This section compares the simplest X++ program to its counterpart in C#.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このセクションでは、最も単純な X++ プログラムを C# の対応するものと比較します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="107">
          <source>X++ to C# Comparisons</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ と C# の比較</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="108">
          <source>The following sections describe some basic similarities and differences between X++ and C<ph id="ph1">\#</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のセクションでは、X++ と C<ph id="ph1">\#</ph> の基本的な類似点と相違点について説明します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="109">
          <source>Similarities</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">類似点</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="110">
          <source>The following X++ features are the same for C#:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の X++ 機能は C# の機能と同じです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="111">
          <source>Single line (<ph id="ph1">`//`</ph>) and multi-line (/<ph id="ph2">\*</ph> <ph id="ph3">\*</ph>/) comments.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">1 つの明細行 (<ph id="ph1">`//`</ph>) と複数行 (/<ph id="ph2">\*</ph><ph id="ph3">\*</ph>/) のコメント。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="112">
          <source><ph id="ph1">`==`</ph> (equal) operator for determining whether two values are equal.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`==`</ph> 2 つの値が等しいかどうかを判定するための (等しい) 演算子。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="113">
          <source><ph id="ph1">`!=`</ph> (not equal to) operator for determining whether two values are not equivalent.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`!=`</ph> (等しくない) 2 つの値が等しくないかどうかを決定するための演算子。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="114">
          <source><ph id="ph1">`+`</ph> (plus sign) operator for string concatenation.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`+`</ph> (プラス記号) 文字列連結の演算子です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="115">
          <source>Differences</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">違い</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="116">
          <source>The following table lists X++ features that are different in C#.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルは、C# では異なる X++ の機能を示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="117">
          <source>Feature</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">機能</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="118">
          <source>X++</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="119">
          <source>C#</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C#</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="120">
          <source>Comments</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="121">
          <source><ph id="ph1">`if`</ph> and <ph id="ph2">`else`</ph> conditional statements</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`if`</ph> および <ph id="ph2">`else`</ph> の条件付きステートメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="122">
          <source>The <ph id="ph1">`if`</ph> statement accepts any type of expression that it can automatically convert to a Boolean.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`if`</ph> ステートメントは、ブール値に自動的に変換できる式のあらゆる型を受け付けます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="123">
          <source>Common examples include an <ph id="ph1">`int`</ph> for which 0 means false, or an object for which null means false.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">一般的な例は、0 が false を意味する <ph id="ph1">`int`</ph>、または Null が false を意味するオブジェクトを含みます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="124">
          <source>The <ph id="ph1">`if`</ph> statement requires a Boolean expression.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`if`</ph> ステートメントには、ブール式が必要です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="125">
          <source>The syntax structure regarding curly braces and parentheses is exactly the same between X++ and C#.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">中括弧と括弧に関する構文構造は、X++ と C# でまったく同じです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="126">
          <source>Literal string</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">リテラル文字列</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="127">
          <source>A literal string can be delimited by either of the following:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">リテラル文字列は、次のいずれかの方法で区切ることができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="128">
          <source>A pair of double quotation mark (") characters.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">二重引用符 (") 文字のペア。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="129">
          <source>A pair of single quotation mark (') characters.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">単一引用符 (') 文字のペア。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="130">
          <source>A literal string must be delimited by a pair of double quotation mark (") characters.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">リテラル文字列は、二重引用符 (") のペアで区切る必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="131">
          <source>For X++, the double quotation mark characters are usually used to delimit strings.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ で、二重引用符文字は通常、文字列を区切るために使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="132">
          <source>However, it is convenient delimit a string with single quotation mark characters when your string must contain a double quotation mark character.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、文字列に二重引用符文字を含める必要がある場合、単一引用符文字で文字列を区切るのが便利です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="133">
          <source>char <ph id="ph1">`type`</ph></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">char <ph id="ph1">`type`</ph></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="134">
          <source>There is no <ph id="ph1">`char`</ph> or character type in X++.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ には <ph id="ph1">`char`</ph> または文字タイプがありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="135">
          <source>You can declare a <ph id="ph1">`str`</ph> of length one, but it is still a string:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">長さ 1 の <ph id="ph1">`str`</ph> を宣言することができますが、文字列のままです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="136">
          <source>There is a <ph id="ph1">`char`</ph> in C#.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# には <ph id="ph1">`char`</ph> があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="137">
          <source>You cannot pass a <ph id="ph1">`char`</ph> as the parameter to a method that inputs a <ph id="ph2">`string`</ph> parameter, although you can first explicitly convert the <ph id="ph3">`char`</ph> to a <ph id="ph4">`string`</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">最初に <ph id="ph3">`char`</ph> を <ph id="ph4">`string`</ph> に明示的に変換できますが、パラメーターとして <ph id="ph1">`char`</ph> を <ph id="ph2">`string`</ph> パラメーターを入力するメソッドに渡すことはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="138">
          <source>For more information about X++ data types, see Primitive Data Types.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ データ型の詳細については、プリミティブ データ型を参照してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="139">
          <source>Output of messages</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メッセージの出力</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="140">
          <source>X++ delivers messages to the user in the Infolog window.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ は情報ログ ウィンドウ内でユーザーにメッセージを提供します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="141">
          <source>Common methods include the following:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">一般的なメソッドは次のとおりです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="142">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>print<ept id="p1">&lt;/strong&gt;</ept> statement:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>print<ept id="p1">&lt;/strong&gt;</ept> ステートメント:</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="143">
          <source>static methods on the <ph id="ph1">`Global`</ph> class:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`Global`</ph> クラスの静的メソッド:</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="144">
          <source>Global::info</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Global::info</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="145">
          <source>Global::warning</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Global::warning</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="146">
          <source>Global::error</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Global::error</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="147">
          <source>For a command line program, messages can be delivered to the console.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コマンド ライン プログラムで、コンソールにメッセージを配信することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="148">
          <source>Common methods include the following:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">一般的なメソッドは次のとおりです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="149">
          <source>X++ and C++ Samples</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ および C++ のサンプル</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="150">
          <source>This section contains two simple code samples.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このセクションには、2 つの簡単なコード サンプルが含まれています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="151">
          <source>One sample is written in X++, and the other is in C<ph id="ph1">\#</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">1 つの例は X++、もう一方は C<ph id="ph1">\#</ph> で記述されています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="152">
          <source>Both samples achieve the same result.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">両方のサンプルで同じ結果が得られます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="153">
          <source>The following X++ features are demonstrated:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の X++ 機能が示されています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="154">
          <source><ph id="ph1">`//`</ph> single line comment</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`//`</ph> 単一行のコメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="155">
          <source><ph id="ph1">/</ph><ph id="ph2">\*</ph> <ph id="ph3">\*</ph>/ multi-line comment</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">/</ph><ph id="ph2">\*</ph> <ph id="ph3">\*</ph>/ 複数行コメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="156">
          <source><ph id="ph1">`if`</ph> statement</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`if`</ph> ステートメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="157">
          <source><ph id="ph1">`==`</ph> operator</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`==`</ph> 演算子</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="158">
          <source><ph id="ph1">`!=`</ph> operator</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`!=`</ph> 演算子</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="159">
          <source><ph id="ph1">`+`</ph> operator to concatenate strings</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`+`</ph> 文字列を連結する演算子</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="160">
          <source>Global::info for message output, with and without the Global:: prefix</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Global:: 接頭語を使用する場合と使用しない場合の、メッセージ出力の Global::info</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="161">
          <source>Global::error for message output</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メッセージ出力の Global::error</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="162">
          <source>The use of single and double quotation characters (' and ") as string delimiters.</source>
        <target logoport:matchpercent="100" state="translated" state-qualifier="leveraged-tm">文字列区切り文字としての一重引用符および二重引用符 (' および ") の使用。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="163">
          <source>The best practice is to use double quotation marks for any string that might be displayed to the user.</source><target logoport:matchpercent="95" state="translated" state-qualifier="fuzzy-match">ユーザーに公開される可能性のある、すべての文字列に二重引用符を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="164">
          <source>X++ Sample</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ サンプル</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="165">
          <source>This X++ code sample is in the form of a job.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この X++ コード サンプルでは、ジョブの形式です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="166">
          <source>There is a node titled Jobs in the Application Object Tree (AOT).</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">アプリケーション オブジェクト ツリー (AOT) にジョブというノードがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="167">
          <source>This sample can be added under the Jobs node, and then the job can be run.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この例を [ジョブ] ノードの下に追加して、ジョブを実行することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="168">
          <source>Output</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">出力</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="169">
          <source>Here is the output from the Infolog window: Message (09:49:48) Hello World, 1.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">情報ログ ウィンドウからの出力を次に示します: メッセージ (09:49:48) Hello World、1。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="170">
          <source>Hello World, 2.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Hello World、2。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="171">
          <source>This is like info, but is for warnings, 3.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これは、情報のようなものですが、警告、3 です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="172">
          <source>This is like info, but is for errors, 4.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これは、情報のようなものですが、エラー、4 です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="173">
          <source>C# Sample</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# サンプル</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="174">
          <source>The following C# program is a rewrite of the previous X++ program.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の C# プログラムは、以前の X++ プログラムを書き直したものです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="175">
          <source>The differences between X++ and C# are highlighted by commenting out the X++ lines, and replacing them with the C# syntax.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ と C# の違いは、X++ の行をコメントアウトして C# の構文に置き換えることで強調表示されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="176">
          <source>C#</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C#</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="177">
          <source>Output</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">出力</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="178">
          <source>Here is the actual output to the C# console:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# コンソールへの実際の出力を次に示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="179">
          <source>X++, C# Comparison: Loops</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++、C# の比較: ループ</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="180">
          <source>This section compares the loop features between X++ and C<ph id="ph1">\#</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このセクションでは、X++ と C<ph id="ph1">\#</ph> の間のループの特徴を比較します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="181">
          <source>Similarities</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">類似点</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="182">
          <source>The following features are the same in X++ and C<ph id="ph1">\#</ph>:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の機能は、X++ と C<ph id="ph1">\#</ph> で同じです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="183">
          <source>Declarations for variables of the int primitive data type.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">int プリミティブ データ型の変数の宣言。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="184">
          <source>Declarations for other primitive types are almost the same, but the types might have different names.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">他のプリミティブ型の宣言はほとんど同じですが、型の名前が異なる可能性があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="185">
          <source>while statement for loops.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ループ用 while ステートメント。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="186">
          <source>break statement to exit a loop.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ループを終了する break ステートメント。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="187">
          <source>continue statement to jump up to the top of a loop.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ループの先頭に移動するための continue ステートメント。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="188">
          <source>&lt;= (less than or equal) comparison operator.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">&lt;= (以下) 比較演算子です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="189">
          <source>Differences</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">違い</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="190">
          <source>The following table lists X++ features that are different in C#.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルは、C# では異なる X++ の機能を示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="191">
          <source>Features</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">機能</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="192">
          <source>X++</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="193">
          <source>C#</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C#</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="194">
          <source>Comments</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="195">
          <source>The <ph id="ph1">`for`</ph> statement.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`for`</ph> ステートメント。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="196">
          <source>The for statement is available for loops.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">for 明細書はループで使用できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="197">
          <source>The C# <ph id="ph1">`for`</ph> statement is slightly different from <ph id="ph2">`for`</ph> in X++.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# <ph id="ph1">`for`</ph> ステートメントは、X++ の <ph id="ph2">`for`</ph> と少し異なります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="198">
          <source>In C# you can declare the counter integer in the <ph id="ph1">`for`</ph> statement.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、<ph id="ph1">`for`</ph> ステートメントでカウンター整数を宣言できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="199">
          <source>But in X++ the counter must be declared outside the <ph id="ph1">`for`</ph> statement.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし X++ では、カウンターは <ph id="ph1">`for`</ph> ステートメントの外側で宣言する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="200">
          <source>++ increment operator.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">++ 増分の演算子。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="201">
          <source>An ++ increment operator is available in X++.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">++ 増分の演算子は X++ で利用可能です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="202">
          <source>But an <bpt id="p1">&lt;strong&gt;</bpt>int<ept id="p1">&lt;/strong&gt;</ept> variable that is decorated with ++ can only be used as a statement, not as an expression.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、++ で修飾された <bpt id="p1">&lt;strong&gt;</bpt>int<ept id="p1">&lt;/strong&gt;</ept> 変数は式としてではなく、ステートメントとしてのみ使用できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="203">
          <source>For example, the following lines of X++ code would not compile:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">たとえば、次の X++ コードの行はコンパイルしません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="204">
          <source>However, the following lines of X++ code would compile:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、次の X++ コードの行はコンパイルします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="205">
          <source>The C# ++ operator is more flexible than in X++.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# 演算子は、X++ での方が柔軟です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="206">
          <source>The following lines of code are the same in both languages:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のコード行は、両方の言語で同じです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="207">
          <source>++ myInteger;</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">++ myInteger;</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="208">
          <source>myInteger++;</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">myInteger++;</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="209">
          <source>But the following lines of code have a different effect from each other, and are valid only in C#:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、次のコード行は互いに異なる効果を持ち、C# でのみ有効です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="210">
          <source>yourInt = ++myInt;</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">yourInt = ++myInt;</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="211">
          <source>yourInt = myInt++;</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">yourInt = myInt++;</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="212">
          <source>modulo operator.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">剰余演算子。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="213">
          <source>In X++ the modulo operator is mod.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、剰余演算子は mod です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="214">
          <source>In C# the modulo operator is %.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、剰余演算子は % です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="215">
          <source>The symbols for the modulo operator are different, but their behavior is the same in both languages.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">モジュロ演算子のシンボルは異なりますが、その動作は両方の言語で同じです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="216">
          <source>Temporarily suspend a console program that has already begun.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">既に開始されているコンソール プログラムを一時的に中断します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="217">
          <source>The <ph id="ph1">`pause`</ph> statement.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`pause`</ph> ステートメント。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="218">
          <source>In C#, a command line program can be paused by the following line of code:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、コマンド ライン プログラムを次のコード行で一時停止することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="219">
          <source>In X++ you continue by clicking an OK button on a modal dialog box.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、モーダル ダイアログ ボックスで OK ボタンをクリックして続行します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="220">
          <source>In C# you continue by pressing any keyboard on the keyboard.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、キーボードの任意のキーボードを押して続行します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="221">
          <source>Display a message.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メッセージを表示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="222">
          <source>In X++, the <ph id="ph1">`print`</ph> statement displays a message in the Print window.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、<ph id="ph1">`print`</ph> ステートメントは印刷ウィンドウにメッセージを表示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="223">
          <source>In C# a message can be displayed on the console by the following line of code:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、次のコード行でメッセージをコンソールに表示することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="224">
          <source>The X++ <ph id="ph1">`print`</ph> function is used only when you test.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ <ph id="ph1">`print`</ph> 関数は、テスト時にのみ使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="225">
          <source>An X++ program that uses <ph id="ph1">`print`</ph> almost always uses the <ph id="ph2">`pause`</ph> statement somewhere later in the code.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`print`</ph> を使用する X++ プログラムは、ほとんどの場合コード内のどこか後で <ph id="ph2">`pause`</ph> 明細書を使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="226">
          <source>For production X++ code, use the Global::info Method instead of <ph id="ph1">`print`</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">生産 X++ コードについては、<ph id="ph1">`print`</ph> の代わりに Global::info メソッドを使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="227">
          <source>The <ph id="ph1">`strfmt`</ph> function is often used together with <ph id="ph2">`info`</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`strfmt`</ph> 関数はしばしば <ph id="ph2">`info`</ph> と一緒に使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="228">
          <source>There is no reason to use <ph id="ph1">`pause`</ph> after <ph id="ph2">`info`</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph2">`info`</ph> の後に <ph id="ph1">`pause`</ph> を使用する理由はありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="229">
          <source>Make a sound.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">音を作成します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="230">
          <source>The beep function makes a sound that you can hear.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ビープ音機能は、人間に聞こえる音を鳴らします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="231">
          <source>In C# a sound that you can hear is issued by the following line of code:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、聞こえるサウンドが次のコード行で発行されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="232">
          <source>The statements each produce a short tone.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ステートメントはそれぞれ短いトーンを作ります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="233">
          <source>Print and Global::info</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Print および Global::info</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="234">
          <source>The X++ code samples for loops use the <ph id="ph1">`print`</ph> function to display results.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ループ用の X++ コード サンプルは、<ph id="ph1">`print`</ph> 関数を使用して結果を表示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="235">
          <source>In X++ you can use the <ph id="ph1">`print`</ph> statement can display any primitive data type without having to call functions that convert it to a string first.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、<ph id="ph1">`print`</ph> ステートメントを使用して、まず文字列に変換する関数を呼び出すことなく、任意のプリミティブ データ型を表示できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="236">
          <source>This makes <ph id="ph1">`print`</ph> useful in quick test situations.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これにより、簡単なテスト環境では <ph id="ph1">`print`</ph> が便利になります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="237">
          <source>Generally the Global::info method is used more often than <ph id="ph1">`print`</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">一般に、Global::info メソッドは <ph id="ph1">`print`</ph> より頻繁に使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="238">
          <source>The <ph id="ph1">`info`</ph> method can only display strings.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`info`</ph> メソッドは文字列のみを表示できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="239">
          <source>Therefore the strfmt function is often used together with <ph id="ph1">`info`</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">したがって、strfmt 関数はしばしば <ph id="ph1">`info`</ph> と一緒に使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="240">
          <source>A limitation of <ph id="ph1">`print`</ph> is that you cannot copy the contents of the Print window to the clipboard (such as with Ctrl+C).</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">印刷ウィンドウの内容をクリップボードにコピー (Ctrl+C などで) できない <ph id="ph1">`print`</ph> の制限。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="241">
          <source>Global::info writes to the Infolog window which does support copy to the clipboard.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Global::info は情報ログ ウィンドウに書き込みをし、クリップボードへのコピーをサポートします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="242">
          <source>Example 1: The while Loop</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例 1: While Loop</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="243">
          <source>The <bpt id="p1">**</bpt>while<ept id="p1">**</ept> keyword supports looping in both X++ and C#.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>while<ept id="p1">**</ept> キーワードは、X++ と C# 両方でのループをサポートします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="244">
          <source>X++ Sample of while</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ while のサンプル</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="245">
          <source>}</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">}</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="246">
          <source>Output</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">出力</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="247">
          <source>The output in the X++ Print window is as follows:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ 印刷ウィンドウの出力は次のようになります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="248">
          <source>C# Sample of while</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# 中のサンプル</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="249">
          <source>C#</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C#</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="250">
          <source>Output</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">出力</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="251">
          <source>The console output from the C# program is as follows:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# プログラムのコンソール出力は次のとおりです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="252">
          <source>Example 2: The for Loop</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例 2: For Loop</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="253">
          <source>The <bpt id="p1">**</bpt>for<ept id="p1">**</ept> keyword supports looping in both X++ and C#.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>for<ept id="p1">**</ept> キーワードは、X++ と C# 両方でのループをサポートします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="254">
          <source>X++ Sample of for</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ for のサンプル</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="255">
          <source>In X++ the counter variable cannot be declared as part of the <bpt id="p1">**</bpt>for<ept id="p1">**</ept> statement.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、カウンター変数は <bpt id="p1">**</bpt>for<ept id="p1">**</ept> ステートメントの一部として宣言できません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="256">
          <source>}</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">}</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="257">
          <source>Output</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">出力</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="258">
          <source>The output in the X++ Print window is as follows:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ 印刷ウィンドウの出力は次のようになります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="259">
          <source>C# Sample of for</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# のサンプル</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="260">
          <source>C#</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C#</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="261">
          <source>Output</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">出力</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="262">
          <source>The console output from the C# program is as follows: 1 (Press any key to resume.) 2 (Press any key to resume.) 3 (Press any key to resume.) 4 (Press any key to resume.) (Press any key to resume.)</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# プログラムのコンソール出力は次のとおりです。1 (任意のキーを押して再開します。) 2 (任意のキーを押して再開します。) 3 (任意のキーを押して再開します。) 4 (任意のキーを押して再開します。) (任意のキーを押して再開します。)</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="263">
          <source>X++, C# Comparison: Switch</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++、C# の比較: Switch</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="264">
          <source>In both X++ and C#, the <bpt id="p1">**</bpt>switch<ept id="p1">**</ept> statement involves the keywords <bpt id="p2">**</bpt>case<ept id="p2">**</ept>, <bpt id="p3">**</bpt>break<ept id="p3">**</ept>, and <bpt id="p4">**</bpt>default<ept id="p4">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ と C# の両方では、<bpt id="p1">**</bpt>switch<ept id="p1">**</ept> ステートメントに、キーワード <bpt id="p2">**</bpt>case<ept id="p2">**</ept>、<bpt id="p3">**</bpt>break<ept id="p3">**</ept>、および <bpt id="p4">**</bpt>default<ept id="p4">**</ept> があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="265">
          <source>The following table lists the differences in the <bpt id="p1">**</bpt>switch<ept id="p1">**</ept> statement between X++ and C<ph id="ph1">\#</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルは、X++ および C<ph id="ph1">\#</ph> の間の <bpt id="p1">**</bpt>switch<ept id="p1">**</ept> ステートメントの相違点を示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="266">
          <source>Feature</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">機能</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="267">
          <source>X++</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="268">
          <source>C#</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C#</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="269">
          <source>Comments</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="270">
          <source><ph id="ph1">`break;`</ph> at the end of each case block</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">各 case ブロックの末尾の <ph id="ph1">`break;`</ph></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="271">
          <source>In X++, when any <bpt id="p1">**</bpt>case<ept id="p1">**</ept> block matches the expression value on the <bpt id="p2">**</bpt>switch<ept id="p2">**</ept> clause, all other <bpt id="p3">**</bpt>case<ept id="p3">**</ept> and <bpt id="p4">**</bpt>default<ept id="p4">**</ept> blocks are executed until a <ph id="ph1">`break;`</ph> statement is reached.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、いずれかの <bpt id="p1">**</bpt>case<ept id="p1">**</ept> ブロックが <bpt id="p2">**</bpt>switch<ept id="p2">**</ept> 句の式の値と一致する場合、<ph id="ph1">`break;`</ph> ステートメントに達するまで他のすべての <bpt id="p3">**</bpt>case<ept id="p3">**</ept> および <bpt id="p4">**</bpt>default<ept id="p4">**</ept> ブロックが実行されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="272">
          <source>No <ph id="ph1">`break;`</ph> statement is ever required in an X++ <bpt id="p1">**</bpt>switch<ept id="p1">**</ept> statement, but <ph id="ph2">`break;`</ph> statements are important in almost all practical situations.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`break;`</ph> ステートメントは、X++ の <bpt id="p1">**</bpt>switch<ept id="p1">**</ept> ステートメントでは必要ありませんが、<ph id="ph2">`break;`</ph> ステートメントはほとんどすべての実践的な状況において重要です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="273">
          <source>In C<ph id="ph1">\#</ph>, a <ph id="ph2">`break;`</ph> statement is always needed after the statements in a <bpt id="p1">**</bpt>case<ept id="p1">**</ept> or <bpt id="p2">**</bpt>default<ept id="p2">**</ept> block.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C<ph id="ph1">\#</ph> では、<ph id="ph2">`break;`</ph> ステートメントが <bpt id="p1">**</bpt>case<ept id="p1">**</ept> または <bpt id="p2">**</bpt>default<ept id="p2">**</ept> ブロックのステートメントの後に常に必要になります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="274">
          <source>If a <bpt id="p1">**</bpt>case<ept id="p1">**</ept> clause has no statements between itself and the next <bpt id="p2">**</bpt>case<ept id="p2">**</ept> clause, a <ph id="ph1">`break;`</ph> statement is not required between the two <bpt id="p3">**</bpt>case<ept id="p3">**</ept> clauses.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>ケース<ept id="p1">**</ept>句に次の<bpt id="p2">**</bpt>ケース<ept id="p2">**</ept>句との間のステートメントがない場合、2 つの<bpt id="p3">**</bpt>ケース<ept id="p3">**</ept>節の間に <ph id="ph1">`break;`</ph> ステートメントは必要ありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="275">
          <source>We recommend against omitting the <ph id="ph1">`break;`</ph> statement after any case <bpt id="p1">**</bpt>block<ept id="p1">**</ept>, because it can confuse the next programmer who edits the code.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コードを編集する次のプログラマが混乱する可能性があるので、case <bpt id="p1">**</bpt>ブロック<ept id="p1">**</ept> の後の <ph id="ph1">`break;`</ph> ステートメントを省略することをお勧めしません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="276">
          <source><ph id="ph1">`break;`</ph> at the end of the <bpt id="p1">**</bpt>default<ept id="p1">**</ept> block</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>既定<ept id="p1">**</ept>ブロックの末尾の <ph id="ph1">`break;`</ph></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="277">
          <source>In X++ there is no effect of adding a <ph id="ph1">`break;`</ph> statement at the end of the <bpt id="p1">**</bpt>default<ept id="p1">**</ept> block.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、<ph id="ph1">`break;`</ph> ステートメントを <bpt id="p1">**</bpt>default<ept id="p1">**</ept> ブロックの最後に追加する効果はありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="278">
          <source>In C<ph id="ph1">\#</ph> the compiler requires a <ph id="ph2">`break;`</ph> statement at the end of the <bpt id="p1">**</bpt>default<ept id="p1">**</ept> block.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C<ph id="ph1">\#</ph> では、コンパイラは <bpt id="p1">**</bpt>default<ept id="p1">**</ept> ブロックの最後に <ph id="ph2">`break;`</ph> ステートメントを必要とします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="279">
          <source>For more information, see Switch Statements.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">詳細については、「明細書の切り替え」を参照してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="280">
          <source>Only constant values on a <bpt id="p1">**</bpt>case<ept id="p1">**</ept> block</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>case<ept id="p1">**</ept> ブロックの定数値のみ</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="281">
          <source>In X++ you can specify either a literal value or a variable on a case block.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、case ブロックでリテラル値または変数のいずれかを指定できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="282">
          <source>For example, you can write case myInteger:.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">たとえば、ケース myInteger: を書き込むことができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="283">
          <source>In C<ph id="ph1">\#</ph> you must specify exactly one literal value on each <bpt id="p1">**</bpt>case<ept id="p1">**</ept> block, and no variables are allowed.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C<ph id="ph1">\#</ph> では、<bpt id="p1">**</bpt>case<ept id="p1">**</ept> ブロックごとに正確に 1 つのリテラル値を指定する必要があり、変数は許可されていません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="284">
          <source>No comments.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメントはありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="285">
          <source>Multiple values on one <bpt id="p1">**</bpt>case<ept id="p1">**</ept> block</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">1 つの <bpt id="p1">**</bpt>case<ept id="p1">**</ept> ブロックにある複数の値</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="286">
          <source>In X++ you can specify multiple values on each case block.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、case ブロックごとに複数の値を指定できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="287">
          <source>The values must be separated by a comma.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">値は、コンマで区切る必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="288">
          <source>For example, you can write <ph id="ph1">`case 4,5,myInteger:`</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">たとえば、<ph id="ph1">`case 4,5,myInteger:`</ph> を書き込むことができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="289">
          <source>In C<ph id="ph1">\#</ph> you must specify exactly one value on each <bpt id="p1">**</bpt>case<ept id="p1">**</ept> block.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C<ph id="ph1">\#</ph> では、<bpt id="p1">**</bpt>case<ept id="p1">**</ept> ブロックごとに正確に 1 つの値を指定する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="290">
          <source>In X++ it is better to write multiple values on one <bpt id="p1">**</bpt>case<ept id="p1">**</ept> block than to omit the <ph id="ph1">`break;`</ph> statement at the end of one or more case blocks.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、1 つまたは複数の case ブロックの最後にある <ph id="ph1">`break;`</ph> ステートメントを省略するよりも、<bpt id="p1">**</bpt>case<ept id="p1">**</ept> ブロックに複数の値を書き込む方が適切です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="291">
          <source>Code Examples for switch</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">切り替えのコードの例</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="292">
          <source>The following sections show comparable switch statements in X++ and C<ph id="ph1">\#</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のセクションでは、X++ と C<ph id="ph1">\#</ph> での比較可能な switch ステートメントを示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="293">
          <source>X++ switch Example</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ 切り替えの例</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="294">
          <source>The X++ switch example shows the following:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">以下に、X++ スイッチの例を示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="295">
          <source>case iTemp: and case (93-90): to show that <bpt id="p1">**</bpt>case<ept id="p1">**</ept> expressions are not limited to constants, as they are in C<ph id="ph1">\#</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">case iTemp: および case (93-90): は、<bpt id="p1">**</bpt>case<ept id="p1">**</ept> 式は、C<ph id="ph1">\#</ph> とは異なり、定数に限定されないことを示すため。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="296">
          <source><ph id="ph1">`//break;`</ph> to show that <ph id="ph2">`break;`</ph> statements are not required in X++, although they are almost always desirable.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`//break;`</ph> は、 X++ では <ph id="ph2">`break;`</ph> ステートメントが必須ではないことを示していますが、ほとんどの場合望ましいです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="297">
          <source>case 2, (93-90), 5: to show that multiple expressions can be listed on one <bpt id="p1">**</bpt>case<ept id="p1">**</ept> clause in X++.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">case 2, (93-90), 5: は、X++ でが、1 つの <bpt id="p1">**</bpt>case<ept id="p1">**</ept> 句に複数の式をリストできることを示すため。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="298">
          <source>X++</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="299">
          <source>C# switch Example</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# 切り替えの例</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="300">
          <source>The C<ph id="ph1">\#</ph> switch example shows the following:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">以下に、C<ph id="ph1">\#</ph> スイッチの例を示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="301">
          <source>case 1: has a comment explaining that only constant expressions can be given on a <bpt id="p1">**</bpt>case<ept id="p1">**</ept> clause.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">case 1: には、<bpt id="p1">**</bpt>case<ept id="p1">**</ept> 句では定数式のみを指定できることを説明したコメントがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="302">
          <source><ph id="ph1">`break;`</ph> statements occur after the last statement in each <bpt id="p1">**</bpt>case<ept id="p1">**</ept> block that has statements, as is required by C<ph id="ph2">\#</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`break;`</ph> ステートメントは、 C<ph id="ph2">\#</ph> で必要とされるステートメントを持つ各 <bpt id="p1">**</bpt>case<ept id="p1">**</ept> ブロックの最後のステートメントの後に発生します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="303">
          <source>C#</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C#</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="304">
          <source>X++, C# Comparison: String Case and Delimiters</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++、C# の比較: 文字列の大文字小文字の区別および区切り記号</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="305">
          <source>This section compares the treatment of strings with mixed casing in X++ and C<ph id="ph1">\#</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このセクションでは、X++ と C<ph id="ph1">\#</ph> の混合ケーシングによる文字列の処理を比較します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="306">
          <source>It also explains the string delimiters that are available in X++.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">また、X++ で使用できる文字列の区切り記号についても説明します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="307">
          <source>Similarities</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">類似点</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="308">
          <source>The following X++ features are the same as in C<ph id="ph1">\#</ph>:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の X++ 機能は C<ph id="ph1">\#</ph> の機能と同じです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="309">
          <source>The backslash (<ph id="ph1">\\</ph>) is the escape operator for string delimiters.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">バックスラッシュ (<ph id="ph1">\\</ph>) は、文字列の区切り記号のエスケープ演算子です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="310">
          <source>The at sign (@) nullifies the escape effect of the backslash when the at sign is written immediately before the open quotation mark of a string.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">アット マーク (@) は、文字列の開始引用符の直前に書かれていると、バックスラッシュのエスケープ効果を無効にします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="311">
          <source>The plus sign (+) is the string concatenation operator.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">プラス記号 (+) は文字列連結演算子です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="312">
          <source>Differences</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">違い</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="313">
          <source>X++ features that are different in C<ph id="ph1">\#</ph> are listed in the following table.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C<ph id="ph1">\#</ph> では異なる X++ 機能を以下の表に一覧表示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="314">
          <source>Feature</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">機能</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="315">
          <source>X++</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="316">
          <source>C#</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C#</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="317">
          <source>Comments</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="318">
          <source><ph id="ph1">`== `</ph>comparison operator</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`== `</ph>比較演算子</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="319">
          <source>Insensitive: the <ph id="ph1">`==`</ph> operator is insensitive to differences in string casing.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">区別しない: <ph id="ph1">`==`</ph> 演算子は文字列の大文字と小文字の差異を区別しません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="320">
          <source>In C#, the <ph id="ph1">`==`</ph> operator is sensitive to differences in string casing.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、<ph id="ph1">`==`</ph> 演算子は文字列の大文字と小文字の差異を区別します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="321">
          <source>In X++ you can use the strCmp Function for case sensitive comparisons between strings.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、文字列間の大文字と小文字の比較には strCmp 関数を使用できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="322">
          <source>String delimiters</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">文字列の区切り記号</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="323">
          <source>In X++ you can use either the single (') or double (<ph id="ph1">`"`</ph>) quotation mark as the string delimiter.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、文字列の区切り記号として単一引用符 (') または二重引用符 (<ph id="ph1">`"`</ph>) のいずれかを使用できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="324">
          <source><bpt id="p1">&lt;strong&gt;</bpt>Note:<ept id="p1">&lt;/strong&gt;</ept> Usually the best practice is to use double quotation marks for strings that might be displayed to the user.</source><target logoport:matchpercent="98" state="translated" state-qualifier="fuzzy-match"><bpt id="p1">&lt;strong&gt;</bpt>注記<ept id="p1">&lt;/strong&gt;</ept>: ユーザーに公開される可能性のある文字列に、二重引用符を使用することを推奨しています。</target>
        </trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="325">
          <source>However, it is convenient to delimit a string with single quotation marks when a double quotation mark is one of the characters in the string.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、二重引用符文字が文字列の文字のいずれかである場合、単一引用符で文字列を区切るのが便利です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="326">
          <source>In C# you must use the double quotation mark as the string delimiter.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、文字列の区切り記号として二重引用符を使用する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="327">
          <source>This refers to the type <ph id="ph1">`System.String`</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これは、タイプ <ph id="ph1">`System.String`</ph> を指します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="328">
          <source>In X++ and C# you have the option of embedding a delimiter in a literal string and escaping it with \.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ および C# では、リテラル文字列の区切り記号を埋め込み、\ でエスケープするオプションがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="329">
          <source>In X++ you also have the alternative of embedding single quotation marks in a string that is delimited by double quotation marks (or the reverse), without having to use the escape.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、エスケープを使用しなくても、二重引用符で区切られた文字列に単一引用符 (または逆) を埋め込むことで代用することもできます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="330">
          <source>Character delimiters</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">文字区切り文字</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="331">
          <source>X++ has a string data type (<ph id="ph1">`str`</ph>), but no character type.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ には文字列データ型 (<ph id="ph1">`str`</ph>) がありますが、文字の種類はありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="332">
          <source>In C# you must use the single quotation mark as the character delimiter.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、文字の区切り記号として単一引用符を使用する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="333">
          <source>This refers to the type <ph id="ph1">`System.Char`</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これは、タイプ <ph id="ph1">`System.Char`</ph> を指します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="334">
          <source>In the .NET Framework, a <ph id="ph1">`System.String`</ph> of length one is a different data type than a <ph id="ph2">`System.Char`</ph> character.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">.NET Framework では、長さが 1 の <ph id="ph1">`System.String`</ph> は <ph id="ph2">`System.Char`</ph> 文字とは異なるデータ型です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="335">
          <source>Example 1: Case Sensitivity of the == Operator</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例 1: Case Sensitivity of the == オペレーター</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="336">
          <source>The <ph id="ph1">`==`</ph> and != operators are case insensitive in X++, but are case sensitive in C<ph id="ph2">\#</ph>, as is illustrated by the following example.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の例に示すように、<ph id="ph1">`==`</ph> と != 演算子は、X++ では大文字と小文字が区別されませんが、C<ph id="ph2">\#</ph> では区別されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="337">
          <source>X++</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="338">
          <source>C#</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C#</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="339">
          <source>Comments</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="340">
          <source>True in X++.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ の場合も同様です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="341">
          <source>False in C#.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# の False。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="342">
          <source>Different case comparisons between X++ and C#.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ と C# の間の異なるケース比較。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="343">
          <source>Example 2: The + String Concatenation Operator</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例 2: The + 文字列連結オペレーター</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="344">
          <source>The + and += operators are used to concatenate strings in both X++ and C<ph id="ph1">\#</ph>, as is shown by the examples in the following table.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">+ および = 演算子は、次の表の例に示すように、X++ と C<ph id="ph1">\#</ph> の両方で文字列を連結するために使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="345">
          <source>X++</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="346">
          <source>C#</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C#</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="347">
          <source>Comments</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="348">
          <source>Result is equality:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">結果は等しくなります:</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="349">
          <source>(Same as for X++.)</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">(X++ と同じです。)</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="350">
          <source>In both X++ and C#, the behavior of the + operator depends on the data type of its operands.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ と C# の両方では、+ 演算子の動作はオペランドのデータ型によって異なります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="351">
          <source>The operator concatenates strings, or adds numbers.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">演算子は、文字列を連結したり、数値を追加します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="352">
          <source>Result is equality: <ph id="ph1">`myString2 == "Hello world"`</ph></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">結果は等しくなります: <ph id="ph1">`myString2 == "Hello world"`</ph></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="353">
          <source>(Same as for X++.)</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">(X++ と同じです。)</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="354">
          <source>In both X++ and C#, the following statements are equivalent:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ と C# の両方では、次のステートメントは同じです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="355">
          <source>Example 3: Embedding and Escaping String Delimiters</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例 3: 文字列の区切り記号を埋め込みおよび分離</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="356">
          <source>Either single or double quotation marks can be used to delimit strings in X++.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ の文字列を区切るには、単一または二重引用符を使用できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="357">
          <source>The escape character (<ph id="ph1">\\</ph>) can be used to embed delimiters in a string.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">エスケープ文字 (<ph id="ph1">\\</ph>) は、区切り記号を文字列に埋め込むために使用できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="358">
          <source>These are illustrated in the following table.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この点については、次のテーブルを参照してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="359">
          <source>X++</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="360">
          <source>C#</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C#</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="361">
          <source>Comments</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="362">
          <source>Result:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">結果:</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="363">
          <source>(Same as for X++.)</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">(X++ と同じです。)</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="364">
          <source>The escape character enables you to embed string delimiters inside strings.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">エスケープ文字を使用すると、文字列の区切り記号を文字列に埋め込むことができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="365">
          <source>Result:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">結果:</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="366">
          <source>C# syntax does not allow for single quotation marks to delimit strings.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# 構文では、文字列を区切るための単一引用符は使用できません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="367">
          <source>For strings that may be seen by the user, it is considered a best practice to use the escape character instead of the single quotation marks as shown in the example.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ユーザーにより表示される場合のある文字列については、次の例で示すように、単一引用符ではなくエスケープ文字を使用するためのベスト プラクティスと見なされます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="368">
          <source>Result:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">結果:</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="369">
          <source>(Same as for X++.)</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">(X++ と同じです。)</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="370">
          <source>In X++, the single quotation marks are not treated as delimiters unless the string starts with a single quotation mark delimiter.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、文字列が単一引用符の区切り記号で始まらない限り、単一引用符は区切り記号として扱われません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="371">
          <source>In C# the single quotation mark has no special meaning for strings, and it cannot be used to delimit strings.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、単一引用符に文字列の特別な意味はなく、文字列を区切るために使用することはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="372">
          <source>In C# the single quotation mark is the required delimiter for literals of type <ph id="ph1">`System.Char`</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、単一引用符は型 <ph id="ph1">`System.Char`</ph> のリテラルに必要な区切り記号です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="373">
          <source>X++ has no character data type.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ には文字データ型がありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="374">
          <source>Here the single quotation is a string delimiter.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ここで、単一引用符は文字列の区切り記号です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="375">
          <source>Here the single quotation mark is a <ph id="ph1">`System.Char`</ph> delimiter, not a <ph id="ph2">`System.String`</ph> delimiter.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ここで、単一引用符は <ph id="ph2">`System.String`</ph> 区切り記号ではなく、<ph id="ph1">`System.Char`</ph> 区切り記号です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="376">
          <source>X++ has no data type that corresponds to <ph id="ph1">`System.Char`</ph> in the .NET Framework.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ には .NET Framework の <ph id="ph1">`System.Char`</ph> に対応するデータ型はありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="377">
          <source>An X++ string that is limited to a length of one is still a string, not a character data type.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">長さが 1 に制限されている X++ 文字列は、まだ文字列であり、文字データ型ではありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="378">
          <source>Example 4: Single Escape Character</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例 4: 単一のエスケープ文字</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="379">
          <source>Examples that illustrate the single escape character in either the input or the output are shown in the following table.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">入力または出力の単一のエスケープ文字を示す例を次の表に示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="380">
          <source>X++</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="381">
          <source>C#</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C#</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="382">
          <source>Comments</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="383">
          <source>Result:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">結果:</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="384">
          <source>A literal string in C# cannot contain the two character sequence of escape followed by a space, such as "\ ".</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# のリテラル文字列には、"\ " のようにエスケープの後にスペースが続く 2 つの文字シーケンスを含めることはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="385">
          <source>A compiler error occurs.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コンパイラ エラーが発生します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="386">
          <source>When the X++ compiler encounters the two character sequence of "\ ", it discards the single escape character.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ コンパイラは、連続した 2 文字の "\" を検出すると、その 1 つのエスケープ文字は切り捨てます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="387">
          <source>Result:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">結果:</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="388">
          <source>(Same as for X++.)</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">(X++ と同じです。)</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="389">
          <source>In a pair of escape characters, the first negates the special meaning of the second.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">エスケープ文字のペアにおいて、1 文字目は 2 文字目の特別な意味をなくします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="390">
          <source>Comparison: Array Syntax</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">比較: 配列の構文</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="391">
          <source>There are similarities and differences in the features and syntax for arrays in X++ versus C<ph id="ph1">\#</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ と C<ph id="ph1">\#</ph> の配列の機能と構文には類似点と相違点があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="392">
          <source>Similarities</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">類似点</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="393">
          <source>Overall there is much similarity in the syntax and treatment of arrays in X++ and C#.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ と C# の配列の構文と処理は、全体的にかなり似ています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="394">
          <source>However there are many differences.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、多くの違いがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="395">
          <source>Differences</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">違い</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="396">
          <source>The following table lists areas in the [] syntax for arrays that are different for X++ and C#.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルは、X++ と C#で異なる配列の [] 構文の領域を示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="397">
          <source>Category</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">カテゴリ</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="398">
          <source>X++</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="399">
          <source>C#</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C#</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="400">
          <source>Comments</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="401">
          <source>Declaration</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">申告</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="402">
          <source>An array is declared with square brackets appended to the variable name.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">配列は変数名に追加され角カッコ付きで宣言されています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="403">
          <source>An array is declared with square brackets appended to the data type.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">配列はデータ型に追加され角カッコ付きで宣言されています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="404">
          <source><bpt id="p1">&lt;strong&gt;</bpt>Note:<ept id="p1">&lt;/strong&gt;</ept> An X++ array cannot be a parameter in a method.</source><target logoport:matchpercent="98" state="translated" state-qualifier="fuzzy-match"><bpt id="p1">&lt;strong&gt;</bpt>注記<ept id="p1">&lt;/strong&gt;</ept>: X++ 配列をメソッド内のパラメーターにすることはできません。</target>
        </trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="405">
          <source>Declaration</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">申告</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="406">
          <source>The array syntax supports only primitive data types, such as <ph id="ph1">`int`</ph> and <ph id="ph2">`str`</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">配列の構文は、<ph id="ph1">`int`</ph> や <ph id="ph2">`str`</ph> などのプリミティブ データ型のみをサポートします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="407">
          <source>The syntax does not support classes or tables.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">構文はクラスまたはテーブルをサポートしていません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="408">
          <source>The array syntax supports primitive data types and classes.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">配列の構文は、プリミティブ データ型およびプリミティブ クラスをサポートします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="409">
          <source>In X++ you can use the <ph id="ph1">`Array`</ph> Array for an array of objects.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、配列のオブジェクトに <ph id="ph1">`Array`</ph> 配列を使用できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="410">
          <source>Declaration</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">申告</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="411">
          <source>X++ is limited to single dimension arrays (myStrings[8]).</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ は一次元配列に制限されます (myStrings[8])。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="412">
          <source>C# adds support for multi-dimensional arrays (myStrings[8,3]) and for jagged arrays (myStrings[8][3]).</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# は多次元配列 (myStrings[8,3]) およびジャグ配列 (myStrings[8][3]) のサポートを追加しました。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="413">
          <source>In X++ you cannot have an array of arrays.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、配列の配列を持つことはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="414">
          <source>However, there is advanced syntax for limiting the amount of active memory that a large array can consume, which looks like the multi-dimensional syntax in C#: int intArray[1024,16];.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、大規模な配列が消費できる有効なメモリの量を制限する高度な構文があり、それは C#: int intArray[1024,16]; で多次元構文のように見えます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="415">
          <source>For more information, see Best Practice Performance Optimizations: Swapping Arrays to Disk.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">詳細については、「ベスト プラクティス パフォーマンスの最適化: ディスクへの配列スワッピング」を参照してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="416">
          <source>Declaration</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">申告</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="417">
          <source>In X++ an array is a special construct but it is not an object.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、配列は特別なコンストラクトですが、オブジェクトではありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="418">
          <source>In C# all arrays are objects regardless of syntax variations.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、すべての配列が構文の違いに関係なくオブジェクトです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="419">
          <source>X++ does have an Array class, but its underlying mechanism differs from arrays created by using the [] syntax.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ には配列クラスがありますが、その基本的なメカニズムは [] 構文を使用して作成された配列とは異なります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="420">
          <source>In C# all arrays use the same underlying mechanism, regardless of whether [] syntax of the <ph id="ph1">`System.Array`</ph> class is used in your code.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、すべての配列が <ph id="ph1">`System.Array`</ph> クラスの [] 構文がコード内で使用されているかに関係なく、同じ基本的なメカニズムを使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="421">
          <source>Length</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">期間</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="422">
          <source>In X++ the length of a static sized array is determined in the declaration syntax.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、静的サイズの配列の長さは宣言構文で決定されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="423">
          <source>In C# the size of an array is determined when the array object is constructed.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、配列のサイズは配列オブジェクトが構築されたときに決定されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="424">
          <source>When you use the [] declaration syntax in X++, no more preparation is needed before you assign values to the array.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ で [] 宣言構文を使用するときは、配列に値を割り当てるとき、その前にこれ以上の準備は必要ありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="425">
          <source>In C# you must declare and then construct the array before assigning to it.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、配列を宣言して作成してから代入する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="426">
          <source>Length</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">期間</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="427">
          <source>An X++ array can have a dynamic length that can be increased even after population has begun.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ 配列は、開始した後でも増加できる動的長さを持つことができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="428">
          <source>This applies only when the array is declared without a number inside the [].</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これは配列が [] 内に数字なしで宣言されている場合にのみ適用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="429">
          <source>Performance might be slowed if the length of the dynamic array is increased many times.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">動的配列の長さが何回も増加した場合、パフォーマンスが低下する可能性があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="430">
          <source>In C# the length of an array cannot be changed after the length is set.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、長さの設定後に配列の長さを変更することはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="431">
          <source>In the following fragment of X++ code, only the <ph id="ph1">`myInts`</ph> array is dynamic and can increase in size.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ コードの次のフラグメントでは、<ph id="ph1">`myInts`</ph> 配列のみが動的にサイズを大きくできます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="432">
          <source>Length</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">期間</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="433">
          <source>You can get the length of some arrays by using the <ph id="ph1">`dimOf`</ph> function.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`dimOf`</ph> 機能を使用することにより、一部の配列の長さを取得することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="434">
          <source>C# arrays are objects that have a <ph id="ph1">`Length`</ph> property.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# の配列は <ph id="ph1">`Length`</ph> プロパティを持つオブジェクトです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="435">
          <source>No comments.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメントはありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="436">
          <source>Indexing</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">インデックスの作成中</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="437">
          <source>Array indexing is 1 based.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">配列インデックスは 1 ベースです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="438">
          <source>Array indexing is 0 based.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">配列インデックスは 0 ベースです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="439">
          <source>mtIntArray[0] would cause an error in X++.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">mtIntArray[0] は X++ ではエラーとなります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="440">
          <source>Constant</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">定数</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="441">
          <source>In X++ a constant value is best achieved by using the <bpt id="p1">&lt;strong&gt;</bpt>#define<ept id="p1">&lt;/strong&gt;</ept> precompiler directive.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ で、定数値は <bpt id="p1">&lt;strong&gt;</bpt>#define<ept id="p1">&lt;/strong&gt;</ept> プリコンパイラ ディレクティブを使用することで最適に実現されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="442">
          <source>In C# you can decorate your variable declaration with the keyword <bpt id="p1">&lt;strong&gt;</bpt>const<ept id="p1">&lt;/strong&gt;</ept>, to achieve a constant value.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、キーワード <bpt id="p1">&lt;strong&gt;</bpt>const<ept id="p1">&lt;/strong&gt;</ept> を使用して変数の宣言を修飾して定数値を実現できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="443">
          <source>X++ has no <bpt id="p1">&lt;strong&gt;</bpt>const<ept id="p1">&lt;/strong&gt;</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ には <bpt id="p1">&lt;strong&gt;</bpt>const<ept id="p1">&lt;/strong&gt;</ept> キーワードがありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="444">
          <source>C# cannot assign values to variables that are created by its #define precompiler directive.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# は、#define プリコンパイラ ディレクティブによって作成される変数に値を割り当てることができません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="445">
          <source>X++ and C<ph id="ph1">\#</ph> Samples</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ および C<ph id="ph1">\#</ph> のサンプル</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="446">
          <source>The following code samples show how arrays of primitive data types are handled.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のコード例は、プリミティブ データ型の配列の処理方法を示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="447">
          <source>The first sample is in X++, and the second sample is in C<ph id="ph1">\#</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">最初のサンプルは X++ で、2 番目のサンプルは C<ph id="ph1">\#</ph> にあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="448">
          <source>Both samples achieve the same results.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">両方のサンプルで同じ結果が得られます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="449">
          <source>X++ Sample</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ サンプル</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="450">
          <source>Output</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">出力</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="451">
          <source>The output to the Infolog is as follows:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">情報ログへの出力は次のとおりです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="452">
          <source>C<ph id="ph1">\#</ph> Sample</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C<ph id="ph1">\#</ph> サンプル</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="453">
          <source>C#</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C#</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="454">
          <source>Output</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">出力</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="455">
          <source>The output from the C# program to the command line console is as follows:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# プログラムからコマンド ライン コンソールへの出力は次のとおりです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="456">
          <source>Additional array-like X++ features</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">追加の配列のような X++ 機能</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="457">
          <source>The <bpt id="p1">**</bpt>container<ept id="p1">**</ept> is a special data type that is available in X++.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>コンテナー<ept id="p1">**</ept>は、X++ で利用できる特別なデータ型です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="458">
          <source>It can be considered as similar to an array, or similar to a <ph id="ph1">`List`</ph> collection.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">配列と類似したもの、または <ph id="ph1">`List`</ph> コレクションと類似したものとみなすことができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="459">
          <source>Comparison: Collections</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">比較: コレクション</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="460">
          <source>Finance and Operations provides the X++ <ph id="ph1">`List`</ph> collection class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Finance and Operations は X++ <ph id="ph1">`List`</ph> コレクション クラスを提供します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="461">
          <source>The .NET Framework that is used in C# has a similar class named <ph id="ph1">`System.Collections.Generic.List`</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# で使用されている .NET Framework には、<ph id="ph1">`System.Collections.Generic.List`</ph> と似た名前のクラスがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="462">
          <source>Comparing the Use of the List Classes</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">リスト クラスの使用の比較</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="463">
          <source>The following table compares methods on the X++ <ph id="ph1">`List`</ph> class to the methods on <ph id="ph2">`System.Collections.Generic.List`</ph> from the .NET Framework and C<ph id="ph3">\#</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルは、X++ <ph id="ph1">`List`</ph> クラスのメソッドと .NET Framework および C<ph id="ph3">\#</ph> の <ph id="ph2">`System.Collections.Generic.List`</ph> のメソッドを比較しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="464">
          <source>Feature</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">機能</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="465">
          <source>X++</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="466">
          <source>C#</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C#</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="467">
          <source>Comments</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="468">
          <source>Declaration of collection</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コレクションの宣言</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="469">
          <source>The X++ declaration does not include the type of elements to be stored.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ 宣言には、格納する要素のタイプは含まれません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="470">
          <source>Declaration of iterator</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">反復子の宣言</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="471">
          <source>IEnumerator<ph id="ph1">&amp;lt;</ph>string<ph id="ph2">&amp;gt;</ph> iter;</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">IEnumerator<ph id="ph1">&amp;lt;</ph>文字列<ph id="ph2">&amp;gt;</ph> iter;</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="472">
          <source>In X++ the <ph id="ph1">`ListIterator`</ph> object has methods that can <ph id="ph2">`insert`</ph> and <ph id="ph3">`delete`</ph> items from the <ph id="ph4">`List`</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、<ph id="ph1">`ListIterator`</ph> オブジェクトに <ph id="ph4">`List`</ph> の項目を <ph id="ph2">`insert`</ph> および <ph id="ph3">`delete`</ph> できるメソッドがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="473">
          <source>The X++ <ph id="ph1">`ListEnumerator`</ph> cannot modify the contents of the <ph id="ph2">`List`</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ <ph id="ph1">`ListEnumerator`</ph> は、<ph id="ph2">`List`</ph> の内容を変更することはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="474">
          <source>In X++ the <ph id="ph1">`ListEnumerator`</ph> object is always created on the same tier as the <ph id="ph2">`List`</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、<ph id="ph1">`ListEnumerator`</ph> オブジェクトは常に <ph id="ph2">`List`</ph> と同じ層で作成されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="475">
          <source>This is not always true for <ph id="ph1">`ListIterator`</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これは、必ずしも <ph id="ph1">`ListIterator`</ph> に当てはまるわけではありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="476">
          <source>Obtaining an iterator</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">反復子の取得</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="477">
          <source>In both X++ and C#, the List object has a getter method for an associated enumerator.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ と C# の両方では、リスト オブジェクトに、関連付けられている列挙子の getter メソッドがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="478">
          <source>Constructor</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コンストラクター</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="479">
          <source>Information about the type of objects to be stored inside the <ph id="ph1">`List`</ph> classes is given to the constructor in both X++ and C#.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`List`</ph> クラス内に格納するオブジェクトのタイプに関する情報は、X++ と C# の両方でコントラクターに付与されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="480">
          <source>Updating data</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">データの更新</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="481">
          <source>Enumerator – the enumerator becomes invalid if any items in the <ph id="ph1">`List`</ph> are added or removed.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">列挙子 – <ph id="ph1">`List`</ph> 内の品目が追加または削除された場合、列挙子は無効になります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="482">
          <source>Iterator – the iterator has methods that insert and delete items from the <ph id="ph1">`List`</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">反復子 – 反復子には <ph id="ph1">`List`</ph> の項目を挿入および削除するメソッドがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="483">
          <source>The iterator remains valid.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">反復子は有効なままです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="484">
          <source>Enumerator – the enumerator becomes invalid if any items in the <ph id="ph1">`List`</ph> are added or removed.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">列挙子 – <ph id="ph1">`List`</ph> 内の品目が追加または削除された場合、列挙子は無効になります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="485">
          <source>Enumerators become invalid after items are added or deleted from the <ph id="ph1">`List`</ph>, in both X++ and C#.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ と C# の両方で、項目が <ph id="ph1">`List`</ph> から追加または削除された後、列挙子は無効になります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="486">
          <source>Updating data</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">データの更新</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="487">
          <source>In X++ the <ph id="ph1">`List`</ph> class has methods for adding items at the start or end of the list.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、<ph id="ph1">`List`</ph> クラスにリストの開始または最後に項目を追加するメソッドがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="488">
          <source>In C# the <ph id="ph1">`List`</ph> class has methods for adding members at any position in the list.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、<ph id="ph1">`List`</ph> クラスにリスト内の任意の位置にメンバーを追加するためのメソッドがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="489">
          <source>It also has methods for removing items from any position.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">また、任意の場所から項目を削除するメソッドもあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="490">
          <source>In X++ items can be removed from the <ph id="ph1">`List`</ph> only by an iterator.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、反復子でのみ項目を <ph id="ph1">`List`</ph> から削除できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="491">
          <source>Example 1: Declaration of a List</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例 1: リストの宣言</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="492">
          <source>The following table displays code examples in X++ and C# that declare <ph id="ph1">`List`</ph> collections.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルは、<ph id="ph1">`List`</ph> コレクションを宣言する X++ および C# のコード例を示しています.</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="493">
          <source>Example 2: Construction of a List</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例 2: リストの作成</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="494">
          <source>In both languages, the type of items that the collection stores must be specified at the time of construction.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">どちらの言語でも、構築の時点でコレクションが格納する項目のタイプを指定する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="495">
          <source>For class types, X++ can get no more specific than whether the type is a class (Types::Class).</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラス タイプでは、X++ はタイプがクラス (Types::Class) であるかどうかよりも具体的でないものを取得します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="496">
          <source>Code examples are in the following table.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コードの例を次の表に示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="497">
          <source>Example 3: Add Items to a List</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例 3: リストに品目を追加</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="498">
          <source>In both X++ and C#, the collection provides a method for appending an item to the end of the collection, and for inserting an item the start.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ と C# 両方では、コレクションはコレクションの末尾に項目を追加するメソッドと、最初に項目を挿入するメソッドを提供します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="499">
          <source>In C# the collection provides a method for inserting at any point in the collection based on an index value.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、コレクションは指数値に基づいてコレクション内の任意の時点で挿入するためのメソッドを提供します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="500">
          <source>In X++ a collection iterator can insert an item at its current position.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、コレクションの反復子によって現在の位置に項目を挿入できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="501">
          <source>Code examples are in the following table.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コードの例を次の表に示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="502">
          <source>Example 4: Iterate Through a List</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例 4: リストを繰り返す</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="503">
          <source>Both X++ and C<ph id="ph1">\#</ph> have iterator classes that you can use to step through the items in a collection.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ と C<ph id="ph1">\#</ph> には反復子のクラスがあり、コレクション内の項目をステップ実行するのに使用できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="504">
          <source>Code examples are in the following table.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コードの例を次の表に示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="505">
          <source>Example 4b: foreach in C<ph id="ph1">\#</ph></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例 4b: C<ph id="ph1">\#</ph> の foreach</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="506">
          <source>In C<ph id="ph1">\#</ph> the <bpt id="p1">**</bpt>foreach<ept id="p1">**</ept> keyword is often used to simplify the task of iterating through a list.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C<ph id="ph1">\#</ph> では、よく <bpt id="p1">**</bpt>foreach<ept id="p1">**</ept> キーワードを使用して、一覧の反復のタスクを簡略化します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="507">
          <source>The following code example behaves the same as the previous C<ph id="ph1">\#</ph> example.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のコード例は、以前の C<ph id="ph1">\#</ph> の例と同じように動作します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="508">
          <source>Example 5: Delete the Second Item</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例 5: 2 番目の項目を削除</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="509">
          <source>The following table contains code examples that delete the second item from the collection.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルに、コレクションから 2 番目のアイテムを削除するコード例を示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="510">
          <source>In X++ this requires an iterator.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、これに反復子が必要になります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="511">
          <source>In C<ph id="ph1">\#</ph> the collection itself provides the method for removing an item.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C<ph id="ph1">\#</ph> では、コレクション自体が項目を削除するメソッドを提供します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="512">
          <source>Example 6: Combine Two Collections</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例 6: 2 つのコレクションを結合</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="513">
          <source>The following table contains code examples that combine the contents of two collections into one.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルには、2 つのコレクションの内容を 1 つにまとめたコード例が含まれています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="514">
          <source>Comparison: Collections of keys with values</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">比較: 値を持つキーのコレクション</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="515">
          <source>Finance and Operations provides the <ph id="ph1">`Map`</ph> collection class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Finance and Operations は <ph id="ph1">`Map`</ph> コレクション クラスを提供します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="516">
          <source>The <ph id="ph1">`Map`</ph> collection holds pairs of values, the key value plus a data value.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`Map`</ph> コレクションには、値のペア (キー値とデータ値の組み合わせ) が保持されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="517">
          <source>This resembles the .NET Framework class named <ph id="ph1">`System.Collections.Generic.Dictionary`</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これは、<ph id="ph1">`System.Collections.Generic.Dictionary`</ph> という名前の .NET Framework クラスに似ています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="518">
          <source>Similarities</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">類似点</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="519">
          <source>The following list describes similarities between X++ and C<ph id="ph1">\#</ph> regarding their collections that store key-value pairs:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のリストは、キーと値のペアを格納するコレクションに関する X++ と C<ph id="ph1">\#</ph> の類似点について説明します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="520">
          <source>Both prevent duplicate keys.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">どちらも重複するキーを防止します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="521">
          <source>Both use an enumerator (or iterator) to loop through the items.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">どちらも列挙子 (または反復子) を使用して項目をループします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="522">
          <source>Both key-value collection objects are constructed with designations of the types that are stored as key and value.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">両方のキー値コレクション オブジェクトは、キーと値として格納されているタイプの指定で作成されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="523">
          <source>Both can store class objects, and are not limited to storing primitives like <bpt id="p1">**</bpt>int<ept id="p1">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">どちらもクラス オブジェクトを格納でき、<bpt id="p1">**</bpt>int<ept id="p1">**</ept> のようなプリミティブの格納に限定されません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="524">
          <source>Differences</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">違い</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="525">
          <source>The following table describes differences between X++ and C<ph id="ph1">\#</ph> regarding their collections classes that store key-value pairs:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルは、キーと値のペアを格納するコレクション クラスに関する X++ と C<ph id="ph1">\#</ph> の違いを示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="526">
          <source>Feature</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">機能</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="527">
          <source>X++</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="528">
          <source>C#</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C#</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="529">
          <source>Comments</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="530">
          <source>Duplicate keys</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">キーの重複</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="531">
          <source>In X++ the <ph id="ph1">`Map`</ph> class prevents duplicate keys by implicitly treating your call to its <ph id="ph2">`insert`</ph> method as an operation to update only the value associated with the key.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、<ph id="ph1">`Map`</ph> クラスが <ph id="ph2">`insert`</ph> メソッドに対する呼び出しを、キーに関連付けられている値のみを更新する操作として暗黙的に扱うことにより、重複キーを防止します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="532">
          <source>In C<ph id="ph1">\#</ph> the <ph id="ph2">`Dictionary`</ph> class throws an exception when you try to add a duplicate key.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C<ph id="ph1">\#</ph> では、重複キーを追加しようとすると <ph id="ph2">`Dictionary`</ph> クラスが例外をスローします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="533">
          <source>Duplicate keys are prevented in both languages, although by different techniques.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">異なる技術ではあるが、両方の言語で重複するキーが防止されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="534">
          <source>Delete items</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">品目の削除</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="535">
          <source>In X++ the <ph id="ph1">`delete`</ph> method on an iterator object is used to remove an unwanted key-value pair from a <ph id="ph2">`Map`</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、反復子オブジェクトで <ph id="ph1">`delete`</ph> メソッドを使用して、不要なキーと値のペアを <ph id="ph2">`Map`</ph> から削除します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="536">
          <source>In C<ph id="ph1">\#</ph> the <ph id="ph2">`Dictionary`</ph> class has a <ph id="ph3">`remove`</ph> method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C<ph id="ph1">\#</ph> では、<ph id="ph2">`Dictionary`</ph> クラスに <ph id="ph3">`remove`</ph> メソッドがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="537">
          <source>In both languages, an enumerator is made invalid if the collection item count is modified during the life of the enumerator.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">どちらの言語でも、列挙子は列挙子の有効期間中にコレクション項目数が変更された場合は無効になります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="538">
          <source>Example 1: Declaration of a Key-Value Collection</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例 1: キー値のコレクションの宣言</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="539">
          <source>In both languages, the type of items that the key-value collection stores must be specified.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">どちらの言語でも、キー値コレクションが格納する項目のタイプを指定する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="540">
          <source>In X++ the type is specified at time of construction.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、型は構築時に指定されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="541">
          <source>In C<ph id="ph1">\#</ph> the type is specified at both the time of declaration and the time of construction.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C<ph id="ph1">\#</ph> では、宣言時と構築時の両方で型が指定されています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="542">
          <source>Code examples are in the following table.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コードの例を次の表に示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="543">
          <source>Example 2: Construction of the Collection</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例 2: コレクションの作成</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="544">
          <source>In both languages, the type of items that the key-value collection stores specified during construction.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">どちらの言語でも、構築中にキー値コレクションが格納する項目のタイプが指定されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="545">
          <source>For class types, X++ can get no more specific than whether the type is a class (Types::Class).</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラス タイプでは、X++ はタイプがクラス (Types::Class) であるかどうかよりも具体的でないものを取得します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="546">
          <source>Code examples are in the following table.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コードの例を次の表に示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="547">
          <source>Example 3: Add an Item to the Collection</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例 3: 品目をコレクションに追加</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="548">
          <source>There is almost no difference in how an item is added to a key-value collection, in X++ and C<ph id="ph1">\#</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ と C<ph id="ph1">\#</ph> では、キー値コレクションにアイテムを追加する方法にほとんど違いはありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="549">
          <source>Code examples are in the following table.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コードの例を次の表に示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="550">
          <source>Example 4: Iterate Through a Key-Value Collection</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例 4: キー値のコレクションを反復</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="551">
          <source>Enumerators are used to loop through the key-value collections in both X++ and C<ph id="ph1">\#</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">列挙子は、X++ と C<ph id="ph1">\#</ph> の両方のキー値コレクションをループするために使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="552">
          <source>Code examples are in the following table.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コードの例を次の表に示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="553">
          <source>Example 5: Update the Value Associated with a Key</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例 5: キーに関連付けられている値を更新</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="554">
          <source>The syntax is very different between the two languages for an update of the value associated to a given key.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">構文は、指定されたキーに関連付けられた値を更新するために 2 つの言語で全く異なります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="555">
          <source>Code examples for the key 102 are in the following table.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">キー 102 のコードの例を次の表に示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="556">
          <source>Example 6: Delete One Item</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例 6: 1つの品目を削除</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="557">
          <source>The syntax is very different between the two languages to delete one key-value pair from a collection, while iterating through the collection members.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">構文は、2 つの言語間でコレクション メンバーを反復しながら、コレクションから 1 つのキーと値のペアを削除する方法が全く異なります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="558">
          <source>Code examples for the key 102 are shown below.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">キー 102 のコードの例は次のとおりです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="559">
          <source>Comparison: Exceptions</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">比較: 例外</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="560">
          <source>There are some similarities but many differences when we compare exception related behavior between X++ and C<ph id="ph1">\#</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">いくつかの類似点がありますが、X++ と C<ph id="ph1">\#</ph> の間の例外関連の動作を比較すると、多くの違いがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="561">
          <source>The <bpt id="p1">**</bpt>try<ept id="p1">**</ept>, <bpt id="p2">**</bpt>catch<ept id="p2">**</ept>, and <bpt id="p3">**</bpt>throw<ept id="p3">**</ept> keywords behave the same in X++ and C#.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>try<ept id="p1">**</ept>、<bpt id="p2">**</bpt>catch<ept id="p2">**</ept>、<bpt id="p3">**</bpt>throw<ept id="p3">**</ept> キーワードは、X++ と C# で同じように動作します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="562">
          <source>But the types of exceptions thrown and caught are different for the two languages.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、スローされキャッチされる例外のタイプは 2 つの言語で異なります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="563">
          <source>Similarities</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">類似点</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="564">
          <source>Similarities between X++ and C<ph id="ph1">\#</ph> regarding their exception features include the following:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例外機能に関する X++ と C<ph id="ph1">\#</ph> の類似点には、次が含まれます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="565">
          <source>Both languages have the same <bpt id="p1">**</bpt>try<ept id="p1">**</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">どちらの言語も同じ <bpt id="p1">**</bpt>try<ept id="p1">**</ept> キーワードを持っています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="566">
          <source>Both have the same <bpt id="p1">**</bpt>catch<ept id="p1">**</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">どちらも同じ <bpt id="p1">**</bpt>catch<ept id="p1">**</ept> キーワードを持っています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="567">
          <source>Both enable for a <bpt id="p1">**</bpt>catch<ept id="p1">**</ept> statement that does not specify any particular exception.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">両方とも特定の例外を指定しない <bpt id="p1">**</bpt>catch<ept id="p1">**</ept> ステートメントを有効にします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="568">
          <source>Such a <bpt id="p1">**</bpt>catch<ept id="p1">**</ept> statement catches all exceptions that reach it.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このような <bpt id="p1">**</bpt>catch<ept id="p1">**</ept> ステートメントは、それに到達するすべての例外を検出します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="569">
          <source>Both have the same <bpt id="p1">**</bpt>throw<ept id="p1">**</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">どちらも同じ <bpt id="p1">**</bpt>throw<ept id="p1">**</ept> キーワードを持っています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="570">
          <source>Differences</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">違い</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="571">
          <source>Exception-related differences between X++ and C<ph id="ph1">\#</ph> are described in the following table.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ と C<ph id="ph1">\#</ph> 間の例外関連の違いは、次のテーブルで説明します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="572">
          <source>Feature</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">機能</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="573">
          <source>X++</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="574">
          <source>C#</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C#</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="575">
          <source>Comments</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="576">
          <source><bpt id="p1">&lt;strong&gt;</bpt>retry<ept id="p1">&lt;/strong&gt;</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>再試行<ept id="p1">&lt;/strong&gt;</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="577">
          <source>Jumps to the first instruction in the associated <bpt id="p1">&lt;strong&gt;</bpt>try<ept id="p1">&lt;/strong&gt;</ept> block.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">関連付けられた <bpt id="p1">&lt;strong&gt;</bpt>try<ept id="p1">&lt;/strong&gt;</ept> ブロックの最初の命令にジャンプします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="578">
          <source>For more information, see Exception Handling with try and catch Keywords.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">詳細については、「トライおよびキャッチ キーワードで例外処理」を参照してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="579">
          <source>The functionality of the <bpt id="p1">&lt;strong&gt;</bpt>retry<ept id="p1">&lt;/strong&gt;</ept> keyword can be mimicked in C# code, but there is no corresponding keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>再試行<ept id="p1">&lt;/strong&gt;</ept> キーワードの機能は C# コードでは真似できますが、対応するキーワードはありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="580">
          <source>Only X++ has a <bpt id="p1">&lt;strong&gt;</bpt>retry<ept id="p1">&lt;/strong&gt;</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ のみ、<bpt id="p1">&lt;strong&gt;</bpt>再試行<ept id="p1">&lt;/strong&gt;</ept>キーワードがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="581">
          <source>C# has no counterpart.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# には対応がありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="582">
          <source>For more information, see X++, C# Comparison: Automated Retry After an Exception.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">詳細については、X++、C# の比較: 例外後の再試行の自動化を参照してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="583">
          <source><bpt id="p1">&lt;strong&gt;</bpt>finally<ept id="p1">&lt;/strong&gt;</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>最終的に<ept id="p1">&lt;/strong&gt;</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="584">
          <source>The <ph id="ph1">`finally`</ph> keyword is supported to follow the <ph id="ph2">`try`</ph> and <ph id="ph3">`catch`</ph> keywords.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`finally`</ph> キーワードは、<ph id="ph2">`try`</ph> および <ph id="ph3">`catch`</ph> キーワードの後に使用することがサポートされます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="585">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>finally<ept id="p1">&lt;/strong&gt;</ept> keyword marks a block of code that follows the <bpt id="p2">&lt;strong&gt;</bpt>try<ept id="p2">&lt;/strong&gt;</ept> and <bpt id="p3">&lt;strong&gt;</bpt>catch<ept id="p3">&lt;/strong&gt;</ept> blocks.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>finally<ept id="p1">&lt;/strong&gt;</ept> キーワードは、<bpt id="p2">&lt;strong&gt;</bpt>try<ept id="p2">&lt;/strong&gt;</ept> および <bpt id="p3">&lt;strong&gt;</bpt>catch<ept id="p3">&lt;/strong&gt;</ept> ブロックに従うコードのブロックをマークします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="586">
          <source>The finally will be executed regardless of whether any exception is thrown or caught.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例外がスローされたかキャッチされたかどうかに関係なく、確定が実行されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="587">
          <source>The semantics are identical to the semantics in C#.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">セマンティクスは C# のセマンティクスと同じです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="588">
          <source>Specific exceptions</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">特定の固有</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="589">
          <source>In X++ an exception is an element of the <ph id="ph1">`Exception`</ph> enum, such as <bpt id="p1">**</bpt>Error<ept id="p1">**</ept>, <bpt id="p2">**</bpt>Deadlock<ept id="p2">**</ept>, or <bpt id="p3">**</bpt>CodeAccessSecurity<ept id="p3">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、例外は、<bpt id="p1">**</bpt>エラー<ept id="p1">**</ept>、<bpt id="p2">**</bpt>デッドロック<ept id="p2">**</ept>、または <bpt id="p3">**</bpt>CodeAccessSecurity<ept id="p3">**</ept> など <ph id="ph1">`Exception`</ph> 列挙型の要素です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="590">
          <source>No exception can contain another.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">別のものを含めることができる例外はありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="591">
          <source>In C# an exception is an instance of the <ph id="ph1">`System.Exception`</ph> base class, or any class that inherits from it.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、例外は <ph id="ph1">`System.Exception`</ph> 基本クラスまたは継承された任意のクラスのインスタンスです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="592">
          <source>An exception can be contained in the <ph id="ph1">`InnerException`</ph> property of the thrown exception.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">スローされた例外の <ph id="ph1">`InnerException`</ph> プロパティに例外を含めることができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="593">
          <source>In X++ each thrown exception is a value of the Exception enum.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、スローされた各例外は Exception 列挙型の値です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="594">
          <source>For more information, see Exception Enumeration.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">詳細については、「例外列挙」を参照してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="595">
          <source>Exception message</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例外メッセージ</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="596">
          <source>In X++ the message that is created when an exception is raised is available only in the Infolog, and the message is not directly tied to the exception.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、例外が発生したときに作成されるメッセージは情報ログでのみ使用でき、そのメッセージは例外に直接関連付けられません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="597">
          <source>In C# the message is the <ph id="ph1">`Message`</ph> member of the <ph id="ph2">`System.Exception`</ph> object.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、メッセージは <ph id="ph2">`System.Exception`</ph> オブジェクトの <ph id="ph1">`Message`</ph> のメンバーです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="598">
          <source>In X++ the Global::error method is the mechanism that display exception messages in the Infolog.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、Global::error メソッドは情報ログで例外メッセージを表示するメカニズムです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="599">
          <source>For more information, see Exception Handling with try and catch Keywords.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">詳細については、「トライおよびキャッチ キーワードで例外処理」を参照してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="600">
          <source>Exception conditions</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例外条件</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="601">
          <source>In X++ an error occurs when you call an instance method on an object variable that has not yet had anything assigned to it.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、まだ何も代入されていないオブジェクト変数でインスタンス メソッドを呼び出すとエラーが発生します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="602">
          <source>However, no exception is raised along with this error.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、このエラーと共に例外は発生しません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="603">
          <source>Therefore no <ph id="ph1">`catch`</ph> block can gain control even if the unassigned variable is misused in a <ph id="ph2">`try`</ph> block.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">したがって、割り当てられていない変数が <ph id="ph2">`try`</ph> ブロックで誤用されても、<ph id="ph1">`catch`</ph> ブロックは制御を獲得できません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="604">
          <source>In the following code example, the error caused by the code <ph id="ph1">`box4.toString();`</ph> does not cause control to transfer to any <ph id="ph2">`catch`</ph> block: <ph id="ph3">`DialogBox box4;`</ph> <ph id="ph4">`try`</ph> { <ph id="ph5">` box4.toString();`</ph> <ph id="ph6">` info("toString did not error, but expected an error.");`</ph> } catch (Exception::Error) // No Exception value catches this.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のコード例では、コード <ph id="ph1">`box4.toString();`</ph> で発生したエラーにより、コントロールは任意の <ph id="ph2">`catch`</ph> ブロックに移行しません。<ph id="ph3">`DialogBox box4;`</ph> <ph id="ph4">`try`</ph> { <ph id="ph5">` box4.toString();`</ph> <ph id="ph6">` info("toString did not error, but expected an error.");`</ph> } catch (Exception::Error) // これを検出する例外値はありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="605">
          <source>{ <ph id="ph1">` info("Invalid use of box4 gave control to catch, unexpected.");`</ph> }</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">{ <ph id="ph1">` info("Invalid use of box4 gave control to catch, unexpected.");`</ph> }</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="606">
          <source>In C# a <ph id="ph1">`System.NullReferenceException`</ph> is raised when an uninitialized variable is treated as an object reference.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、初期化されていない変数がオブジェクト参照として扱われる場合、<ph id="ph1">`System.NullReferenceException`</ph> が発生します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="607">
          <source>There might be several other differences in the conditions that raise exceptions.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例外を発生させる条件にはいくつかの相違点があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="608">
          <source>SQL transactions</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">SQL トランザクション</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="609">
          <source>In X++ when an SQL exception occurs in a <bpt id="p1">&lt;strong&gt;</bpt>ttsBegin<ept id="p1">&lt;/strong&gt;</ept><ph id="ph1"> - </ph><bpt id="p2">&lt;strong&gt;</bpt>ttsCommit<ept id="p2">&lt;/strong&gt;</ept> transaction, no <bpt id="p3">&lt;strong&gt;</bpt>catch<ept id="p3">&lt;/strong&gt;</ept> statement inside the transaction block can process the exception.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ で、SQL 例外が <bpt id="p1">&lt;strong&gt;</bpt>ttsBegin<ept id="p1">&lt;/strong&gt;</ept><ph id="ph1"> - </ph><bpt id="p2">&lt;strong&gt;</bpt>ttsCommit<ept id="p2">&lt;/strong&gt;</ept> トランザクションで発生する場合、そのトランザクション ブロック内の <bpt id="p3">&lt;strong&gt;</bpt>catch<ept id="p3">&lt;/strong&gt;</ept> ステートメントは例外を処理できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="610">
          <source>In C# a catch block inside an SQL transaction can catch the exception.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、SQL トランザクション内部の catch ブロックは例外を検出できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="611">
          <source>Examples</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="612">
          <source>The following X++ features are demonstrated:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の X++ 機能が示されています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="613">
          <source><bpt id="p1">**</bpt>try<ept id="p1">**</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>試行<ept id="p1">**</ept>キーワード。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="614">
          <source><bpt id="p1">**</bpt>catch<ept id="p1">**</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>catch<ept id="p1">**</ept> キーワード。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="615">
          <source>The behavior after an Exception::Error exception occurs.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Exception::Error 例外が発生した後の動作。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="616">
          <source>X++ Example</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ 例</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="617">
          <source>Output</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">出力</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="618">
          <source>Here is the output from the Infolog window:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">情報ログ ウィンドウからの出力を次に示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="619">
          <source>C# Sample</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# サンプル</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="620">
          <source>The following C<ph id="ph1">\#</ph> program is a rewrite of the previous X++ program.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の C<ph id="ph1">\#</ph> プログラムは、以前の X++ プログラムを書き直したものです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="621">
          <source>Output</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">出力</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="622">
          <source>Here is the actual output to the C<ph id="ph1">\#</ph> console:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C<ph id="ph1">\#</ph> コンソールへの実際の出力を次に示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="623">
          <source>Comparison: Automated Retry After an Exception</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">比較: 例外後の自動再試行</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="624">
          <source>Sometimes you can write code in a catch block that fixes the cause of an exception that occurs during run time.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">場合によっては、実行時に発生する例外の原因を修正する catch ブロックでコードを記述できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="625">
          <source>X++ provides a <bpt id="p1">**</bpt>retry<ept id="p1">**</ept> keyword that can be used only inside a <bpt id="p2">**</bpt>catch<ept id="p2">**</ept> block.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ には <bpt id="p2">**</bpt>catch<ept id="p2">**</ept> ブロック内でのみ使用することができる <bpt id="p1">**</bpt>retry<ept id="p1">**</ept> キーワードが用意されています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="626">
          <source>The <bpt id="p1">**</bpt>retry<ept id="p1">**</ept> keyword enables a program to jump back to the start of the <bpt id="p2">**</bpt>try<ept id="p2">**</ept> block after the problem has been corrected by code in the <bpt id="p3">**</bpt>catch<ept id="p3">**</ept> block.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>retry<ept id="p1">**</ept> キーワードを使用すると、問題が <bpt id="p3">**</bpt>catch<ept id="p3">**</ept> ブロック内のコードにより修正されるとプログラムが <bpt id="p2">**</bpt>try<ept id="p2">**</ept> ブロックの先頭に戻ることができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="627">
          <source>C# does not have a <bpt id="p1">**</bpt>retry<ept id="p1">**</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# には<bpt id="p1">**</bpt>再試行<ept id="p1">**</ept>キーワードがありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="628">
          <source>However, C# code can be written to provide equivalent behavior.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、同等の動作を提供するよう C# コードを書き込むことができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="629">
          <source>Code Samples for Retry</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">再試行のためのコード サンプル</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="630">
          <source>The following X++ sample program causes an Exception::Error to be raised.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の X++ サンプル プログラムは、Exception::Error を発生させます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="631">
          <source>This occurs when it first tries to read an element from the <ph id="ph1">`sStrings`</ph> array by using an invalid index value.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これは、最初に無効なインデックス値を使用して <ph id="ph1">`sStrings`</ph> 配列から要素を読み取ろうとするときに発生します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="632">
          <source>When the exception is caught, corrective action is taken during run time inside the <bpt id="p1">**</bpt>catch<ept id="p1">**</ept> block.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例外がキャッチされると、<bpt id="p1">**</bpt>catch<ept id="p1">**</ept> ブロック内で、実行時に是正措置が行われます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="633">
          <source>The retry statement then jumps back to the first statement in the <bpt id="p1">**</bpt>try<ept id="p1">**</ept> block.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">その後再試行ステートメントは、<bpt id="p1">**</bpt>try<ept id="p1">**</ept> ブロックの最初のステートメントに戻ります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="634">
          <source>This second iteration works without encountering any exception.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この 2 回目の繰り返しは、例外が発生することなく動作します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="635">
          <source>Output</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">出力</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="636">
          <source>Here is the output to the Print window:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">印刷ウィンドウへの出力を次に示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="637">
          <source>C# Sample</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# サンプル</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="638">
          <source>The following C<ph id="ph1">\#</ph> sample is not a line-by-line translation from the previous X++ sample.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の C<ph id="ph1">\#</ph> サンプルは、以前の X++ サンプルからの行ごとの変換ではありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="639">
          <source>Instead the C<ph id="ph1">\#</ph> program has a different structure so that it mimics the behavior of the <bpt id="p1">**</bpt>retry<ept id="p1">**</ept> keyword that the X++ program relies on.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">代わりに、C<ph id="ph1">\#</ph> プログラムには X++ プログラムが依存している <bpt id="p1">**</bpt>retry<ept id="p1">**</ept> のキーワードの動作に似た別の構造体があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="640">
          <source>The <bpt id="p1">**</bpt>try<ept id="p1">**</ept> and <bpt id="p2">**</bpt>catch<ept id="p2">**</ept> blocks are in a called method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>try<ept id="p1">**</ept> および <bpt id="p2">**</bpt>catch<ept id="p2">**</ept> ブロックは、呼び出されたメソッドにあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="641">
          <source>The variables that are used in the <bpt id="p1">**</bpt>try<ept id="p1">**</ept> block are stored in the caller method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>try<ept id="p1">**</ept> ブロックで使用される変数は、caller 側メソッドに格納されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="642">
          <source>The caller method passes the variables as parameters that are decorated with the <bpt id="p1">**</bpt>ref<ept id="p1">**</ept> keyword, so that their values can be corrected inside the <bpt id="p2">**</bpt>catch<ept id="p2">**</ept> block of the called method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">呼び出し元メソッドは、変数を <bpt id="p1">**</bpt>ref<ept id="p1">**</ept> キーワードで修飾されたパラメーターとして渡し、呼び出されたメソッドの <bpt id="p2">**</bpt>catch<ept id="p2">**</ept> ブロック内で値を修正できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="643">
          <source>The called method captures all exceptions, and returns a <bpt id="p1">**</bpt>boolean<ept id="p1">**</ept> to communicate back to the caller whether a second call is required.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">呼び出されたメソッドはすべての例外を取得し、<bpt id="p1">**</bpt>ブール値<ept id="p1">**</ept> を返して、2 番目の呼び出しが必要かどうかを呼び出し元に返信します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="644">
          <source>Output</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">出力</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="645">
          <source>Here is the output to the console:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コンソールへの出力を次に示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="646">
          <source>Comparison: Operators</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">比較: 演算子</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="647">
          <source>This section compares the operators between X++ and C<ph id="ph1">\#</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このセクションでは、X++ と C<ph id="ph1">\#</ph> の間のループの演算子を比較します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="648">
          <source>Assignment Operators</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">代入演算子</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="649">
          <source>The following table displays the differences between the assignment operators in X++ and C<ph id="ph1">\#</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルは、X++ と C<ph id="ph1">\#</ph> の代入演算子の違いを示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="650">
          <source>X++ and C#</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ および C#</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="651">
          <source>Differences</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">違い</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="652">
          <source>In X++ this operator causes an implicit conversion whenever a loss of precision might occur, such for an assignment from an <bpt id="p1">&lt;strong&gt;</bpt>int64<ept id="p1">&lt;/strong&gt;</ept> to an <bpt id="p2">&lt;strong&gt;</bpt>int<ept id="p2">&lt;/strong&gt;</ept>. But in C# the assignment causes a compile error.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、この演算子によって、<bpt id="p1">&lt;strong&gt;</bpt>int64<ept id="p1">&lt;/strong&gt;</ept> から <bpt id="p2">&lt;strong&gt;</bpt>int<ept id="p2">&lt;/strong&gt;</ept> に代入する場合など、精度が損なわれる可能性がある場合は必ず暗黙的な変換が発生します。ただし、C# では、この代入により、コンパイル エラーが発生します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="653">
          <source><ph id="ph1">`+=`</ph> and <ph id="ph2">`-=`</ph></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`+=`</ph> および <ph id="ph2">`-=`</ph></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="654">
          <source>The only difference is that in C# these operators are also used in delegate manipulation.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">唯一の違いは、C# ではこれらの演算子もデリゲート操作で使用されることです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="655">
          <source>++ and --</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">++ および --</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="656">
          <source>These are the increment and decrement operators in both languages.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これらは、両方の言語のインクリメント演算子およびデクリメント演算子です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="657">
          <source>The following line is identical in both languages:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の行は、両方の言語で同じです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="658">
          <source>But in X++ these two operators are for statements, not for expressions.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし X++ では、これら 2 つの演算子は式ではなくステートメントに対して使用できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="659">
          <source>Therefore the following lines generate compile errors in X++:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">したがって、次の行は X++ でコンパイル エラーを生成します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="660">
          <source>Arithmetic Operators</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">算術演算子</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="661">
          <source>The following table lists the arithmetic operators.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルに、算術演算子の一覧を示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="662">
          <source>X++ and C#</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ および C#</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="663">
          <source>Differences</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">違い</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="664">
          <source>As the multiplication operator, there are no differences.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">乗算演算子との違いはありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="665">
          <source><bpt id="p1">&lt;strong&gt;</bpt>Note:<ept id="p1">&lt;/strong&gt;</ept> The asterisk is also used in the SQL statements that are part of the X++ language.</source><target logoport:matchpercent="98" state="translated" state-qualifier="fuzzy-match"><bpt id="p1">&lt;strong&gt;</bpt>注記<ept id="p1">&lt;/strong&gt;</ept>: アスタリスクは、X++言語の一部である SQL ステートメントにも使用されます。</target>
        </trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="666">
          <source>In these SQL statements the asterisk can also be one of the following:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これらの SQL ステートメントでは、アスタリスクを次のいずれかに設定できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="667">
          <source>A wildcard indicating that all the columns should be returned.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">すべての列を返す必要があることを示すワイルドカード。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="668">
          <source>A wildcard for characters in a string that is used on a <bpt id="p1">&lt;strong&gt;</bpt>like<ept id="p1">&lt;/strong&gt;</ept> clause.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>LIKE<ept id="p1">&lt;/strong&gt;</ept> 句で使用される文字列の文字のワイルドカード。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="669">
          <source>The division operator is the same in X++ and C#.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">除算演算子は、X++ と C# で同じです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="670">
          <source>For modulo operations, the only difference is that the % symbol is used in C#.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">剰余工程については、唯一の違いは % 記号が C# で使用されることです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="671">
          <source>The addition operator is the same in X++ and C#.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">加算演算子は、X++ と C# で同じです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="672">
          <source>The plus sign is also used for string concatenation.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">プラス記号は文字列の連結にも使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="673">
          <source>This operator adds numbers and concatenates strings in both languages.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この演算子は、数値を追加し、両方の言語で文字列を連結します。 </target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="674">
          <source>The subtraction operator is the same in X++ and C#.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">減算演算子は、X++ と C# で同じです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="675">
          <source>Bitwise Operators</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ビット演算子</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="676">
          <source>The following table compares the bitwise operators between X++ and C<ph id="ph1">\#</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルは X++ と C<ph id="ph1">\#</ph> の間のビット演算子を比較しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="677">
          <source>X++ and C<ph id="ph1">\#</ph></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ および C<ph id="ph1">\#</ph></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="678">
          <source>Differences</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">違い</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="679">
          <source>The left shift operator is the same in X++ and C<ph id="ph1">\#</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">左シフト演算子は、X++ と C<ph id="ph1">\#</ph> で同じです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="680">
          <source>The right shift operator is the same in X++ and C<ph id="ph1">\#</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">右シフト演算子は、X++ と C<ph id="ph1">\#</ph> で同じです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="681">
          <source>The bitwise NOT operator is the same in X++ and C<ph id="ph1">\#</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ビットの NOT 演算子は、X++ と C<ph id="ph1">\#</ph> で同じです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="682">
          <source>The binary AND operator is the same in X++ and C<ph id="ph1">\#</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">バイナリの AND 演算子は、X++ と C<ph id="ph1">\#</ph> で同じです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="683">
          <source>The binary XOR operator is the same in X++ and C<ph id="ph1">\#</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">バイナリの XOR 演算子は、X++ と C<ph id="ph1">\#</ph> で同じです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="684">
          <source>Relational Operators</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">リレーショナル演算子</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="685">
          <source>The following relational operators are the same in X++ and C<ph id="ph1">\#</ph>:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のリレーショナル演算子は、X++ と C<ph id="ph1">\#</ph> で同じです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="686">
          <source>Comparison: Events</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">比較: イベント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="687">
          <source>There are some differences in how X++ and C# implement the event design pattern.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ と C# がイベントデザインパターンを実装する方法にはいくつかの違いがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="688">
          <source>For more information, see Event Terminology and Keywords.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">詳細については、「イベント用語とキーワード」を参照してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="689">
          <source>Comparison of Events between X++ and C<ph id="ph1">\#</ph></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ と C<ph id="ph1">\#</ph> 間のイベントの比較</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="690">
          <source>There are differences in the way delegates are used for events in X++ versus C#.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">委任が X++ と C# の各イベントに使用される方法には違いがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="691">
          <source>Concept</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">概念</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="692">
          <source>X++</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="693">
          <source>C#</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C#</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="694">
          <source>Comments</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="695">
          <source><bpt id="p1">&lt;strong&gt;</bpt>delegate<ept id="p1">&lt;/strong&gt;</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>デリゲート<ept id="p1">&lt;/strong&gt;</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="696">
          <source>In X++, a delegate can be declared only as a member on a class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、デリゲートはクラスのメンバーとしてのみ宣言できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="697">
          <source>A delegate cannot be a member on a table.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">デリゲートは、テーブルのメンバーであることはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="698">
          <source>All delegates are instance members of their class, not <bpt id="p1">&lt;strong&gt;</bpt>static<ept id="p1">&lt;/strong&gt;</ept> members.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">すべてのデリゲートはそのクラスのインスタンス メンバーであり、<bpt id="p1">&lt;strong&gt;</bpt>静的<ept id="p1">&lt;/strong&gt;</ept>メンバーではありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="699">
          <source>No access modifier can be used on a delegate declaration, because all delegates are <bpt id="p1">&lt;strong&gt;</bpt>protected<ept id="p1">&lt;/strong&gt;</ept> members.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">すべてのデリゲートは<bpt id="p1">&lt;strong&gt;</bpt>保護された<ept id="p1">&lt;/strong&gt;</ept>メンバーであるため、デリゲートの宣言で使用できるアクセス修飾子はありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="700">
          <source>Therefore, the event can be raised only by code within the same class where the delegate is a member.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">したがって、イベントは、デリゲートがメンバーである同じクラス内のコードによってのみ呼び出すことができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="701">
          <source>However, the one exception to the private nature of a delegate is that code outside their class can operate on the delegates by using the += and -= operators.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、デリゲートのプライベート性質の 1 つの例外は、そのクラス以外のコードが、+= および -= 演算子を使用してデリゲートで操作できることです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="702">
          <source>In C#, each <bpt id="p1">&lt;strong&gt;</bpt>delegate<ept id="p1">&lt;/strong&gt;</ept> is a type, just as every <bpt id="p2">&lt;strong&gt;</bpt>class<ept id="p2">&lt;/strong&gt;</ept> is a type.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、各<bpt id="p1">&lt;strong&gt;</bpt>デリゲート<ept id="p1">&lt;/strong&gt;</ept>は、すべて<bpt id="p2">&lt;strong&gt;</bpt>クラス<ept id="p2">&lt;/strong&gt;</ept>が 1 つの型であるように 1 つの型です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="703">
          <source>A delegate is declared independently of any class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">デリゲートは、任意のクラスとは別に宣言されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="704">
          <source>Without the <bpt id="p1">&lt;strong&gt;</bpt>event<ept id="p1">&lt;/strong&gt;</ept> keyword, you can have a delegate as a parameter type on a method, just as you can have a class as a parameter type.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>イベント<ept id="p1">&lt;/strong&gt;</ept> キーワードがない場合、パラメーター タイプとしてクラスを設定することができるように、メソッドのパラメーター タイプとしてデリゲートを設定することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="705">
          <source>You can construct an instance of a delegate to pass in for the parameter value.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">デリゲートのインスタンスを構築して、パラメーター値を渡すことができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="706">
          <source>In X++, each class is a type, but no delegate is a type.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、各クラスは型ですが、デリゲートは型ではありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="707">
          <source>You cannot construct an instance of a delegate.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">デリゲートのインスタンスをコンストラクトすることはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="708">
          <source>No delegate can be a parameter for a method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドのパラメーターに設定できるデリゲートはありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="709">
          <source>But you can create a class that has a delegate member, and you can pass instances of the class as parameter values.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、デリゲート メンバーを持つクラスを作成し、クラスのインスタンスをパラメーター値として渡すことができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="710">
          <source>For more information, see X++ Keywords.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">詳細については、「X++ キーワード」を参照してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="711">
          <source><bpt id="p1">&lt;strong&gt;</bpt>event<ept id="p1">&lt;/strong&gt;</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>イベント<ept id="p1">&lt;/strong&gt;</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="712">
          <source>In X++ code, an event is one of the following:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ コードでは、イベントは次のいずれかです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="713">
          <source>An explicit call to a delegate.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">デリゲートを明示的に呼び出します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="714">
          <source>The start or end of a method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドの開始または終了。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="715">
          <source>There is no <bpt id="p1">&lt;strong&gt;</bpt>event<ept id="p1">&lt;/strong&gt;</ept> keyword in X++.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ には <bpt id="p1">&lt;strong&gt;</bpt>event<ept id="p1">&lt;/strong&gt;</ept> キーワードがありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="716">
          <source>In C#, the <bpt id="p1">&lt;strong&gt;</bpt>event<ept id="p1">&lt;/strong&gt;</ept> keyword is used to declare a <bpt id="p2">&lt;strong&gt;</bpt>delegate<ept id="p2">&lt;/strong&gt;</ept> type as a member of a class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、<bpt id="p1">&lt;strong&gt;</bpt>event<ept id="p1">&lt;/strong&gt;</ept> キーワードを使用して<bpt id="p2">&lt;strong&gt;</bpt>デリゲート<ept id="p2">&lt;/strong&gt;</ept>型をクラスのメンバーとして宣言します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="717">
          <source>The effect of the <bpt id="p1">&lt;strong&gt;</bpt>event<ept id="p1">&lt;/strong&gt;</ept> keyword is to make the delegate <bpt id="p2">&lt;strong&gt;</bpt>protected<ept id="p2">&lt;/strong&gt;</ept>, yet still accessible for the += and -= operators.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>イベント<ept id="p1">&lt;/strong&gt;</ept> キーワードの結果は、委任を確認する<bpt id="p2">&lt;strong&gt;</bpt>protected<ept id="p2">&lt;/strong&gt;</ept> を委任することですが、+= および -= 演算子にはアクセスできます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="718">
          <source>You can subscribe event handler methods to an <bpt id="p1">&lt;strong&gt;</bpt>event<ept id="p1">&lt;/strong&gt;</ept> by using the += operator.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">+= 演算子を使用して、<bpt id="p1">&lt;strong&gt;</bpt>イベント<ept id="p1">&lt;/strong&gt;</ept> に対するイベント ハンドラー メソッドを申し込むことができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="719">
          <source>A <bpt id="p1">&lt;strong&gt;</bpt>delegate<ept id="p1">&lt;/strong&gt;</ept> can be useful without the <bpt id="p2">&lt;strong&gt;</bpt>event<ept id="p2">&lt;/strong&gt;</ept> keyword, as a technique for passing a function pointer as a parameter into a method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドに関数ポインターをパラメータとして渡す手法として<bpt id="p1">&lt;strong&gt;</bpt>デリゲート<ept id="p1">&lt;/strong&gt;</ept>は、<bpt id="p2">&lt;strong&gt;</bpt>イベント<ept id="p2">&lt;/strong&gt;</ept>キーワードなしで役立ちます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="720">
          <source>The automatic events that occur before the start of a method, and after the end of a method, can be subscribed to only by using the AOT.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドの開始前およびメソッドの終了後に発生する自動イベントは、AOT の使用によってのみサブスクライブできます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="721">
          <source>+= and -= operators</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">+= および -= 演算子</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="722">
          <source>In X++, you use the += operator to subscribe methods to a <bpt id="p1">&lt;strong&gt;</bpt>delegate<ept id="p1">&lt;/strong&gt;</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、+= 演算子を使用して<bpt id="p1">&lt;strong&gt;</bpt>デリゲート<ept id="p1">&lt;/strong&gt;</ept>に対するメソッドをサブスクライブします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="723">
          <source>The -= operator unsubscribes a method from a delegate.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">-= 演算子は、デリゲートからメソッドのサブスクライブを解除します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="724">
          <source>In C#, you use the += operator to subscribe methods to an <bpt id="p1">&lt;strong&gt;</bpt>event<ept id="p1">&lt;/strong&gt;</ept>, or to a <bpt id="p2">&lt;strong&gt;</bpt>delegate<ept id="p2">&lt;/strong&gt;</ept> that is not used with the <bpt id="p3">&lt;strong&gt;</bpt>event<ept id="p3">&lt;/strong&gt;</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、+= 演算子を使用して、<bpt id="p3">&lt;strong&gt;</bpt>event<ept id="p3">&lt;/strong&gt;</ept> キーワードとともに使用されていない<bpt id="p1">&lt;strong&gt;</bpt>イベント<ept id="p1">&lt;/strong&gt;</ept>、または<bpt id="p2">&lt;strong&gt;</bpt>デリゲート<ept id="p2">&lt;/strong&gt;</ept>にメソッドをサブスクライブします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="725">
          <source>The delegate contains a reference to all the objects that have methods subscribed to the delegate.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">デリゲートには、デリゲートにサブスクライブされたメソッドを持つすべてのオブジェクトへの照会が含まれています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="726">
          <source>Those objects are not eligible for garbage collection while delegate holds those references.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これらのオブジェクトはガベージ コレクションの対象外ですが、デリゲートはそれらの参照を保持します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="727">
          <source>In X++, the <bpt id="p1">&lt;strong&gt;</bpt>eventHandler<ept id="p1">&lt;/strong&gt;</ept> keyword is required when you use either the += or -= operator to subscribe or unsubscribe a method from a delegate.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ で、+= や -= の演算子を使用してデリゲートからメソッドをサブスクライブまたはサブスクライブ解除を行う場合、<bpt id="p1">&lt;strong&gt;</bpt>eventHandler<ept id="p1">&lt;/strong&gt;</ept> キーワードが必要です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="728">
          <source><ph id="ph1">`System.EventHandler`</ph> is a delegate type in the .NET Framework.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`System.EventHandler`</ph> は、.NET Framework のデリゲート タイプです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="729">
          <source>This term is used differently in X++ than it is in C# or the .NET Framework.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この用語は、C# または .NET Framework の場合とは異なる方法で、X++ で使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="730">
          <source>For more information, see X++ Keywords.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">詳細については、「X++ キーワード」を参照してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="731">
          <source>X++ Example</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ 例</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="732">
          <source>The important things to notice in the X++ example are the following:</source>
        <target logoport:matchpercent="100" state="translated" state-qualifier="leveraged-tm">X++ の例で注目すべき重要なことは次のとおりです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="733">
          <source>The <ph id="ph1">`XppClass`</ph> has a delegate member that is named <ph id="ph2">`myDelegate`</ph>.</source>
        <target logoport:matchpercent="100" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`XppClass`</ph> には、<ph id="ph2">`myDelegate`</ph> という名前のデリゲート メンバーが含まれます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="734">
          <source>The AOT contains a node for the delegate.</source><target logoport:matchpercent="87" state="translated" state-qualifier="fuzzy-match">AOT にはデリゲートのノードが含まれています。</target>
        </trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="735">
          <source>The node is located at AOT &gt; Classes &gt; XppClass &gt; myDelegate.</source>
        <target logoport:matchpercent="100" state="translated" state-qualifier="leveraged-tm">このノードは、[AOT] &gt; [クラス] &gt; <ph id="1">[XppClass]</ph> &gt; [myDelegate] にあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="736">
          <source>Several event handler nodes can be located under the myDelegate node.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">いくつかのイベント ハンドラー ノードは、myDelegate ノードの下に配置できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="737">
          <source>Event handlers that are represented by nodes in the AOT cannot be removed by the -= operator during run time.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">AOT ノードによって表されるイベント ハンドラーは、実行時に -= オペレーターによって削除できません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="738">
          <source>The <ph id="ph1">{}</ph> braces at the end of the delegate declaration are required, but they cannot have any code in them.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">デリゲート宣言の末尾の <ph id="ph1">{}</ph> カッコは必要ですが、カッコにコードを所持することはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="739">
          <source>The <ph id="ph1">`XppClass`</ph> has two methods whose parameter signatures are compatible with the delegate.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`XppClass`</ph> には、パラメーター シグネチャがデリゲートと互換性を持つ 2 つのメソッドがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="740">
          <source>One method is static.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">１ つの方法は静的です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="741">
          <source>The two compatible methods are added to the delegate with the += operator and the <bpt id="p1">**</bpt>eventHandler<ept id="p1">**</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">2 つの互換メソッドは、+= 演算子と <bpt id="p1">**</bpt>eventHandler<ept id="p1">**</ept> キーワードを使用してデリゲートに追加されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="742">
          <source>These statements do not call the event handler methods, the statements only add the methods to the delegate.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これらのステートメントはイベント ハンドラー メソッドを呼び出さず、ステートメントはデリゲートにメソッドを追加するだけです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="743">
          <source>The event is raised by one call to the delegate.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">デリゲートへの 1 回の呼び出しでイベントが発生します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="744">
          <source>The parameter value that passed in to the delegate is received by each event handler method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">デリゲートに渡されたパラメーター値は、各イベント ハンドラー メソッドによって受け取られます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="745">
          <source>The short X++ job at the top of the example starts the test.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">サンプルの一番上にある短い X++ ジョブがテストを開始します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="746">
          <source>The output from the previous X++ job is as follows:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">以前の X++ ジョブの出力は次のとおりです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="747">
          <source>C# Sample</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# サンプル</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="748">
          <source>This section contains a C<ph id="ph1">\#</ph> code sample for the event design pattern of the previous X++ sample.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このセクションには、以前の X++ サンプルのイベント設計パターンの C<ph id="ph1">\#</ph> コード サンプルが含まれています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="749">
          <source>The output from the previous C<ph id="ph1">\#</ph> sample is as follows:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">以前の C<ph id="ph1">\#</ph> サンプルの出力は次のとおりです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="750">
          <source>Events and the AOT</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">イベントおよび AOT</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="751">
          <source>Finance and Operations has other event systems that apply only to items in the AOT.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Finance and Operations には、AOT 内の品目のみに適用する他のイベント システムがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="752">
          <source>For more information, see Event Handler Nodes in the AOT.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">詳細については、「AOT でのイベント ハンドラー ノード」を参照してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="753">
          <source>Comparison: Precompiler Directives</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">比較: プリコンパイラのディレクティブ</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="754">
          <source>X++ and C# share some keywords for their precompiler directive syntax, but the meanings are not always the same.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ および C# はプリコンパイラー ディレクティブ構文の一部のキーワードを共有しますが、意味は常に同じではありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="755">
          <source>Similarities</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">類似点</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="756">
          <source>The X++ and C<ph id="ph1">\#</ph> compilers recognize many of the same keywords.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ および C<ph id="ph1">\#</ph> コンパイラは、同じキーワードの多くを認識します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="757">
          <source>In most cases, the keywords mean the same for both language compilers.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ほとんどの場合、キーワードは両言語のコンパイラに対して同じ意味を持ちます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="758">
          <source>Differences</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">違い</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="759">
          <source>A fundamental difference between the precompiler directives in X++ versus C<ph id="ph1">\#</ph> is the <ph id="ph2">\#</ph>define keyword that both language precompilers recognize.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ と C<ph id="ph1">\#</ph> でのプリコンパイラ ディレクティブの基本的な違いは、両方の言語プリコンパイラが認識できる<ph id="ph2">\#</ph>定義キーワードです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="760">
          <source>Unlike C<ph id="ph1">\#</ph>, in X++ the <ph id="ph2">\#</ph>define directive requires a dot in its syntax.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C<ph id="ph1">\#</ph> とは異なり、X++ では <ph id="ph2">\#</ph>define ディレクティブではその構文にドットを必要とします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="761">
          <source>In X++, parentheses can be used to give the defined symbol a value.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、定義済の記号に値を指定するために丸かっこを使用できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="762">
          <source>These differences are shown in the following examples:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これらの違いを次の例に示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="763">
          <source>In X++: <ph id="ph1">\#</ph>define.InitialYear(2003)</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++: <ph id="ph1">\#</ph>define.InitialYear(2003)</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="764">
          <source>In C<ph id="ph1">\#</ph>: <ph id="ph2">\#</ph>define InitialYear</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C<ph id="ph1">\#</ph>: <ph id="ph2">\#</ph>define InitialYear</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="765">
          <source>A minor difference is that in C<ph id="ph1">\#</ph> there can be spaces and tab characters between the <ph id="ph2">\#</ph> character and the directive keyword, such as <ph id="ph3">\#</ph> define Testing.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">小さな差異は、C<ph id="ph1">\#</ph> では、<ph id="ph2">\#</ph> 文字とディレクティブ キーワード (<ph id="ph3">\#</ph> テストの定義など) の間にスペースとタブ文字があることです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="766">
          <source>Identical Keywords</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">同一であるキーワード</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="767">
          <source>The following table lists precompiler directives that are similar in X++ and C<ph id="ph1">\#</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルは、X++ および C<ph id="ph1">\#</ph> で同様のプリコンパイラ ディレクティブを示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="768">
          <source>Keyword</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">キーワード</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="769">
          <source>X++</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="770">
          <source>C#</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C#</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="771">
          <source>Comments</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="772">
          <source>In X++, a precompiler variable name can be defined, and a value can be given to that variable.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、プリコンパイラ変数名を定義でき、その変数に値を指定できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="773">
          <source>In C<ph id="ph1">\#</ph>, a precompiler variable name can be defined, but no value can be given to that variable.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C<ph id="ph1">\#</ph> では、プリコンパイラ変数名を定義できますが、その変数に値を指定できません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="774">
          <source>Also, any <ph id="ph1">\#</ph>define in C<ph id="ph2">\#</ph> must occur at the top of the file, and cannot occur after any code such as a using statement or a class declaration.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">また、<ph id="ph1">\#</ph>C での定義<ph id="ph2">\#</ph>はファイルの先頭になければならず、using ステートメントやクラス宣言などのコードの後には出現できません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="775">
          <source>The C<ph id="ph1">\#</ph> compiler can input a command line parameter of <ph id="ph2">`/define`</ph> to define a precompiler variable name without defining the variable in any C<ph id="ph3">\#</ph> code file.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C<ph id="ph1">\#</ph> コンパイラは、C<ph id="ph3">\#</ph> コード ファイルで変数を定義しなくても、<ph id="ph2">`/define`</ph> のコマンドライン パラメーターを入力し、プリコンパイラ変数名を定義できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="776">
          <source>The X++ compiler has no counterpart to <ph id="ph1">`/define`</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ コンパイラには、<ph id="ph1">`/define`</ph> に相当するものはありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="777">
          <source>In X++, <ph id="ph1">\#</ph>if can determine whether a precompiler variable exists, and whether the variable has a given value.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、<ph id="ph1">\#</ph>if がプリコンパイラ変数が存在するかどうかと、変数に指定された値があるかどうかを特定できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="778">
          <source>In C<ph id="ph1">\#</ph>, <ph id="ph2">\#</ph>if can only determine whether a precompiler variable exists.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C<ph id="ph1">\#</ph> では、<ph id="ph2">\#</ph>if はプリコンパイラ変数が存在するかどうかのみ特定できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="779">
          <source>It cannot test for any value because no value can be assigned.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">値が割り当てられないため、任意の値のテストはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="780">
          <source>In X++, <ph id="ph1">\#</ph>endif marks the end of an <ph id="ph2">\#</ph>if block.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、<ph id="ph1">\#</ph>endif が <ph id="ph2">\#</ph>if ブロックの終了を示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="781">
          <source>It also ends an <ph id="ph1">\#</ph>ifnot block.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">また、<ph id="ph1">\#</ph>ifnot ブロックも終了します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="782">
          <source>In C<ph id="ph1">\#</ph>, <ph id="ph2">\#</ph>endif marks the end of an <ph id="ph3">\#</ph>if block, regardless of whether the block includes a <ph id="ph4">\#</ph>else.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C<ph id="ph1">\#</ph> では、ブロックに <ph id="ph4">\#</ph>else が含まれるかに関係なく、<ph id="ph2">\#</ph>endif を <ph id="ph3">\#</ph>if ブロックの最後に記述します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="783">
          <source>Different Keywords with the Same Processing Result</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">同じ処理結果を持つ異なるキーワード</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="784">
          <source>The following table lists precompiler directives that are named differently in X++ and C<ph id="ph1">\#</ph>, but that give the same results when processed.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルは、X++ および C<ph id="ph1">\#</ph> で異なる名前が付けられているが、処理時に同じ結果を与えるプリコンパイラ ディレクティブを示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="785">
          <source>X++</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="786">
          <source>C#</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C#</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="787">
          <source>Comments</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="788">
          <source><ph id="ph1">\#</ph>ifnot</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">\#</ph>ifnot</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="789">
          <source><ph id="ph1">\#</ph>if <ph id="ph2">\#</ph>else</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">\#</ph>if <ph id="ph2">\#</ph>else</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="790">
          <source>There is no <ph id="ph1">\#</ph>else directive in X++, but the <ph id="ph2">\#</ph>ifnot provides similar functionality.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ には <ph id="ph1">\#</ph>else ディレクティブはありませんが、<ph id="ph2">\#</ph>ifnot は同様の機能を提供します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="791">
          <source>In X++, <ph id="ph1">\#</ph>ifnot can determine whether a precompiler variable exists, and whether the variable does not have a specific given value.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、<ph id="ph1">\#</ph>ifnot がプリコンパイラ変数が存在するかどうかと、変数に指定された値がないかどうかを特定できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="792">
          <source>In C<ph id="ph1">\#</ph>, <ph id="ph2">\#</ph>if can determine whether a precompiler variable exists when the ‘!’</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C<ph id="ph1">\#</ph> では、<ph id="ph2">\#</ph>if は ‘!’ の場合にプリコンパイラ変数が存在するかどうかを特定できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="793">
          <source>symbol is prefixed to the variable name.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">symbol は変数名に対する接頭語になります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="794">
          <source><ph id="ph1">\#</ph>pragma warning</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">\#</ph>pragma 警告</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="795">
          <source>These X++ and C<ph id="ph1">\#</ph> entries are not equivalent, but there is a partial similarity.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これら X++ エントリと C<ph id="ph1">\#</ph> エントリは等価ではありませんが、部分的な類似性があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="796">
          <source>Both suppress compiler warning messages.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">どちらもコンパイラの警告メッセージを抑制します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="797">
          <source><ph id="ph1">\#</ph>macrolib</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">\#</ph>macrolib</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="798">
          <source>.HPP file in C++</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C++ 内の .HPP ファイル</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="799">
          <source>There is a partial similarity between the X++ directive <ph id="ph1">\#</ph>macrolib versus an .HPP file in C++.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ ディレクティブ <ph id="ph1">\#</ph>macrolib と C++ の .HPP ファイルの間には部分的な類似点があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="800">
          <source>Both can contain several <ph id="ph1">\#</ph>define statements.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">両方とも複数の<ph id="ph1">\#</ph>定義ステートメントを含めることができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="801">
          <source>Precompiler Directives Exclusive to X++</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ 限定のプリコンパイラ ディレクティブ</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="802">
          <source>The following table lists X++ precompiler directives that have no direct counterpart in C<ph id="ph1">\#</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルは、C<ph id="ph1">\#</ph> に直接対応するものがない X++ プリコンパイラ ディレクティブを示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="803">
          <source>X++</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="804">
          <source>Comments</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="805">
          <source><ph id="ph1">\#</ph>linenumber</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">\#</ph>linenumber</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="806">
          <source>The <ph id="ph1">\#</ph>linenumber directive is for obtaining the line number, so that it can be output to the Infolog.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">\#</ph> 行番号ディレクティブは、情報ログに出力できるように、行番号を取得するために使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="807">
          <source>The C<ph id="ph1">\#</ph> directive <ph id="ph2">\#</ph>line is different because its purpose is for setting the line number.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C<ph id="ph1">\#</ph> ディレクティブ <ph id="ph2">\#</ph> 行は、その目的が行番号を設定することであるため異なります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="808">
          <source><ph id="ph1">\#</ph>defdec <ph id="ph2">\#</ph>definc</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">\#</ph>defdec <ph id="ph2">\#</ph>definc</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="809">
          <source><ph id="ph1">\#</ph>globaldefine</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">\#</ph>globaldefine</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="810">
          <source>In X++, there is a small difference between <ph id="ph1">\#</ph>globaldefine versus <ph id="ph2">\#</ph>define.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、<ph id="ph1">\#</ph>globaldefine と <ph id="ph2">\#</ph>define はわずかに違います。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="811">
          <source>The difference is that <ph id="ph1">\#</ph>globaldefine never overwrites a current nonnull value that was assigned to a precompiler variable by <ph id="ph2">\#</ph>define.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">違いは、<ph id="ph1">\#</ph>globaldefine は、<ph id="ph2">\#</ph>define によってプリコンパイラ変数に割り当てられた現在の非 null 値を上書きしないことです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="812">
          <source>C<ph id="ph1">\#</ph> has nothing similar to this difference, because in C<ph id="ph2">\#</ph>, a precompiler variable name cannot be given a value.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C<ph id="ph2">\#</ph> ではプリコンパイラの変数名は値を指定することができないため、C<ph id="ph1">\#</ph> はこの違いと大きく異なっています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="813">
          <source><ph id="ph1">\#</ph>localmacro <ph id="ph2">\#</ph>macro</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">\#</ph>localmacro <ph id="ph2">\#</ph>マクロ</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="814">
          <source>In X++, <ph id="ph1">\#</ph>localmacro enables you to assign a multiline value to a precompiler variable.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、<ph id="ph1">\#</ph>localmacro を使用すると、プリコンパイラ変数に複数行の値を代入できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="815">
          <source><ph id="ph1">\#</ph>macro is a synonym, but <ph id="ph2">\#</ph>localmacro is recommended.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">\#</ph>マクロは同義語ですが、 <ph id="ph2">\#</ph>localmacro をお勧めします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="816">
          <source>In C<ph id="ph1">\#</ph>, the <ph id="ph2">\#</ph>define directive has part of this functionality, but it cannot assign a value to a precompiler variable.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C<ph id="ph1">\#</ph> では、<ph id="ph2">\#</ph>define ディレクティブにこの機能の一部がありますが、プリコンパイラ変数に値を代入できません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="817">
          <source><ph id="ph1">\#</ph>globalmacro</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">\#</ph>globalmacro</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="818">
          <source>In X++, <ph id="ph1">\#</ph>globalmacro is almost the same as the preferred <ph id="ph2">\#</ph>localmacro.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、<ph id="ph1">\#</ph>globalmacro は優先 <ph id="ph2">\#</ph>localmacro とほぼ同じです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="819">
          <source>Comparison: Object Oriented Programming</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">比較: オブジェクト指向プログラミング</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="820">
          <source>The object oriented programming (OOP) principles of X++ differ from C<ph id="ph1">\#</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ のオブジェクト指向プログラミング (OOP) の原則は、C<ph id="ph1">\#</ph> と異なります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="821">
          <source>Conceptual Comparisons</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">概念の比較</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="822">
          <source>The following table compares the implementation of OOP principles between X++ and C<ph id="ph1">\#</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルは、X++ と C<ph id="ph1">\#</ph> の間の OOP の原則の実装を比較しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="823">
          <source>Feature</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">機能</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="824">
          <source>X++</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="825">
          <source>C#</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C#</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="826">
          <source>Comments</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="827">
          <source>Casting</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">キャスティング</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="828">
          <source>The X++ language has the keywords <bpt id="p1">&lt;strong&gt;</bpt>is<ept id="p1">&lt;/strong&gt;</ept> and <bpt id="p2">&lt;strong&gt;</bpt>as<ept id="p2">&lt;/strong&gt;</ept>, which are used to make downcasts safe and explicit.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ 言語には、キーワード <bpt id="p1">&lt;strong&gt;</bpt>is<ept id="p1">&lt;/strong&gt;</ept> および <bpt id="p2">&lt;strong&gt;</bpt>as<ept id="p2">&lt;/strong&gt;</ept> があり、ダウンキャストを安全かつ明示的にするために使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="829">
          <source><bpt id="p1">**</bpt>Tip<ept id="p1">**</ept>: X++ does not require the use of the <bpt id="p2">&lt;strong&gt;</bpt>as<ept id="p2">&lt;/strong&gt;</ept> keyword when you downcast a base class variable to a derived class variable.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>ヒント<ept id="p1">**</ept>: X++ では、基本クラス変数を派生クラス変数にダウンキャストするときに、<bpt id="p2">&lt;strong&gt;</bpt>as<ept id="p2">&lt;/strong&gt;</ept> キーワードを使用する必要はありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="830">
          <source>However, we recommend that all downcast statements use the <bpt id="p1">&lt;strong&gt;</bpt>as<ept id="p1">&lt;/strong&gt;</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、すべてのダウンキャスト ステートメントで <bpt id="p1">&lt;strong&gt;</bpt>as<ept id="p1">&lt;/strong&gt;</ept> キーワードを使用することをお勧めします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="831">
          <source>An object can be cast either up or down the inheritance path.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">オブジェクトは継承パスを上または下にキャストすることができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="832">
          <source>Downcasts require the <bpt id="p1">&lt;strong&gt;</bpt>as<ept id="p1">&lt;/strong&gt;</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ダウンキャストは <bpt id="p1">&lt;strong&gt;</bpt>as<ept id="p1">&lt;/strong&gt;</ept> キーワードを必要とします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="833">
          <source>For more information about the X++ keywords <bpt id="p1">&lt;strong&gt;</bpt>is<ept id="p1">&lt;/strong&gt;</ept> and <bpt id="p2">&lt;strong&gt;</bpt>as<ept id="p2">&lt;/strong&gt;</ept>, see Expression Operators: Is and As for Inheritance.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ キーワード <bpt id="p1">&lt;strong&gt;</bpt>is<ept id="p1">&lt;/strong&gt;</ept> および <bpt id="p2">&lt;strong&gt;</bpt>as<ept id="p2">&lt;/strong&gt;</ept> の詳細については、式の演算子: 継承の Is および As を参照してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="834">
          <source>Local functions</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ローカル関数</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="835">
          <source>A method can contain a declaration and code body for zero or more local functions.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドには、ゼロ以上のローカル関数用の宣言およびコードの本文を含めることができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="836">
          <source>Only that method can have calls to the local function.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">そのメソッドのみローカル関数を呼び出すことができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="837">
          <source>C# 3.0 supports lambda expressions, which have some similarity to anonymous functions and local functions.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# 3.0 では、匿名関数およびローカル関数といくつかの類似点を持つラムダ式をサポートしています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="838">
          <source>Lambda expressions are often used with delegates.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ラムダ式は、デリゲートでよく使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="839">
          <source>Method overloading</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドのオーバーロード</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="840">
          <source>Method overloading is not supported.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドのオーバーロードはサポートされません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="841">
          <source>A method name can occur only one time per class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッド名は、クラスごとに 1 回のみ発生する場合があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="842">
          <source>Method overloading is supported.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドのオーバーロードはサポートされています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="843">
          <source>A method name can occur multiple times in one class, with different parameter signatures in each case.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッド名は、それぞれのケースで異なるパラメーターシグネチャを使用して、1 つのクラスで複数回発生する場合があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="844">
          <source>X++ does support optional parameters on methods.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ はメソッドでの省略可能パラメーターをサポートしています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="845">
          <source>Optional parameters can partially mimic method overloading.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">省略可能なパラメーターは、メソッドのオーバーロードを部分的に反映できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="846">
          <source>For more information, see the row for optional parameters in this table.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">詳細については、この表の、「オプション パラメーターの行」を参照してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="847">
          <source>Method overriding</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドのオーバーライド</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="848">
          <source>Method overriding is supported.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドのオーバーライドはサポートされています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="849">
          <source>A derived class can have a method by the same name as in the base class, as long as the parameter signature is the same in both cases.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">派生クラスは、パラメータの署名がどちらの場合も同じ限り、基本クラスと同じ名前のメソッドを持つことができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="850">
          <source>The only exception is that the overriding method can add a default value to a parameter.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">唯一の例外は、オーバーライドするメソッドがパラメーターに既定値を追加できることです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="851">
          <source>Method overriding is supported.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドのオーバーライドはサポートされています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="852">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>virtual<ept id="p1">&lt;/strong&gt;</ept> keyword must be applied to a method before the method can be overridden in a derived class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">派生クラスでメソッドを上書きするには、<bpt id="p1">&lt;strong&gt;</bpt>virtual<ept id="p1">&lt;/strong&gt;</ept> キーワードをメソッドに適用する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="853">
          <source>The concept of overriding a method includes the method name, its parameter signature, and its return type.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">上書きするメソッドの概念には、メソッド名、そのパラメーター署名および戻り値の型が含まれています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="854">
          <source>The concept of method overriding does not apply if the base method and the overriding method differ in any of these aspects.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドのオーバーライドの概念は、基準メソッドとオーバーライド メソッドがこれらの側面のいずれかで異なる場合は適用されません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="855">
          <source>Optional parameters</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">オプションのパラメーター</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="856">
          <source>A parameter declaration can be followed by a default value assignment.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">パラメーター宣言の後に既定値の割り当てを実行できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="857">
          <source>The method caller has the option of passing a value for that parameter, or ignoring the parameter to accept the default value.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッド呼び出し元には、そのパラメーターの値を渡すか、既定値を受け入れるようにパラメーターを無視するかの選択肢があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="858">
          <source>This feature mimics method overloading because two calls to the same method name can pass different numbers of parameters.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このメソッドは、同じメソッド名への 2 回の呼び出しが異なる数のパラメーターを渡すことができるため、メソッドのオーバーロードに似ています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="859">
          <source>Each parameter that has a default value must follow the last parameter that does not have a default value.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">既定値を持つ各パラメーターは、既定値を持たない最後のパラメーターに従う必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="860">
          <source>Optional parameters are supported by the <bpt id="p1">&lt;strong&gt;</bpt>params<ept id="p1">&lt;/strong&gt;</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">オプションのパラメーターは、<bpt id="p1">&lt;strong&gt;</bpt>params<ept id="p1">&lt;/strong&gt;</ept> キーワードによりサポートされます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="861">
          <source>Even without the <bpt id="p1">&lt;strong&gt;</bpt>params<ept id="p1">&lt;/strong&gt;</ept> keyword, from the point of view of the caller, method overloading can provide partially similar functionality.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">呼び出しの表示ポイントから<bpt id="p1">&lt;strong&gt;</bpt>パラメーター<ept id="p1">&lt;/strong&gt;</ept>キーワードが無くても、メソッドのオーバーロードは、部分的に同様の機能を提供できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="862">
          <source>For more information, see Parameters and Scoping and Using Optional Parameters.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">詳細については、「パラメーターとスコープおよびオプションのパラメーターの使用」を参照してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="863">
          <source>Single inheritance</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">単一の継承</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="864">
          <source>You can derive your X++ class from another X++ class by using the <bpt id="p1">&lt;strong&gt;</bpt>extends<ept id="p1">&lt;/strong&gt;</ept> keyword in the classDeclaration node of your class, in the AOT.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">AOT では、クラスの classDeclaration ノード内で <bpt id="p1">&lt;strong&gt;</bpt>extends<ept id="p1">&lt;/strong&gt;</ept> キーワードを使用することにより、X++ クラスを他の X++ クラスから派生させることができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="865">
          <source>No class implicitly derives directly from another class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">別のクラスから暗黙的に直接派生するクラスはありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="866">
          <source>If you want your class to directly derive from the <ph id="ph1">`Object`</ph> class, you must use the <bpt id="p1">&lt;strong&gt;</bpt>extends<ept id="p1">&lt;/strong&gt;</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラスを <ph id="ph1">`Object`</ph> クラスから直接派生させる場合は、<bpt id="p1">&lt;strong&gt;</bpt>拡張<ept id="p1">&lt;/strong&gt;</ept>キーワードを使用する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="867">
          <source>You can specify only one class on the <bpt id="p1">&lt;strong&gt;</bpt>extends<ept id="p1">&lt;/strong&gt;</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>extends<ept id="p1">&lt;/strong&gt;</ept> キーワード上では 1 つのクラスのみを指定することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="868">
          <source><bpt id="p1">**</bpt>Caution<ept id="p1">**</ept>: When you modify an X++ base class that other classes derive from, you must recompile that base class using the Compile forward.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>注意<ept id="p1">**</ept>: 他のクラスが派生する X++ 基本クラスを変更する場合は、コンパイル フォワードを使用してその基本クラスを再コンパイルする必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="869">
          <source>This option ensures that the derived classes are also recompiled.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このオプションを使用すると、派生クラスも再コンパイルされます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="870">
          <source>To ensure the derived classes are also recompiled, right-click the base class node, and then click Add-Ins &gt; Compile forward.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">派生クラスも再コンパイルされるようにするには、基本クラス ノードを右クリックし、[アドイン] &gt; [コンパイル フォワード] をクリックします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="871">
          <source>The alternative of clicking Build &gt; Compile (or pressing the F7 key) is sometimes insufficient for a base class change.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">[ビルド] &gt; [コンパイル] のクリック (または F7 キーを押すこと) という代わりの方法では、基底クラスを変更できない場合があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="872">
          <source>A class can implement zero to many interfaces.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラスは、ゼロから多くのインターフェイスを実装できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="873">
          <source>An X++ table implicitly inherits from the <ph id="ph1">`Common`</ph> table, and from the <ph id="ph2">`xRecord`</ph> class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ テーブルは <ph id="ph1">`Common`</ph> テーブル、および <ph id="ph2">`xRecord`</ph> クラスから暗黙的に継承します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="874">
          <source>C# uses the <bpt id="p1">&lt;strong&gt;</bpt>extends<ept id="p1">&lt;/strong&gt;</ept> keyword to derive from another class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">別のクラスから派生するために C# は<bpt id="p1">&lt;strong&gt;</bpt>拡張<ept id="p1">&lt;/strong&gt;</ept>キーワードを使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="875">
          <source>All .NET Framework classes implicitly derive from the <ph id="ph1">`System.Object`</ph> class, unless they explicitly derive from another class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">すべての .NET Framework クラスは明示的に別のクラスから派生しない限り、<ph id="ph1">`System.Object`</ph> クラスから暗黙的に派生しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="876">
          <source>Keyword Comparisons</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">キーワードの比較</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="877">
          <source>The following table lists the OOP-related keywords in X++ and C#.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルは、X++ および C＃ の OOP 関連のキーワードを示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="878">
          <source>Keyword</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">キーワード</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="879">
          <source>X++</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="880">
          <source>C#</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C#</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="881">
          <source>Comments</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="882">
          <source><bpt id="p1">&lt;strong&gt;</bpt>abstract<ept id="p1">&lt;/strong&gt;</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>抽象<ept id="p1">&lt;/strong&gt;</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="883">
          <source>No difference.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">差異はありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="884">
          <source><bpt id="p1">&lt;strong&gt;</bpt>class<ept id="p1">&lt;/strong&gt;</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>クラス<ept id="p1">&lt;/strong&gt;</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="885">
          <source>The modifiers <bpt id="p1">&lt;strong&gt;</bpt>public<ept id="p1">&lt;/strong&gt;</ept> and <bpt id="p2">&lt;strong&gt;</bpt>private<ept id="p2">&lt;/strong&gt;</ept> are ignored on class declarations.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">修飾子 <bpt id="p1">&lt;strong&gt;</bpt>パブリック<ept id="p1">&lt;/strong&gt;</ept> と <bpt id="p2">&lt;strong&gt;</bpt>プライベート<ept id="p2">&lt;/strong&gt;</ept> はクラス宣言で無視されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="886">
          <source>There is no concept of a namespace grouping of classes.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラスの名前空間グループ化の概念はありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="887">
          <source>There are no dots (.) in any class names.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">どのクラス名にもピリオド (.) はありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="888">
          <source>The modifiers <bpt id="p1">&lt;strong&gt;</bpt>public<ept id="p1">&lt;/strong&gt;</ept> and <bpt id="p2">&lt;strong&gt;</bpt>private<ept id="p2">&lt;/strong&gt;</ept> can be used to modify class declarations.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">修飾子 <bpt id="p1">&lt;strong&gt;</bpt>パブリック<ept id="p1">&lt;/strong&gt;</ept> と <bpt id="p2">&lt;strong&gt;</bpt>プライベート<ept id="p2">&lt;/strong&gt;</ept> を使用してクラス宣言を変更できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="889">
          <source>C# also has the keyword <bpt id="p1">&lt;strong&gt;</bpt>internal<ept id="p1">&lt;/strong&gt;</ept>, which relates to how classes are grouped together in assembly files.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C＃にはキーワード<bpt id="p1">&lt;strong&gt;</bpt>内部<ept id="p1">&lt;/strong&gt;</ept>があります。このキーワードは、クラスがアセンブリ ファイル内でグループ化されている方法が関連付けられています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="890">
          <source>There is no concept of a <bpt id="p1">&lt;strong&gt;</bpt>protected<ept id="p1">&lt;/strong&gt;</ept> class, only <bpt id="p2">&lt;strong&gt;</bpt>protected<ept id="p2">&lt;/strong&gt;</ept> members of a class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>protected<ept id="p1">&lt;/strong&gt;</ept> クラスの概念はなく、クラスの <bpt id="p2">&lt;strong&gt;</bpt>protected<ept id="p2">&lt;/strong&gt;</ept> メンバーのみあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="891">
          <source><bpt id="p1">&lt;strong&gt;</bpt>extends<ept id="p1">&lt;/strong&gt;</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>拡張<ept id="p1">&lt;/strong&gt;</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="892">
          <source>A class declaration can inherit from another class by using the <bpt id="p1">&lt;strong&gt;</bpt>extends<ept id="p1">&lt;/strong&gt;</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラス宣言は、<bpt id="p1">&lt;strong&gt;</bpt>拡張<ept id="p1">&lt;/strong&gt;</ept>キーワードを利用して、別のクラスから継承できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="893">
          <source>A colon (:) is used where the keywords <bpt id="p1">&lt;strong&gt;</bpt>extends<ept id="p1">&lt;/strong&gt;</ept> and <bpt id="p2">&lt;strong&gt;</bpt>implements<ept id="p2">&lt;/strong&gt;</ept> are used in X++.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>拡張<ept id="p1">&lt;/strong&gt;</ept>および<bpt id="p2">&lt;strong&gt;</bpt>実装<ept id="p2">&lt;/strong&gt;</ept>などのキーワードが X++ で使用される場合、コロン (:) が使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="894">
          <source><bpt id="p1">&lt;strong&gt;</bpt>final<ept id="p1">&lt;/strong&gt;</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>最終<ept id="p1">&lt;/strong&gt;</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="895">
          <source>A <bpt id="p1">&lt;strong&gt;</bpt>final<ept id="p1">&lt;/strong&gt;</ept> method cannot be overridden in a derived class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>最終<ept id="p1">&lt;/strong&gt;</ept>メソッドは、派生クラスで上書きすることはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="896">
          <source>A <bpt id="p1">&lt;strong&gt;</bpt>final<ept id="p1">&lt;/strong&gt;</ept> class cannot be extended.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>最終<ept id="p1">&lt;/strong&gt;</ept>クラスは拡張できません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="897">
          <source>The keyword <bpt id="p1">&lt;strong&gt;</bpt>sealed<ept id="p1">&lt;/strong&gt;</ept> on a class means the same thing that <bpt id="p2">&lt;strong&gt;</bpt>final<ept id="p2">&lt;/strong&gt;</ept> means on an X++ class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラスのキーワード <bpt id="p1">&lt;strong&gt;</bpt>シールド<ept id="p1">&lt;/strong&gt;</ept> は、<bpt id="p2">&lt;strong&gt;</bpt>最終<ept id="p2">&lt;/strong&gt;</ept> が X++クラスで意味するのと同じことを意味します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="898">
          <source><bpt id="p1">&lt;strong&gt;</bpt>implements<ept id="p1">&lt;/strong&gt;</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>実装<ept id="p1">&lt;/strong&gt;</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="899">
          <source>A class declaration can implement an <bpt id="p1">&lt;strong&gt;</bpt>interface<ept id="p1">&lt;/strong&gt;</ept> by using the <bpt id="p2">&lt;strong&gt;</bpt>implements<ept id="p2">&lt;/strong&gt;</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラス宣言では、<bpt id="p2">&lt;strong&gt;</bpt>実装<ept id="p2">&lt;/strong&gt;</ept>キーワードを利用して、<bpt id="p1">&lt;strong&gt;</bpt>インターフェイス<ept id="p1">&lt;/strong&gt;</ept>を実装することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="900">
          <source><bpt id="p1">&lt;strong&gt;</bpt>interface<ept id="p1">&lt;/strong&gt;</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>インターフェイス<ept id="p1">&lt;/strong&gt;</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="901">
          <source>An <bpt id="p1">&lt;strong&gt;</bpt>interface<ept id="p1">&lt;/strong&gt;</ept> can specify methods that the class must implement.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>インターフェイス<ept id="p1">&lt;/strong&gt;</ept>はクラスで実装する必要があるメソッドを指定できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="902">
          <source>An <bpt id="p1">&lt;strong&gt;</bpt>interface<ept id="p1">&lt;/strong&gt;</ept> can specify methods that the class must implement.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>インターフェイス<ept id="p1">&lt;/strong&gt;</ept>はクラスで実装する必要があるメソッドを指定できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="903">
          <source><bpt id="p1">&lt;strong&gt;</bpt>new<ept id="p1">&lt;/strong&gt;</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>新規<ept id="p1">&lt;/strong&gt;</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="904">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>new<ept id="p1">&lt;/strong&gt;</ept> keyword is used to allocate a new instance of a class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>new<ept id="p1">&lt;/strong&gt;</ept> キーワードは、クラスの新しいインスタンスを割り当てるために使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="905">
          <source>Then the constructor is automatically called.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コンストラクターは自動で呼び出されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="906">
          <source>Each class has exactly one constructor, and the constructor is named <ph id="ph1">`new`</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">各クラスには、厳密に 1 つのコンストラクターがあり、コンストラクターの名前は <ph id="ph1">`new`</ph> です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="907">
          <source>You can decide what parameters the constructor should input.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コンストラクターが入力するパラメーターを決定することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="908">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>new<ept id="p1">&lt;/strong&gt;</ept> keyword is used to create a new instance of a class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>new<ept id="p1">&lt;/strong&gt;</ept> キーワードは、クラスの新しいインスタンスを作成するために使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="909">
          <source>Then the constructor is automatically called.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コンストラクターは自動で呼び出されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="910">
          <source>Constructor methods themselves are not named <ph id="ph1">`new`</ph>, they have the same name as the class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コンストラクターのメソッド自体は <ph id="ph1">`new`</ph> という名前ではなく、クラスと同じ名前です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="911">
          <source><bpt id="p1">&lt;strong&gt;</bpt>Note:<ept id="p1">&lt;/strong&gt;</ept> The <bpt id="p2">&lt;strong&gt;</bpt>new<ept id="p2">&lt;/strong&gt;</ept> keyword can also be used on a method, to modify the way in which the method overrides the same method in the base class.</source><target logoport:matchpercent="101" state="translated" state-qualifier="id-match"><bpt id="p1">&lt;strong&gt;</bpt>注記<ept id="p1">&lt;/strong&gt;</ept>: <bpt id="p2">&lt;strong&gt;</bpt>新しい<ept id="p2">&lt;/strong&gt;</ept> キーワードはメソッドに使用することも可能で、メソッドがベースクラスの同じメソッドを上書きする方法を変更します。</target>
        </trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="912">
          <source>Both X++ and C# assume a default constructor for classes that have no constructor explicitly written in their code.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ と C# はどちらもコードで明示的に記述されたコンストラクターを持たないクラスの既定のコンストラクターであると想定します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="913">
          <source><bpt id="p1">&lt;strong&gt;</bpt>null<ept id="p1">&lt;/strong&gt;</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>NULL<ept id="p1">&lt;/strong&gt;</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="914">
          <source>No difference.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">差異はありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="915">
          <source><bpt id="p1">&lt;strong&gt;</bpt>private<ept id="p1">&lt;/strong&gt;</ept> and <bpt id="p2">&lt;strong&gt;</bpt>protected<ept id="p2">&lt;/strong&gt;</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>プライベート<ept id="p1">&lt;/strong&gt;</ept>および<bpt id="p2">&lt;strong&gt;</bpt>保護<ept id="p2">&lt;/strong&gt;</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="916">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>private<ept id="p1">&lt;/strong&gt;</ept> and <bpt id="p2">&lt;strong&gt;</bpt>protected<ept id="p2">&lt;/strong&gt;</ept> keywords can be used to modify the declaration of a class member.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>private<ept id="p1">&lt;/strong&gt;</ept> および <bpt id="p2">&lt;strong&gt;</bpt>protected<ept id="p2">&lt;/strong&gt;</ept> キーワードは、クラス メンバーの申告を変更するために使用できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="917">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>private<ept id="p1">&lt;/strong&gt;</ept> and <bpt id="p2">&lt;strong&gt;</bpt>protected<ept id="p2">&lt;/strong&gt;</ept> keywords can be used to modify the declaration of a class member.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>private<ept id="p1">&lt;/strong&gt;</ept> および <bpt id="p2">&lt;strong&gt;</bpt>protected<ept id="p2">&lt;/strong&gt;</ept> キーワードは、クラス メンバーの申告を変更するために使用できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="918">
          <source><bpt id="p1">&lt;strong&gt;</bpt>public<ept id="p1">&lt;/strong&gt;</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>パブリック<ept id="p1">&lt;/strong&gt;</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="919">
          <source>A method that is not modified with <bpt id="p1">&lt;strong&gt;</bpt>public<ept id="p1">&lt;/strong&gt;</ept>, <bpt id="p2">&lt;strong&gt;</bpt>protected<ept id="p2">&lt;/strong&gt;</ept>, or <bpt id="p3">&lt;strong&gt;</bpt>private<ept id="p3">&lt;/strong&gt;</ept> has the default access level of <bpt id="p4">&lt;strong&gt;</bpt>public<ept id="p4">&lt;/strong&gt;</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p4">&lt;strong&gt;</bpt>パブリック<ept id="p4">&lt;/strong&gt;</ept>の既定のアクセス レベルを持つ<bpt id="p1">&lt;strong&gt;</bpt>パブリック<ept id="p1">&lt;/strong&gt;</ept>、<bpt id="p2">&lt;strong&gt;</bpt>保護<ept id="p2">&lt;/strong&gt;</ept>、または<bpt id="p3">&lt;strong&gt;</bpt>プライベート<ept id="p3">&lt;/strong&gt;</ept>で変更されないメソッド。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="920">
          <source>A method that is not modified with <bpt id="p1">&lt;strong&gt;</bpt>public<ept id="p1">&lt;/strong&gt;</ept>, <bpt id="p2">&lt;strong&gt;</bpt>protected<ept id="p2">&lt;/strong&gt;</ept>, or <bpt id="p3">&lt;strong&gt;</bpt>private<ept id="p3">&lt;/strong&gt;</ept> has the default access level of <bpt id="p4">&lt;strong&gt;</bpt>private<ept id="p4">&lt;/strong&gt;</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p4">&lt;strong&gt;</bpt>プライベート<ept id="p4">&lt;/strong&gt;</ept>の既定のアクセス レベルを持つ<bpt id="p1">&lt;strong&gt;</bpt>パブリック<ept id="p1">&lt;/strong&gt;</ept>、<bpt id="p2">&lt;strong&gt;</bpt>保護<ept id="p2">&lt;/strong&gt;</ept>、または<bpt id="p3">&lt;strong&gt;</bpt>プライベート<ept id="p3">&lt;/strong&gt;</ept>で変更されないメソッド。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="921">
          <source><bpt id="p1">&lt;strong&gt;</bpt>static<ept id="p1">&lt;/strong&gt;</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>静的<ept id="p1">&lt;/strong&gt;</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="922">
          <source>A method can be <bpt id="p1">&lt;strong&gt;</bpt>static<ept id="p1">&lt;/strong&gt;</ept>, but a field cannot.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドは<bpt id="p1">&lt;strong&gt;</bpt>静的<ept id="p1">&lt;/strong&gt;</ept>にできますが、フィールドはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="923">
          <source>Both methods and fields can be <bpt id="p1">&lt;strong&gt;</bpt>static<ept id="p1">&lt;/strong&gt;</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドとフィールドの両方を<bpt id="p1">&lt;strong&gt;</bpt>静的<ept id="p1">&lt;/strong&gt;</ept>にすることができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="924">
          <source><bpt id="p1">&lt;strong&gt;</bpt>super<ept id="p1">&lt;/strong&gt;</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>スーパー<ept id="p1">&lt;/strong&gt;</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="925">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>super<ept id="p1">&lt;/strong&gt;</ept> keyword is used in a derived class to access the same method on its base class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>super<ept id="p1">&lt;/strong&gt;</ept> キーワードは、基本クラスで同じメソッドにアクセスするために派生クラスで使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="926">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>base<ept id="p1">&lt;/strong&gt;</ept> keyword is used in a derived class to access various methods in its base class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>base<ept id="p1">&lt;/strong&gt;</ept> キーワードは、基本クラスのさまざまなメソッドにアクセスするために派生クラスで使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="927">
          <source>In C#, there is special syntax for using <bpt id="p1">&lt;strong&gt;</bpt>base<ept id="p1">&lt;/strong&gt;</ept> to call the base constructor.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、<bpt id="p1">&lt;strong&gt;</bpt>ベース<ept id="p1">&lt;/strong&gt;</ept>を使用して基本コンストラクターを呼び出すための特別な構文があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="928">
          <source><bpt id="p1">&lt;strong&gt;</bpt>this<ept id="p1">&lt;/strong&gt;</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>この<ept id="p1">&lt;/strong&gt;</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="929">
          <source>For a call from one instance method to another on the same object, a qualifier for the called method is required.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">同じオブジェクトで 1 つのインスタンス メソッドから別への呼び出しで、呼び出されたメソッドの修飾子が必要です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="930">
          <source>The keyword <bpt id="p1">&lt;strong&gt;</bpt>this<ept id="p1">&lt;/strong&gt;</ept> is available as a qualifier for the current object.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">キーワード <bpt id="p1">&lt;strong&gt;</bpt>これ<ept id="p1">&lt;/strong&gt;</ept> は現在のオブジェクトの修飾子として使用できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="931">
          <source>For a call from one instance method to another on the same object, a qualifier for the called method is not required.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">同じオブジェクトで 1 つのインスタンス メソッドから別への呼び出しで、呼び出されたメソッドの修飾子は必要ではありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="932">
          <source>However, the <bpt id="p1">&lt;strong&gt;</bpt>this<ept id="p1">&lt;/strong&gt;</ept> keyword is available as a qualifier for the current object.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、<bpt id="p1">&lt;strong&gt;</bpt>この<ept id="p1">&lt;/strong&gt;</ept>キーワードは現在のオブジェクトの修飾子として使用できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="933">
          <source>In practice, the keyword <bpt id="p1">&lt;strong&gt;</bpt>this<ept id="p1">&lt;/strong&gt;</ept> can be helpful by displaying IntelliSense information.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">実際、キーワード <bpt id="p1">&lt;strong&gt;</bpt>this<ept id="p1">&lt;/strong&gt;</ept> は IntelliSense の情報を表示することで役に立ちます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="934">
          <source>The <ph id="ph1">`Object`</ph> class contains the <ph id="ph2">`finalize`</ph> method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`Object`</ph> クラスには、<ph id="ph2">`finalize`</ph> メソッドが含まれます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="935">
          <source>The <ph id="ph1">`finalize`</ph> method is not <bpt id="p1">&lt;strong&gt;</bpt>final<ept id="p1">&lt;/strong&gt;</ept>, and it can be overridden.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`finalize`</ph> メソッドは<bpt id="p1">&lt;strong&gt;</bpt>最終<ept id="p1">&lt;/strong&gt;</ept>でないため、オーバーライドできます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="936">
          <source>The <ph id="ph1">`finalize`</ph> method appears to resemble the <ph id="ph2">`System.Object.Finalize`</ph> method in C#, but in X++ the <ph id="ph3">`finalize`</ph> method has no special meaning of any kind.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`finalize`</ph> メソッドは、C# では <ph id="ph2">`System.Object.Finalize`</ph> メソッドと似ているように見えますが、X++ では <ph id="ph3">`finalize`</ph> メソッドにはどのような特別な意味もありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="937">
          <source>An object is automatically removed from memory when the last reference to the object stops referencing the object.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">オブジェクへの最後の参照がオブジェクトの参照を停止した場合、オブジェクトはメモリから自動的に削除されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="938">
          <source>For example, this can happen when the last reference goes out of scope or is assigned another object to reference.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">たとえば、これは、最後の参照がスコープ外になるまたは参照する他のオブジェクトが割り当てられる場合に、発生する可能性があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="939">
          <source>The methods <ph id="ph1">`Finalize`</ph> and <ph id="ph2">`Dispose`</ph> are common on some types of classes.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`Finalize`</ph> と <ph id="ph2">`Dispose`</ph> メソッドはいくつかのタイプのクラスで共通です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="940">
          <source>The garbage collector calls the <ph id="ph1">`Finalize`</ph> and <ph id="ph2">`Dispose`</ph> methods when it destroys and object.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ガベージ コレクターは、破棄して処理するときに、<ph id="ph1">`Finalize`</ph> メソッドと <ph id="ph2">`Dispose`</ph> メソッドを呼び出します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="941">
          <source>In C#, the <ph id="ph1">`System.GC.Collect`</ph> method in the .NET Framework can be called to start the garbage collector.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、.NET Framework の <ph id="ph1">`System.GC.Collect`</ph> メソッドを呼び出してガベージ コレクターを開始できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="942">
          <source>There is no similar function in X++ because X++ uses a deterministic garbage collector.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ には確定的なガベージ コレクターが使用されているため、X++ には似たような機能はありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="943">
          <source>Classes that are invoked from a menu have their <ph id="ph1">`main`</ph> method called by the system.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メニューから呼び出されるクラスには、システムによって呼び出される <ph id="ph1">`main`</ph> メソッドがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="944">
          <source>Classes that are invoked from a command line console have their <ph id="ph1">`Main`</ph> method called by the system.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コマンド ライン コンソールから呼び出されるクラスには、システムによって呼び出される <ph id="ph1">`Main`</ph> メソッドがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="945">
          <source>Comparison: Classes</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">比較: クラス</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="946">
          <source>When you use C<ph id="ph1">\#</ph> in the .NET Framework, classes are grouped into namespaces.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">.NET frameworkで C<ph id="ph1">\#</ph> を使用すると、クラスは名前空間にグループ分けされます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="947">
          <source>Each namespace focuses on a functional area such as file operations or reflection.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">各名前空間では、ファイル操作やリフレクションなどの機能区分に焦点を当てます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="948">
          <source>However, when you use the classes in X++, there are no visible groupings like a namespace.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、X++ のクラスを使用する場合、名前空間のようなグループ分けは表示されません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="949">
          <source>Comparison: Classes about Reflection</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">比較: リフレクションに関するクラス</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="950">
          <source>In X++ the <ph id="ph1">`TreeNode`</ph> class provides access to the Application Object Tree (AOT).</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、<ph id="ph1">`TreeNode`</ph> クラスがアプリケーション オブジェクト ツリー (AOT) へのアクセスを提供します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="951">
          <source>The <ph id="ph1">`TreeNode`</ph> class is the center of reflection functionality in X++.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`TreeNode`</ph> クラスは、X++ におけるリフレクション機能の中心です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="952">
          <source>The <ph id="ph1">`TreeNode`</ph> class and its methods can be compared to the <ph id="ph2">`System.Reflection`</ph> namespace in the .NET Framework that C<ph id="ph3">\#</ph> uses.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`TreeNode`</ph> クラスとそのメソッドは、C<ph id="ph3">\#</ph> が使用する .NET Framework において <ph id="ph2">`System.Reflection`</ph> 名前空間と比較できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="953">
          <source>The following table lists several classes that are available to you when you write C<ph id="ph1">\#</ph> code.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルに、C<ph id="ph1">\#</ph> コードを書くときに利用できるいくつかのクラスを示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="954">
          <source>These are .NET Framework classes.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これらは、.NET Framework クラスです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="955">
          <source>For this table, all C<ph id="ph1">\#</ph> classes are in the <ph id="ph2">`System.Reflection`</ph> namespace unless otherwise specified.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このテーブルでは、すべての C<ph id="ph1">\#</ph> クラスは、特に指定のない限り <ph id="ph2">`System.Reflection`</ph> 名前空間にあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="956">
          <source>Each row shows the corresponding class, or class member, that is available to you when your write X++ code.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">各行では、対応するクラスまたはクラス メンバーを示し、X++ コードを記述する際に利用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="957">
          <source>X++</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="958">
          <source>C#</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C#</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="959">
          <source>Comments</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="960">
          <source>Assembly is the first class to use when a C<ph id="ph1">\#</ph> program must gather reflection information.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">アセンブリは C<ph id="ph1">\#</ph> プログラムがリフレクション情報を収集する必要がある場合に使用する最初のクラスです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="961">
          <source>Static methods on the X++ class <ph id="ph1">`TreeNode`</ph> are the starting point for reflection in X++.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ クラスの静的メソッド <ph id="ph1">`TreeNode`</ph> は、X++ におけるリフレクションの開始点です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="962">
          <source>Instance methods on <ph id="ph1">`TreeNode`</ph> correspond to instance methods on <ph id="ph2">`System.Type`</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`TreeNode`</ph> のインスタンス メソッドは、<ph id="ph2">`System.Type`</ph> のインスタンス メソッドに対応します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="963">
          <source>The <ph id="ph1">`AOTgetSource`</ph> method returns several pieces of information together in one string.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`AOTgetSource`</ph> メソッドは、いくつかの情報を 1 つの文字列でまとめて返します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="964">
          <source>This includes the X++ source code in the method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これには、メソッドの X++ ソース コードが含まれます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="965">
          <source>In contrast, <ph id="ph1">`MethodInfo`</ph> has a separate member for each piece of information.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">対照的に、<ph id="ph1">`MethodInfo`</ph> には各情報に対する個別のメンバーがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="966">
          <source><ph id="ph1">`TreeNode .AOTfirstChild`</ph> <ph id="ph2">`TreeNode .AOTnextSibling`</ph> <ph id="ph3">`TreeNode .AOTiterator`</ph> <ph id="ph4">`AOTiterator`</ph></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`TreeNode .AOTfirstChild`</ph> <ph id="ph2">`TreeNode .AOTnextSibling`</ph> <ph id="ph3">`TreeNode .AOTiterator`</ph> <ph id="ph4">`AOTiterator`</ph></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="967">
          <source>MethodInfo<ph id="ph1">\[</ph><ph id="ph2">\]</ph> (an array)</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">MethodInfo<ph id="ph1">\[</ph><ph id="ph2">\]</ph> (配列)</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="968">
          <source>In C<ph id="ph1">\#</ph>, the <ph id="ph2">`GetMethods`</ph> method on <ph id="ph3">`System.Type`</ph> returns an array of MethodInfo objects.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C<ph id="ph1">\#</ph> では、<ph id="ph3">`System.Type`</ph> の <ph id="ph2">`GetMethods`</ph> メソッドは MethodInfo オブジェクトの配列を返します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="969">
          <source>You can loop through the array by the common technique of incrementing an indexer.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">インデクサーをインクリメントする一般的な手法により、配列の間をループことができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="970">
          <source>In contrast, the X++ model is to navigate the tree control of the AOT.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">対照的に、X++ モデルは、AOT のツリー コントロールを移動するためのものです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="971">
          <source>The <ph id="ph1">`TreeNode`</ph> methods of <ph id="ph2">`AOTfirstChild`</ph> and <ph id="ph3">`AOTnextSibling`</ph> accomplish the navigation.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph2">`AOTfirstChild`</ph> および <ph id="ph3">`AOTnextSibling`</ph> の <ph id="ph1">`TreeNode`</ph> メソッドは、ナビゲーションを実行します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="972">
          <source>As an equivalent alternative, the X++ <ph id="ph1">`AOTiterator`</ph> class is designed to navigate the tree control of the AOT.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">同等の代替として X++ <ph id="ph1">`AOTiterator`</ph> クラスは、AOT のツリー コントロールをナビゲートするように設計されています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="973">
          <source>A class node is the parent over several method nodes.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラス ノードは、いくつかのメソッド ノードの親です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="974">
          <source>The <ph id="ph1">`AOTiterator`</ph> steps through child nodes, returning each as another <ph id="ph2">`TreeNode`</ph> instance.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`AOTiterator`</ph> は、子ノードを順番に進み、それぞれ別の <ph id="ph2">`TreeNode`</ph> インスタンスとして返します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="975">
          <source>Additional resources the <ph id="ph1">`TreeNode`</ph> methods that are named <ph id="ph2">`AOTparent`</ph> and <ph id="ph3">`AOTprevious`</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph2">`AOTparent`</ph> および <ph id="ph3">`AOTprevious`</ph> という名前の追加のリソース <ph id="ph1">`TreeNode`</ph> メソッド。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="976">
          <source><ph id="ph1">`TreeNode .AOTgetProperty`</ph> <ph id="ph2">`TreeNode .AOTgetProperties`</ph> <ph id="ph3">`TreeNode .AOTname`</ph></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`TreeNode .AOTgetProperty`</ph> <ph id="ph2">`TreeNode .AOTgetProperties`</ph> <ph id="ph3">`TreeNode .AOTname`</ph></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="977">
          <source>In X++, the <ph id="ph1">`AOTgetProperties`</ph> method returns a long string that contains name-value pairs for all the properties of the <ph id="ph2">`TreeNode`</ph>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、<ph id="ph1">`AOTgetProperties`</ph> メソッドは <ph id="ph2">`TreeNode`</ph> のすべてのプロパティの名前と値のペアを含む長い文字列を返します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="978">
          <source>The <ph id="ph1">`AOTname`</ph> method returns a string that contains only the value for the name property.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`AOTname`</ph> メソッドは、名プロパティの値のみを含む文字列を返します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="979">
          <source><ph id="ph1">`TreeNode .AOTsave`</ph> <ph id="ph2">`TreeNode .AOTinsert`</ph></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`TreeNode .AOTsave`</ph> <ph id="ph2">`TreeNode .AOTinsert`</ph></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="980">
          <source><ph id="ph1">`System .Reflection .Emit`</ph> (namespace of classes)</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`System .Reflection .Emit`</ph> (クラスの名前空間)</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="981">
          <source>The <ph id="ph1">`AOTsave`</ph> method applies changes from a <ph id="ph2">`TreeNode`</ph> object in your X++ code to the AOT, and the changes are persisted.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`AOTsave`</ph> メソッドは、X++ コード内の <ph id="ph2">`TreeNode`</ph> オブジェクトからの変更を AOT に適用し、変更は維持されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="982">
          <source>For a large code sample, see TreeNode.AOTsave Method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">大規模なコード サンプルについては、TreeNode.AOTsave メソッドを参照してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="983">
          <source>Comparison: Classes about File IO</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">比較: ファイル IO に関するクラス</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="984">
          <source>There are several classes that perform file input and output (IO) operations.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ファイル入出力 (IO) 操作を実行するクラスはいくつかあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="985">
          <source>In the .NET Framework that is used in C<ph id="ph1">\#</ph>, the counterparts to these classes reside in the <ph id="ph2">`System.IO`</ph> namespace.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C<ph id="ph1">\#</ph> で使用されている .NET Framework では、これらのクラスに対応するものが <ph id="ph2">`System.IO`</ph> 名前空間に配置されています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="986">
          <source>The following table lists several .NET Framework classes for C<ph id="ph1">\#</ph> that are in the <ph id="ph2">`System.IO`</ph> namespace.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルは、<ph id="ph2">`System.IO`</ph> 名前空間にある C<ph id="ph1">\#</ph> のいくつかの .NET Framework クラスをリストしたものです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="987">
          <source>Each row in the table shows the X++ class or method that best corresponds to the .NET Framework class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">テーブルの各行は、.NET Framework クラスに最も対応する方法または X++ クラスを示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="988">
          <source>X++</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="989">
          <source>C#</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C#</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="990">
          <source>Comments</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="991">
          <source><ph id="ph1">`FileStream`</ph> <ph id="ph2">`BinaryReader`</ph> <ph id="ph3">`BinaryWriter`</ph></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`FileStream`</ph> <ph id="ph2">`BinaryReader`</ph> <ph id="ph3">`BinaryWriter`</ph></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="992">
          <source>X++ classes such as <ph id="ph1">`BinaryIo`</ph> that extend from the abstract class <ph id="ph2">`Io`</ph> serve as a stream, and they also serve as a reader and writer for that stream.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">抽象クラス <ph id="ph2">`Io`</ph> から拡張された <ph id="ph1">`BinaryIo`</ph> 等の X++ クラスはストリームとして機能し、そのストリームのリーダーおよびライターとしても機能します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="993">
          <source>In C# the stream is a separate class the from the class that has the more specific read and write methods.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C# では、ストリームはより具体的な読み取りおよび書き込みメソッドがあるクラスからの別のクラスです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="994">
          <source>These classes contain an in-memory buffer, and some of the methods treat the buffer as if it were a file on the hard disk.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これらのクラスにはメモリ内バッファがあり、メソッドの中には、バッファをハードディスク上のファイルであるかのように扱うものがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="995">
          <source>WINAPI::createDirectory WINAPI::folderExists WINAPI::removeDirectory</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">WINAPI::createDirectory WINAPI::folderExists WINAPI::removeDirectory</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="996">
          <source><ph id="ph1">`Directory`</ph> <ph id="ph2">`DirectoryInfo`</ph> <ph id="ph3">`Path`</ph></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`Directory`</ph> <ph id="ph2">`DirectoryInfo`</ph> <ph id="ph3">`Path`</ph></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="997">
          <source>X++ can use static methods in the <ph id="ph1">`WINAPI`</ph> class for many basic operating system functions that involve directories.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ はディレクトリを含む多くの基本オペレーティング システム関数の <ph id="ph1">`WINAPI`</ph> クラス内で静的メソッドを使用することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="998">
          <source>WINAPI::getDriveType</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">WINAPI::getDriveType</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="999">
          <source><ph id="ph1">`DriveInfo`</ph> <ph id="ph2">`DriveType`</ph></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`DriveInfo`</ph> <ph id="ph2">`DriveType`</ph></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1000">
          <source>These classes and methods are used to obtain drive related information.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これらのクラスとメソッドは、ドライブ関連の情報を取得するために使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1001">
          <source>WINAPI::copyFile WINAPI::createFile WINAPI::deleteFile WINAPI::fileExists</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">WINAPI::copyFile WINAPI::createFile WINAPI::deleteFile WINAPI::fileExists</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1002">
          <source><ph id="ph1">`File`</ph> <ph id="ph2">`FileAttributes`</ph> <ph id="ph3">`FileInfo`</ph></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`File`</ph> <ph id="ph2">`FileAttributes`</ph> <ph id="ph3">`FileInfo`</ph></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1003">
          <source>X++ can use static methods in the <ph id="ph1">`WINAPI`</ph> class for many basic operating system functions that involve files.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ はファイルを含む多くの基本オペレーティング システム関数の <ph id="ph1">`WINAPI`</ph> クラスで内で静的メソッドを使用することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1004">
          <source><ph id="ph1">`CommaIo`</ph> <ph id="ph2">`Comma7Io`</ph></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`CommaIo`</ph> <ph id="ph2">`Comma7Io`</ph></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1005">
          <source>(No corresponding class.)</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">(対応するクラスはありません。)</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1006">
          <source>These X++ classes can generate files that Microsoft Excel can import.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これらの X++ クラスは、Microsoft Excel がインポートできるファイルを生成できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1007">
          <source>In X++ an <bpt id="p1">&lt;a href="https://epplus.codeplex.com/"&gt;</bpt>EPPlus<ept id="p1">&lt;/a&gt;</ept> library reference is available for additional interaction with Excel.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ で、Excel との追加のインタラクションに <bpt id="p1">&lt;a href="https://epplus.codeplex.com/"&gt;</bpt>EPPlus<ept id="p1">&lt;/a&gt;</ept>ライブラリ リファレンスを使用できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1008">
          <source><ph id="ph1">`AsciiIo`</ph> <ph id="ph2">`TextIo`</ph></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`AsciiIo`</ph> <ph id="ph2">`TextIo`</ph></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1009">
          <source><ph id="ph1">`FileStream`</ph> <ph id="ph2">`TextReader`</ph> <ph id="ph3">`TextWriter`</ph></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`FileStream`</ph> <ph id="ph2">`TextReader`</ph> <ph id="ph3">`TextWriter`</ph></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1010">
          <source>These classes use different code pages.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これらのクラスはさまざまなコード ページを使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1011">
          <source><ph id="ph1">`Stream`</ph> <ph id="ph2">`StreamReader`</ph> <ph id="ph3">`StreamWriter`</ph> <ph id="ph4">`FileStream`</ph></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`Stream`</ph> <ph id="ph2">`StreamReader`</ph> <ph id="ph3">`StreamWriter`</ph> <ph id="ph4">`FileStream`</ph></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1012">
          <source>These are often used as base classes that other classes extend.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これらは、他のクラスが拡張する基本クラスとしてよく使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1013">
          <source><ph id="ph1">`CodeAccessPermission`</ph> <ph id="ph2">`FileIoPermission`</ph></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`CodeAccessPermission`</ph> <ph id="ph2">`FileIoPermission`</ph></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1014">
          <source><ph id="ph1">`System.Security`</ph> <ph id="ph2">`.CodeAccessPermission`</ph> The namespace <ph id="ph3">`System.Security.Permissions`</ph> includes the following classes:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`System.Security`</ph> <ph id="ph2">`.CodeAccessPermission`</ph> 名前空間 <ph id="ph3">`System.Security.Permissions`</ph> には、次のクラスが含まれます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1015">
          <source>The concepts and methods of <ph id="ph1">`assert`</ph>, <ph id="ph2">`demand`</ph>, and <ph id="ph3">`revertAssert`</ph> apply to both languages.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">`assert`</ph>、<ph id="ph2">`demand`</ph>、および <ph id="ph3">`revertAssert`</ph> の概念とメソッドは両方の言語に適用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1016">
          <source>However, the <ph id="ph1">`deny`</ph> and <ph id="ph2">`revertDeny`</ph> methods that are available in C# are not available in X++.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、C# で利用可能な <ph id="ph1">`deny`</ph> および <ph id="ph2">`revertDeny`</ph> メソッドは、X++ では使用できません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1017">
          <source>X++, ANSI SQL Comparison: SQL Select</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++、ANSI SQL 比較: SQL の選択</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1018">
          <source>In X++, the SQL <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statement syntax differs from the American National Standards Institute (ANSI) specification.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ では、SQL <bpt id="p1">**</bpt>select<ept id="p1">**</ept> ステートメントの構文は、米国規格協会 (ANSI) の仕様とは異なります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1019">
          <source>Single Table Select</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">1 つのテーブル選択</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1020">
          <source>The following table lists differences between the select statements of X++ SQL and ANSI SQL.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルで、X++ SQL および ANSI SQLの select ステートメントの相違点について説明します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1021">
          <source>Feature</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">機能</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1022">
          <source>X++ SQL</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ SQL</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1023">
          <source>ANSI SQL</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ANSI SQL</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1024">
          <source>Comments</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1025">
          <source>Table name on the <bpt id="p1">&lt;strong&gt;</bpt>from<ept id="p1">&lt;/strong&gt;</ept> clause.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>from<ept id="p1">&lt;/strong&gt;</ept> 句のテーブル名。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1026">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>from<ept id="p1">&lt;/strong&gt;</ept> clause lists a record buffer instance that is declared from a table, such as from the <ph id="ph1">`CustTable`</ph> table.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>from<ept id="p1">&lt;/strong&gt;</ept> 句は、<ph id="ph1">`CustTable`</ph> テーブルからなど、テーブルから宣言されているレコード バッファー インスタンスを一覧表示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1027">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>from<ept id="p1">&lt;/strong&gt;</ept> clause lists a table name, not the name of a buffer.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>from<ept id="p1">&lt;/strong&gt;</ept> 句は、バッファーの名前ではなく、テーブル名を一覧表示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1028">
          <source>The record buffer has all the methods that the <ph id="ph1">`xRecord`</ph>class has in X++.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">レコード バッファには、<ph id="ph1">`xRecord`</ph>class が X++ のすべてのメソッドがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1029">
          <source>Syntax sequence of the order by versus <bpt id="p1">&lt;strong&gt;</bpt>where<ept id="p1">&lt;/strong&gt;</ept> clauses.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">order by 句と <bpt id="p1">&lt;strong&gt;</bpt>where<ept id="p1">&lt;/strong&gt;</ept> 句の構文の順序。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1030">
          <source>The order by clause must appear before the <bpt id="p1">&lt;strong&gt;</bpt>where<ept id="p1">&lt;/strong&gt;</ept> clause.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">order by 句は、<bpt id="p1">&lt;strong&gt;</bpt>where<ept id="p1">&lt;/strong&gt;</ept> 句の前に指定する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1031">
          <source>The order by clause must appear after the <bpt id="p1">&lt;strong&gt;</bpt>from<ept id="p1">&lt;/strong&gt;</ept> or <bpt id="p2">&lt;strong&gt;</bpt>join<ept id="p2">&lt;/strong&gt;</ept> clause.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">order by 句は、<bpt id="p1">&lt;strong&gt;</bpt>from<ept id="p1">&lt;/strong&gt;</ept> 句または <bpt id="p2">&lt;strong&gt;</bpt>join<ept id="p2">&lt;/strong&gt;</ept> 句の後に指定する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1032">
          <source>The group by clause must follow the same syntax positioning rules that the order by follows.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">group by 句は、次の順序で同じ構文位置決めルールに従う必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1033">
          <source>The order by clause must appear after the <bpt id="p1">&lt;strong&gt;</bpt>where<ept id="p1">&lt;/strong&gt;</ept> clause.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">order by 句は、<bpt id="p1">&lt;strong&gt;</bpt>where<ept id="p1">&lt;/strong&gt;</ept> 句の後に指定する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1034">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>where<ept id="p1">&lt;/strong&gt;</ept> clause must appear after the <bpt id="p2">&lt;strong&gt;</bpt>from<ept id="p2">&lt;/strong&gt;</ept> or <bpt id="p3">&lt;strong&gt;</bpt>join<ept id="p3">&lt;/strong&gt;</ept> clause.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>where<ept id="p1">&lt;/strong&gt;</ept> 句は、<bpt id="p2">&lt;strong&gt;</bpt>from<ept id="p2">&lt;/strong&gt;</ept> 句または <bpt id="p3">&lt;strong&gt;</bpt>join<ept id="p3">&lt;/strong&gt;</ept> 句の後に指定する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1035">
          <source>In both X++ and ANSI SQL, the <bpt id="p1">&lt;strong&gt;</bpt>from<ept id="p1">&lt;/strong&gt;</ept> and <bpt id="p2">&lt;strong&gt;</bpt>join<ept id="p2">&lt;/strong&gt;</ept> clauses must appear before the order by and <bpt id="p3">&lt;strong&gt;</bpt>where<ept id="p3">&lt;/strong&gt;</ept> clauses.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ と ANSI SQL の両方では、<bpt id="p1">&lt;strong&gt;</bpt>from<ept id="p1">&lt;/strong&gt;</ept> および <bpt id="p2">&lt;strong&gt;</bpt>join<ept id="p2">&lt;/strong&gt;</ept> 句が order by および <bpt id="p3">&lt;strong&gt;</bpt>where<ept id="p3">&lt;/strong&gt;</ept> 句の前に表示されている必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1036">
          <source>Condition negation.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">条件の否定。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1037">
          <source>The exclamation mark ('!') is used for negation.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">感嘆符 ('!') は 否定を示すために使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1038">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>not<ept id="p1">&lt;/strong&gt;</ept> keyword is used for negation.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>not<ept id="p1">&lt;/strong&gt;</ept> キーワードは、否定を示すために使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1039">
          <source>X++ does not support the syntax !like.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ は構文 !like はサポートしません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1040">
          <source>Instead, you must apply the !</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">代わりに、! を適用する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1041">
          <source>operator to a clause.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">演算子を句に適用する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1042">
          <source>Wildcard characters for the <bpt id="p1">&lt;strong&gt;</bpt>like<ept id="p1">&lt;/strong&gt;</ept> operator.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>like<ept id="p1">&lt;/strong&gt;</ept> 演算子用ワイルドカード文字。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1043">
          <source>0 to many – Asterisk ('*')</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">0 から多数 - アスタリスク (「*」)</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1044">
          <source>Exactly 1 – Question mark ('?')</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">1 のみ – 疑問符 ('?')</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1045">
          <source>0 to many – Percent sign ('%')</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">0 から多数 - パーセントを記号 (「%」)</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1046">
          <source>Exactly 1 – Underbar ('_')</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">1 のみ – アンダーバー ('_')</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1047">
          <source>Logical operators in the <bpt id="p1">&lt;strong&gt;</bpt>where<ept id="p1">&lt;/strong&gt;</ept> clause.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>where<ept id="p1">&lt;/strong&gt;</ept> 句における論理演算子。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1048">
          <source>And – &amp;&amp;</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">および – &amp;&amp;</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1049">
          <source>Or – <ph id="ph1">\|</ph><ph id="ph2">\|</ph></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">または – <ph id="ph1">\|</ph><ph id="ph2">\|</ph></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1050">
          <source>And – <bpt id="p1">&lt;strong&gt;</bpt>and<ept id="p1">&lt;/strong&gt;</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">および – <bpt id="p1">&lt;strong&gt;</bpt>および<ept id="p1">&lt;/strong&gt;</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1051">
          <source>Or – <bpt id="p1">&lt;strong&gt;</bpt>or<ept id="p1">&lt;/strong&gt;</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">または – <bpt id="p1">&lt;strong&gt;</bpt>や<ept id="p1">&lt;/strong&gt;</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1052">
          <source>Code Example</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コードの例</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1053">
          <source>The following code example illustrates features in the previous table.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のコード例は、前のテーブルの機能を示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1054">
          <source>X++ SQL Keywords</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ SQL キーワード</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1055">
          <source>The following X++ SQL keywords are among those that are not part of ANSI SQL:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の X++ SQL キーワードは、ANSI SQL に含まれていないものです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1056">
          <source>crosscompany</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">crosscompany</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1057">
          <source>firstonly100</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">firstonly100</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1058">
          <source>forceliterals</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">forceliterals</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1059">
          <source>forcenestedloop</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">forcenestedloop</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1060">
          <source>forceplaceholders</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">forceplaceholders</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1061">
          <source>forceselectorder</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">forceselectorder</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1062">
          <source>validtimestate</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">validtimestate</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1063">
          <source>Join Clause</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">句の結合</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1064">
          <source>The following table lists differences about the <bpt id="p1">**</bpt>join<ept id="p1">**</ept> keyword of X++ SQL and ANSI SQL.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルで、X++ SQL および ANSI SQLの <bpt id="p1">**</bpt>結合<ept id="p1">**</ept> キーワードの相違点について説明します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1065">
          <source>Feature</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">機能</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1066">
          <source>X++ SQL</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ SQL</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1067">
          <source>ANSI SQL</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ANSI SQL</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1068">
          <source>Comments</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1069">
          <source>Columns list.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">列リスト。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1070">
          <source>The columns in the columns list must all come from the table listed in the <bpt id="p1">**</bpt>from<ept id="p1">**</ept> clause, and not from any table in a <bpt id="p2">**</bpt>join<ept id="p2">**</ept> clause.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">列リストの列は、<bpt id="p1">**</bpt>from<ept id="p1">**</ept> 句にリストされているテーブルから取得し、<bpt id="p2">**</bpt>join<ept id="p2">**</ept> 句のテーブルからは取得しないでください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1071">
          <source>Columns in the list cannot be qualified by their table name.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">リスト内の列は、テーブル名で修飾することはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1072">
          <source>The columns in the columns list can come from any table in the <bpt id="p1">**</bpt>from<ept id="p1">**</ept> or <bpt id="p2">**</bpt>join<ept id="p2">**</ept> clauses.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">列リストの列は、<bpt id="p1">**</bpt>from<ept id="p1">**</ept> または <bpt id="p2">**</bpt>join<ept id="p2">**</ept> 句の任意のテーブルから取得できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1073">
          <source>It helps others to maintain your code when you qualify the columns in the list with their table name.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これにより、他のユーザーはそのテーブル名のあるリスト内の列を修飾するときに、コードを維持することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1074">
          <source>For more information, see Select Statements on Fields.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">詳細については、「フィールドでの明細書の選択」を参照してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1075">
          <source><bpt id="p1">**</bpt>Join<ept id="p1">**</ept> clause syntax.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>Join<ept id="p1">**</ept> 句の構文。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1076">
          <source>The <bpt id="p1">**</bpt>join<ept id="p1">**</ept> clause follows the <bpt id="p2">**</bpt>where<ept id="p2">**</ept> clause.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>join<ept id="p1">**</ept> 句は <bpt id="p2">**</bpt>where<ept id="p2">**</ept> 句に従います。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1077">
          <source>The <bpt id="p1">**</bpt>join<ept id="p1">**</ept> clause follows a table in the <bpt id="p2">**</bpt>from<ept id="p2">**</ept> clause.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>join<ept id="p1">**</ept> 句は、<bpt id="p2">**</bpt>from<ept id="p2">**</ept> 句のテーブルに従います。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1078">
          <source>In the X++ code example, the <bpt id="p1">**</bpt>join<ept id="p1">**</ept> criteria is an equality of <ph id="ph1">`SalesPoolId`</ph> values.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ コードの例で、<bpt id="p1">**</bpt>join<ept id="p1">**</ept> の条件は <ph id="ph1">`SalesPoolId`</ph> 値と一致します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1079">
          <source><bpt id="p1">**</bpt>Inner<ept id="p1">**</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>内部<ept id="p1">**</ept>キーワード。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1080">
          <source>The default <bpt id="p1">**</bpt>join<ept id="p1">**</ept> mode is inner join.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">既定の <bpt id="p1">**</bpt>結合<ept id="p1">**</ept> モードは内部結合です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1081">
          <source>There is no <bpt id="p1">**</bpt>inner<ept id="p1">**</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>inner<ept id="p1">**</ept> キーワードがありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1082">
          <source>The default <bpt id="p1">**</bpt>join<ept id="p1">**</ept> mode is inner join.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">既定の <bpt id="p1">**</bpt>結合<ept id="p1">**</ept> モードは内部結合です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1083">
          <source>The <bpt id="p1">**</bpt>inner<ept id="p1">**</ept> keyword is available to make the code explicit.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>inner<ept id="p1">**</ept> キーワードは、コードを明確にするために使用できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1084">
          <source>The <bpt id="p1">**</bpt>outer<ept id="p1">**</ept> keyword exists in both X++ SQL and ANSI SQL.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>outer<ept id="p1">**</ept> キーワードは、X++ SQL と ANSI SQL の両方に存在します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1085">
          <source><bpt id="p1">**</bpt>Left<ept id="p1">**</ept> and <bpt id="p2">**</bpt>right<ept id="p2">**</ept> keywords.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>左<ept id="p1">**</ept>および<bpt id="p2">**</bpt>右<ept id="p2">**</ept>キーワード。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1086">
          <source>The <bpt id="p1">**</bpt>left<ept id="p1">**</ept> and <bpt id="p2">**</bpt>right<ept id="p2">**</ept> keywords are not available.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>left<ept id="p1">**</ept> および <bpt id="p2">**</bpt>right<ept id="p2">**</ept> キーワードは使用できません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1087">
          <source>All joins are left.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">すべての結合が残されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1088">
          <source>The <bpt id="p1">**</bpt>left<ept id="p1">**</ept> and <bpt id="p2">**</bpt>right<ept id="p2">**</ept> keywords are available to modify the <bpt id="p3">**</bpt>join<ept id="p3">**</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>left<ept id="p1">**</ept> および <bpt id="p2">**</bpt>right<ept id="p2">**</ept> キーワードは、<bpt id="p3">**</bpt>join<ept id="p3">**</ept> キーワードを変更するために使用できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1089">
          <source>No comments.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメントはありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1090">
          <source>Equality operator.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">等式演算子。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1091">
          <source>The double equal sign operator ('<ph id="ph1">`==`</ph>') is used to test for the equality of two values.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">二重等号演算子 ('<ph id="ph1">`==`</ph>') は、2 つの値の等価性をテストするために使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1092">
          <source>The single equal sign operator ('<ph id="ph1">`=`</ph>') is used to test for the equality of two values.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">一重等号演算子 ('<ph id="ph1">`=`</ph>') は、2 つの値の等価性をテストするために使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1093">
          <source>No comments.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメントはありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1094">
          <source>Code Example</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コードの例</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1095">
          <source>The following code example illustrates the <bpt id="p1">**</bpt>join<ept id="p1">**</ept> syntax in X++ SQL.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のコード例は、X++ SQL の <bpt id="p1">**</bpt>join<ept id="p1">**</ept> 構文を示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1096">
          <source>Aggregate Fields</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">集計フィールド</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1097">
          <source>The following table lists some differences in how aggregate fields in the <bpt id="p1">**</bpt>select<ept id="p1">**</ept> column list are referenced between X++ SQL and ANSI SQL.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルは、<bpt id="p1">**</bpt>選択<ept id="p1">**</ept> 列リストの集計フィールドが X++ SQL と ANSI SQL の間でどのように参照されるかの相違点を示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1098">
          <source>Aggregate fields are those that are derived by functions such as <bpt id="p1">**</bpt>sum<ept id="p1">**</ept> or <bpt id="p2">**</bpt>avg<ept id="p2">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">集計フィールドとは、<bpt id="p1">**</bpt>合計<ept id="p1">**</ept>または<bpt id="p2">**</bpt>平均<ept id="p2">**</ept>などの機能によって派生したものです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1099">
          <source>Feature</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">機能</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1100">
          <source>X++ SQL</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ SQL</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1101">
          <source>ANSI SQL</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ANSI SQL</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1102">
          <source>Comments</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1103">
          <source>Aggregate field name alias.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">集計フィールド名エイリアス。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1104">
          <source>The aggregate value is in the field that was aggregated.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">集計値は、集計されたフィールドにあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1105">
          <source>You can use the <bpt id="p1">**</bpt>as<ept id="p1">**</ept> keyword to tag an aggregate field with a name alias.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>as<ept id="p1">**</ept> キーワードを使用すると、名前エイリアス内の集計フィールドをタグ付けすることができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1106">
          <source>The alias can be referenced in subsequent code.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">エイリアスは、以降のコードで参照される場合があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1107">
          <source>For more information, see Aggregate Functions: Differences Between X++ and SQL</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">詳細については、「集計関数: X++ および SQL の差異」を参照してください</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1108">
          <source>Code Example</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コードの例</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1109">
          <source>In the following code example, the call to the info method illustrates the way to reference aggregate fields (see <ph id="ph1">`tPurchLine.QtyOrdered`</ph>).</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のコード例では、情報メソッドの呼び出しが集計フィールドを参照する方法を示しています (<ph id="ph1">`tPurchLine.QtyOrdered`</ph> を参照してください)。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1110">
          <source>Other Differences</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">その他の違い</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1111">
          <source>The following table lists other differences of the <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statement between the X++ SQL and ANSI SQL.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルに、X++ SQL および ANSI SQLの <bpt id="p1">**</bpt>select<ept id="p1">**</ept> ステートメントの相違点を示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1112">
          <source>Feature</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">機能</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1113">
          <source>X++ SQL</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ SQL</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1114">
          <source>ANSI SQL</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ANSI SQL</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1115">
          <source>Comments</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1116">
          <source>The <bpt id="p1">**</bpt>having<ept id="p1">**</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>having<ept id="p1">**</ept> キーワード。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1117">
          <source>There is no <bpt id="p1">**</bpt>having<ept id="p1">**</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>having<ept id="p1">**</ept> キーワードがありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1118">
          <source>The <bpt id="p1">**</bpt>having<ept id="p1">**</ept> keyword enables you to specify filter criteria for rows that are generated by the group by clause.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>having<ept id="p1">**</ept> キーワードを使用すると、group by 句によって生成された行のフィルター条件を指できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1119">
          <source>No comments.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメントはありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1120">
          <source>Null results.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">null の結果。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1121">
          <source>In a <bpt id="p1">**</bpt>while<ept id="p1">**</ept> select statement, if the <bpt id="p2">**</bpt>where<ept id="p2">**</ept> clause filters out all rows, no special count row is returned to report that.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>while<ept id="p1">**</ept> select ステートメントで、<bpt id="p2">**</bpt>where<ept id="p2">**</ept> 句がすべての行を除外する場合、それをレポートする特別なカウント行は返されません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1122">
          <source>In a <bpt id="p1">**</bpt>select<ept id="p1">**</ept>, if the <bpt id="p2">**</bpt>where<ept id="p2">**</ept> clause filters out all rows, a special count row is returned.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>select<ept id="p1">**</ept> で、<bpt id="p2">**</bpt>where<ept id="p2">**</ept> 句がすべての行を除外する場合、特別なカウント行が返されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1123">
          <source>The count value is 0.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">カウント値は 0 です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1124">
          <source>No comments.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメントはありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1125">
          <source>Cursors for navigating returned rows.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">戻された行を移動するためのカーソル。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1126">
          <source>The while select statement provides cursor functionality.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">while select 文は、カーソル機能を提供します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1127">
          <source>The alternative is to use the <bpt id="p1">**</bpt>next<ept id="p1">**</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">代わりに、<bpt id="p1">**</bpt>next<ept id="p1">**</ept> キーワードを使用することもできます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1128">
          <source>You can declare a <bpt id="p1">**</bpt>cursor<ept id="p1">**</ept> for looping through the rows that are returned from a <bpt id="p2">**</bpt>select<ept id="p2">**</ept> statement.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p2">**</bpt>select<ept id="p2">**</ept> ステートメントから戻される行間ループのために、<bpt id="p1">**</bpt>cursor<ept id="p1">**</ept> を宣言することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1129">
          <source><bpt id="p1">**</bpt>From<ept id="p1">**</ept> clause.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>From<ept id="p1">**</ept> 句。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1130">
          <source>The <bpt id="p1">**</bpt>from<ept id="p1">**</ept> keyword is optional when no columns are listed and only one table is referenced.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">列がリストされず、1 つのテーブルだけが参照される場合、<bpt id="p1">**</bpt>from<ept id="p1">**</ept> キーワードはオプションです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1131">
          <source>The following two syntax options are equivalent:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の 2 つの構文オプションは同等です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1132">
          <source>A <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statement cannot read from a table unless the <bpt id="p2">**</bpt>from<ept id="p2">**</ept> clause is used.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>選択<ept id="p1">**</ept>ステートメントは、<bpt id="p2">**</bpt>from<ept id="p2">**</ept> 句が使用されていない限り、テーブルから読み取ることはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1133">
          <source>In X++ SQL, the simple <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statement fills the table buffer variable with the first row that was returned.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ SQL では、シンプルな<bpt id="p1">**</bpt>選択<ept id="p1">**</ept>ステートメントが返された最初の行でテーブル バッファ変数を入力します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="1134">
          <source>This is illustrated by the following code fragment:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これは、次のコード フラグメントによって示されています。</target></trans-unit>
      </group>
    </body>
  </file>
</xliff>