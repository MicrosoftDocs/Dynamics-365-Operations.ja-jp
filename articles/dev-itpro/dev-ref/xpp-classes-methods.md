<?xml version="1.0" encoding="UTF-8"?>
<xliff xmlns:logoport="urn:logoport:xliffeditor:xliff-extras:1.0" xmlns:tilt="urn:logoport:xliffeditor:tilt-non-translatables:1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-US" original="xpp-classes-methods.md" target-language="ja-JP">
    <header>
      <tool tool-company="Microsoft" tool-version="1.0-7889195" tool-name="mdxliff" tool-id="mdxliff"/>
      <xliffext:skl_file_name>xpp-classes-methods.d84494.8ee078c78dabcc5a0e0e36e9495b8bc9891bbc40.skl</xliffext:skl_file_name>
      <xliffext:version>1.2</xliffext:version>
      <xliffext:ms.openlocfilehash>8ee078c78dabcc5a0e0e36e9495b8bc9891bbc40</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit>9d4c7edd0ae2053c37c7d81cdd180b16bf3a9d3b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff>05/15/2019</xliffext:ms.lasthandoff>
      <xliffext:ms.openlocfilepath>articles\dev-itpro\dev-ref\xpp-classes-methods.md</xliffext:ms.openlocfilepath>
    </header>
    <body>
      <group extype="content" id="content">
        <trans-unit xml:space="preserve" translate="yes" id="101" restype="x-metadata">
          <source>X++ classes and methods</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ クラスおよびメソッド</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="102" restype="x-metadata">
          <source>This topic describes how to create and use classes and interfaces in X++.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このトピックでは、X++ でクラスやインターフェイスを作成および使用する方法について説明します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="103">
          <source>X++ classes and methods</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ クラスおよびメソッド</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="104">
          <source>This topic describes how to create and use classes and interfaces in X++.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このトピックでは、X++ でクラスやインターフェイスを作成および使用する方法について説明します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="105">
          <source>Classes in X++</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ のクラス</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="106">
          <source>A <bpt id="p1">*</bpt>class<ept id="p1">*</ept> is a software construct that defines the data and methods of the objects that are later constructed from that class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">*</bpt>クラス<ept id="p1">*</ept>は、そのクラスから後に構築されるオブジェクトのデータとメソッドを定義するソフトウェア構造です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="107">
          <source>The objects that are constructed are known as <bpt id="p1">*</bpt>instances<ept id="p1">*</ept> or <bpt id="p2">*</bpt>objects<ept id="p2">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">構築されるオブジェクトは、<bpt id="p1">*</bpt>インスタンス<ept id="p1">*</ept> または <bpt id="p2">*</bpt>オブジェクト<ept id="p2">*</ept> と呼ばれます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="108">
          <source>(This topic uses the two terms interchangeably.) The data represents the state of the object, whereas the methods represent the behavior of the object.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">(このトピックでは、2 つの用語を同じ意味で使用しています。) データはオブジェクトの状態を表し、メソッドはオブジェクトの動作を表します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="109">
          <source><bpt id="p1">*</bpt>Variables<ept id="p1">*</ept> contain the data for the class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">*</bpt>変数<ept id="p1">*</ept>にはクラスのデータが含まれます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="110">
          <source>Variables in a class are specific to objects that are constructed from that class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラス内の変数は、そのクラスから構成されるオブジェクトに固有です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="111">
          <source>Every object that is constructed from the class declaration has its own copy of the variables.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラス宣言から構築されたすべてのオブジェクトには、独自の変数のコピーがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="112">
          <source>These variables are known as <bpt id="p1">*</bpt>instance variables<ept id="p1">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これらの変数は<bpt id="p1">*</bpt>インスタンス変数<ept id="p1">*</ept>と呼ばれます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="113">
          <source>Methods define the behavior of a class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドはクラスの動作を定義します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="114">
          <source>They are the sequences of statements that operate on the data.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">データに作用する一連のステートメントです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="115">
          <source>Typically, methods are declared to operate on the instance variables of the class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">通常、メソッドはクラスのインスタンス変数を操作するように宣言されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="116">
          <source>These methods are known as <bpt id="p1">*</bpt>instance methods<ept id="p1">*</ept> or <bpt id="p2">*</bpt>object methods<ept id="p2">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これらのメソッドは、<bpt id="p1">*</bpt>instance メソッド<ept id="p1">*</ept>または <bpt id="p2">*</bpt>object メソッド<ept id="p2">*</ept>と呼ばれます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="117">
          <source>You can also declare <bpt id="p1">*</bpt>static methods<ept id="p1">*</ept> and <bpt id="p2">*</bpt>static fields<ept id="p2">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">また、<bpt id="p1">*</bpt>静的メソッド<ept id="p1">*</ept> および <bpt id="p2">*</bpt>静的フィールド<ept id="p2">*</ept> を宣言することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="118">
          <source>Declaration of classes</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラスの宣言</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="119">
          <source>Create a class in Visual Studio</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Visual Studio でのクラスの作成</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="120">
          <source>Follow these steps to create a class in Microsoft Visual Studio.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Microsoft Visual Studio でクラスを作成するには、次の手順に従います。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="121">
          <source>In Server Explorer, right-click the project, and then click <bpt id="p1">**</bpt>Add<ept id="p1">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">サーバー エクスプローラーで、プロジェクトを右クリックしてから<bpt id="p1">**</bpt>追加<ept id="p1">**</ept>をクリックします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="122">
          <source>In the <bpt id="p1">**</bpt>New Item<ept id="p1">**</ept> dialog box, select <bpt id="p2">**</bpt>Class<ept id="p2">**</ept>, and then enter a name for the class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>新しい項目<ept id="p1">**</ept>ダイアログ ボックスで、<bpt id="p2">**</bpt>クラス<ept id="p2">**</ept>を選択してからクラスの名前を入力します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="123">
          <source>Click <bpt id="p1">**</bpt>Add<ept id="p1">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>追加<ept id="p1">**</ept> をクリックします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="124">
          <source>All classes are public.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">すべてのクラスはパブリックです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="125">
          <source>If you remove the <bpt id="p1">**</bpt>public<ept id="p1">**</ept> modifier, the system still treats the class as public.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>パブリック<ept id="p1">**</ept> モディファイアーを削除すると、システムではクラスはパブリック クラスとして扱われます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="126">
          <source>You can specify other modifiers on the class declaration, such as <bpt id="p1">**</bpt>final<ept id="p1">**</ept> and <bpt id="p2">**</bpt>extends<ept id="p2">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラス宣言では、<bpt id="p1">**</bpt>final<ept id="p1">**</ept> および <bpt id="p2">**</bpt>extends<ept id="p2">**</ept> などの、他の修飾子を指定することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="127">
          <source>Creating variables in a class</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラスで変数を作成しています</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="128">
          <source>All classes are public, but all member variables are implicitly protected.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">すべてのクラスはパブリックですが、すべてのメンバー変数は暗黙的に保護されています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="129">
          <source>However, you can modify the member variable declaration by using the private, protected or public keywords.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、private、protected または public キーワードを使用してメンバー変数宣言を変更することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="130">
          <source>All member variables belong to only object instances of the class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">すべてのメンバー変数はクラスのオブジェクト インスタンスにのみ属しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="131">
          <source>The following example shows how to use accessor methods to make the variable data public.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の例は、アクセサー メソッドを使用して変数データを公開する方法を示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="132">
          <source>Constructors</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コンストラクター</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="133">
          <source>To create an instance of a class, you must instantiate it by using a <bpt id="p1">*</bpt>constructor<ept id="p1">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラスのインスタンスを作成するには、<bpt id="p1">*</bpt>コンストラクタ<ept id="p1">*</ept>を使用してクラスのインスタンスを生成する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="134">
          <source>The default constructor is the <bpt id="p1">**</bpt>new<ept id="p1">**</ept> method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">既定のコンストラクターは、<bpt id="p1">**</bpt>新規<ept id="p1">**</ept> メソッドです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="135">
          <source>As a best practice, you should make the <bpt id="p1">**</bpt>new<ept id="p1">**</ept> method protected.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ベスト プラクティスとして、<bpt id="p1">**</bpt>新しい<ept id="p1">**</ept>メソッドを保護する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="136">
          <source>Instead, if initialization isn't required, you should use a <bpt id="p1">**</bpt>static construct<ept id="p1">**</ept> method as the public constructor for the class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">代わりに、初期化が必要ない場合、<bpt id="p1">**</bpt>静的コンストラクト<ept id="p1">**</ept> メソッドをクラスのパブリック コンストラクターとして使用する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="137">
          <source>Otherwise, you should use a <bpt id="p1">**</bpt>static new<ept id="p1">**</ept> method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">それ以外の場合、<bpt id="p1">**</bpt>新しい静的<ept id="p1">**</ept>なメソッドを使う必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="138">
          <source>Creating other objects in a constructor</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コンストラクターでその他のオブジェクトを作成しています</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="139">
          <source>A class constructor can instantiate other objects in addition to creating an instance of the class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラス コンストラクターは、クラスのインスタンスを作成するだけでなく、他のオブジェクトをインスタンス化することもできます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="140">
          <source>For example, the following code declares a <bpt id="p1">**</bpt>Rectangle<ept id="p1">**</ept> class that uses two <bpt id="p2">**</bpt>Point<ept id="p2">**</ept> objects to define its bounds.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">たとえば、次のコードは、境界を定義するため 2 つの<bpt id="p2">**</bpt>ポイント<ept id="p2">**</ept>オブジェクトを使用する<bpt id="p1">**</bpt>長方形<ept id="p1">**</ept>クラスを申告します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="141">
          <source>Destructors</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">デストラクター</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="142">
          <source>A <bpt id="p1">*</bpt>destructor<ept id="p1">*</ept> is used to explicitly destroy a class object.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">*</bpt>デストラクター<ept id="p1">*</ept>は、クラス オブジェクトを明示的に破棄するために使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="143">
          <source>Objects are automatically destroyed when there are no references to them.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">オブジェクトはへの参照がない場合、自動的に破棄されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="144">
          <source>However, you can destroy objects explicitly in the following ways:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、たとえば、次の方法で対象を明示的に破棄できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="145">
          <source>Use the <bpt id="p1">**</bpt>finalize<ept id="p1">**</ept> method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>finalize<ept id="p1">**</ept> メソッドを使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="146">
          <source>Set the object handle to <bpt id="p1">**</bpt>null<ept id="p1">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">オブジェクト ハンドルを <bpt id="p1">**</bpt>null<ept id="p1">**</ept> に設定します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="147">
          <source>Using the finalize method</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">finalize メソッドの使用</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="148">
          <source>Use the <bpt id="p1">**</bpt>finalize<ept id="p1">**</ept> method to explicitly destroy an object.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">オブジェクトを明示的に破棄するには <bpt id="p1">**</bpt>finalize<ept id="p1">**</ept> メソッドを使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="149">
          <source>There are no implicit calls to the <bpt id="p1">**</bpt>finalize<ept id="p1">**</ept> method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>finalize<ept id="p1">**</ept> メソッドへの暗黙的な呼び出しはありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="150">
          <source>You must call the method to run the statements in it.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">そこでステートメントを実行するメソッドを呼び出す必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="151">
          <source>The following example shows the basic structure for a call to the <bpt id="p1">**</bpt>finalize<ept id="p1">**</ept> method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の例は、<bpt id="p1">**</bpt>finalize<ept id="p1">**</ept> メソッドの呼び出しの基本構造を示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="152">
          <source>In the <bpt id="p1">**</bpt>finalize<ept id="p1">**</ept> method, you should also put any clean-up code that is required.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>finalize<ept id="p1">**</ept> メソッドでは、必要なクリーンアップ コードも配置する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="153">
          <source>For example, if your class uses a dynamic-link library (DLL) module, you can use the <bpt id="p1">**</bpt>finalize<ept id="p1">**</ept> method to release the DLL when you no longer require it.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">たとえば、クラスがダイナミックリンク ライブラリ (DLL) モジュールを使用する場合、必要ではなくなったときに DLL をリリースする<bpt id="p1">**</bpt>確定<ept id="p1">**</ept>メソッドを使用できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="154">
          <source>Use the <bpt id="p1">**</bpt>finalize<ept id="p1">**</ept> method carefully.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>finalize<ept id="p1">**</ept> メソッドは慎重に使用してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="155">
          <source>It will destroy an object even if there are references to it.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">オブジェクトへの参照がある場合オブジェクトを破棄します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="156">
          <source>Setting an object handle to null</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">オブジェクト ハンドルを null に設定</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="157">
          <source>Set the object handle to <bpt id="p1">**</bpt>null<ept id="p1">**</ept> to terminate an object.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">オブジェクト ハンドルを <bpt id="p1">**</bpt>null<ept id="p1">**</ept> に設定してオブジェクトを終了します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="158">
          <source>This approach destroys an object only if no other object handles point to that object.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この方法は、他のオブジェクト ハンドルがそのオブジェクトを指していない場合にのみオブジェクトを破棄します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="159">
          <source>You should verify that other code isn't using the object handle.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">他のコードがオブジェクト ハンドルを使用していないことを確認する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="160">
          <source>The following example creates an object handle and then sets it to <bpt id="p1">**</bpt>null<ept id="p1">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の例では、オブジェクト ハンドルを作成し、<bpt id="p1">**</bpt>null<ept id="p1">**</ept> に設定します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="161">
          <source>Creating a subclass</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">サブクラスを作成しています</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="162">
          <source><bpt id="p1">*</bpt>Subclasses<ept id="p1">*</ept> are classes that extend or inherit from other classes.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">*</bpt>サブクラス<ept id="p1">*</ept>は拡張または他のクラスから継承されるクラスです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="163">
          <source>A class can extend only one other class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラスは、他の 1 つのクラスのみ拡張することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="164">
          <source>Multiple inheritance isn't supported.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">複数の継承はサポートされていません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="165">
          <source>If you extend a class, the subclass inherits all the methods and variables in the parent class (the <bpt id="p1">*</bpt>superclass<ept id="p1">*</ept>).</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラスを拡張する場合、サブクラスが親クラスの (<bpt id="p1">*</bpt>スーパークラス<ept id="p1">*</ept>) すべてのメソッドと変数を継承します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="166">
          <source>Subclasses let you reuse existing code for a more specific purpose.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">サブクラスを使用すると、より特殊な目的で既存のコードを再利用できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="167">
          <source>Therefore, they help save you time during design, development, and testing.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">したがって、設計、開発、テストの時間を節約できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="168">
          <source>To customize the behavior of a superclass, override the methods in a subclass.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">スーパークラスの動作をカスタマイズするには、サブクラスのメソッドをオーバーライドします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="169">
          <source>A superclass is often known as a <bpt id="p1">*</bpt>base class<ept id="p1">*</ept>, and a subclass is often known as a <bpt id="p2">*</bpt>derived class<ept id="p2">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">多くの場合、スーパークラスは、<bpt id="p1">*</bpt>基本クラス<ept id="p1">*</ept>として知られており、サブクラスは、<bpt id="p2">*</bpt>派生クラス<ept id="p2">*</ept>として知られています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="170">
          <source>Subclass example</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">サブクラスの例</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="171">
          <source>The following example first creates a class that is named <bpt id="p1">**</bpt>Point<ept id="p1">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の例では、まず <bpt id="p1">**</bpt>Point<ept id="p1">**</ept> という名前のクラスを作成します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="172">
          <source>It then extends the <bpt id="p1">**</bpt>Point<ept id="p1">**</ept> class to create a new class that is named <bpt id="p2">**</bpt>ThreePoint<ept id="p2">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">その後、<bpt id="p1">**</bpt>Point<ept id="p1">**</ept> クラスを拡張して、<bpt id="p2">**</bpt>ThreePoint<ept id="p2">**</ept> という新しいクラスを作成します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="173">
          <source>Preventing class inheritance</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラスの継承を禁止する</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="174">
          <source>You can prevent classes from being inherited by using the <bpt id="p1">**</bpt>final<ept id="p1">**</ept> modifier.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>最終<ept id="p1">**</ept> モディファイアーを使用して、クラスが継承されないようにすることができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="175">
          <source>Methods</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッド</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="176">
          <source>The following code block types are standard for application classes:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のコード ブロック タイプは、アプリケーション クラスの標準です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="177">
          <source><bpt id="p1">*</bpt><bpt id="p2">&lt;strong&gt;</bpt><bpt id="p3">&lt;em&gt;</bpt>classDescription<ept id="p3">&lt;/em&gt;</ept><ept id="p2">*</ept> declaration block<ept id="p1">&lt;/strong&gt;</ept> – This declaration block contains class modifiers such as <bpt id="p4">&lt;strong&gt;</bpt>public<ept id="p4">&lt;/strong&gt;</ept>, <bpt id="p5">&lt;strong&gt;</bpt>private<ept id="p5">&lt;/strong&gt;</ept>, and <bpt id="p6">&lt;strong&gt;</bpt>extends<ept id="p6">&lt;/strong&gt;</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">*</bpt><bpt id="p2">&lt;strong&gt;</bpt><bpt id="p3">&lt;em&gt;</bpt>classDescription<ept id="p3">&lt;/em&gt;</ept><ept id="p2">*</ept> 申告ブロック<ept id="p1">&lt;/strong&gt;</ept> – この申告ブロックには<bpt id="p4">&lt;strong&gt;</bpt>パブリック<ept id="p4">&lt;/strong&gt;</ept>、<bpt id="p5">&lt;strong&gt;</bpt>プライベート<ept id="p5">&lt;/strong&gt;</ept>、および<bpt id="p6">&lt;strong&gt;</bpt>拡張<ept id="p6">&lt;/strong&gt;</ept>などのクラス モディファイアーが含まれます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="178">
          <source>It also contains the field members for objects that are constructed from the class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これには、クラスから作成されたオブジェクトのフィールドのメンバーも含まれます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="179">
          <source>When you type the keyword <bpt id="p1">&lt;strong&gt;</bpt>this<ept id="p1">&lt;/strong&gt;</ept>, IntelliSense can show a list of the members.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>this<ept id="p1">&lt;/strong&gt;</ept> というキーワードを入力すると、IntelliSense にメンバーのリストを表示することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="180">
          <source><bpt id="p1">*</bpt><bpt id="p2">&lt;strong&gt;</bpt><bpt id="p3">&lt;em&gt;</bpt>new<ept id="p3">&lt;/em&gt;</ept><ept id="p2">*</ept> method<ept id="p1">&lt;/strong&gt;</ept> – This method creates an instance of the class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">*</bpt><bpt id="p2">&lt;strong&gt;</bpt><bpt id="p3">&lt;em&gt;</bpt>新規<ept id="p3">&lt;/em&gt;</ept><ept id="p2">*</ept>メソッド<ept id="p1">&lt;/strong&gt;</ept> – このメソッドは、クラスのインスタンスを作成します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="181">
          <source>The constructor can be called only by using the <bpt id="p1">&lt;strong&gt;</bpt>new<ept id="p1">&lt;/strong&gt;</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コンストラクターは、<bpt id="p1">&lt;strong&gt;</bpt>新しい<ept id="p1">&lt;/strong&gt;</ept>キーワードを使用することによってのみ呼び出すことができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="182">
          <source>Derived classes can call the <bpt id="p1">&lt;strong&gt;</bpt>new<ept id="p1">&lt;/strong&gt;</ept> method of their constructor by calling the <bpt id="p2">&lt;strong&gt;</bpt>super<ept id="p2">&lt;/strong&gt;</ept> method reference.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">派生クラスは、<bpt id="p2">&lt;strong&gt;</bpt>super<ept id="p2">&lt;/strong&gt;</ept> メソッドの参照を呼ぶことにとって、コントラクターの<bpt id="p1">&lt;strong&gt;</bpt>新しい<ept id="p1">&lt;/strong&gt;</ept>メソッドを呼び出すことができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="183">
          <source><bpt id="p1">*</bpt><bpt id="p2">&lt;strong&gt;</bpt><bpt id="p3">&lt;em&gt;</bpt>finalize<ept id="p3">&lt;/em&gt;</ept><ept id="p2">*</ept> method<ept id="p1">&lt;/strong&gt;</ept> – This method finalizes an instance of the class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">*</bpt><bpt id="p2">&lt;strong&gt;</bpt><bpt id="p3">&lt;em&gt;</bpt>確定<ept id="p3">&lt;/em&gt;</ept><ept id="p2">*</ept>メソッド<ept id="p1">&lt;/strong&gt;</ept> – このメソッドは、クラスのインスタンスを確定します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="184">
          <source>This method is the destructor method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このメソッドはデストラクター メソッドです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="185">
          <source>However, it's a destructor by convention only.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、規則のみのデストラクタです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="186">
          <source>The system doesn't automatically call the <bpt id="p1">&lt;strong&gt;</bpt>finalize<ept id="p1">&lt;/strong&gt;</ept> method during garbage collection.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ガベージ コレクション中に <bpt id="p1">&lt;strong&gt;</bpt>finalize<ept id="p1">&lt;/strong&gt;</ept> メソッドが自動的に呼び出されることはありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="187">
          <source>Additional methods for a class have the following types:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラスの追加メソッドには、次のタイプがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="188">
          <source>Instance methods</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">インスタンス メソッド</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="189">
          <source>Static methods</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">静的メソッド</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="190">
          <source>Main methods</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">主要メソッド</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="191">
          <source>Methods can be created on many kinds of items.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">さまざまな種類の項目でメソッドを作成することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="192">
          <source>Here are some examples:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次にいくつか例を挙げます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="193">
          <source>Classes</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラス</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="194">
          <source>Maps</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">マップ</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="195">
          <source>Views</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ビュー</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="196">
          <source>Data Sets</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">データ セット</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="197">
          <source>Forms</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">フォーム</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="198">
          <source>Queries</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クエリ</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="199">
          <source>Instance methods</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">インスタンス メソッド</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="200">
          <source>Instance methods, or object methods, are embedded in each object that is created from the class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">インスタンス メソッド、またはオブジェクト メソッドは、クラスから作成される各オブジェクトに埋め込まれます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="201">
          <source>You must instantiate the object before you can use the method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドの使用前に、オブジェクトのインスタンスを作成する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="202">
          <source>If you later convert an instance method to a static method, you must restart the client.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">後でインスタンス メソッドを静的メソッドに変換する場合は、クライアントを再起動する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="203">
          <source>Otherwise, the compiler doesn't detect the change.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">それ以外の場合、コンパイラは変更を検出しません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="204">
          <source>After you've converted an instance method to a static method, you can no longer call the method from the instance of the class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">インスタンス メソッドを静的メソッドに変換した後は、クラスのインスタンスからメソッドを呼び出すことができなくなります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="205">
          <source>Instead, you must call the method from the class itself.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">代わりに、クラス自体からメソッドを呼び出す必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="206">
          <source>Static methods are discussed in the next section.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">静的メソッドは、次のセクションで説明します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="207">
          <source>You use the following syntax to call instance methods.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">インスタンス メソッドを呼び出すには、次の構文を使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="208">
          <source>Static methods</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">静的メソッド</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="209">
          <source>Static methods, which are also known as <bpt id="p1">*</bpt>class methods<ept id="p1">*</ept>, belong to a class and are created by using the keyword <bpt id="p2">**</bpt>static<ept id="p2">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">*</bpt>クラス メソッド<ept id="p1">*</ept>とも呼ばれる静的メソッドは、クラスに属しており、キーワード <bpt id="p2">**</bpt>static<ept id="p2">**</ept> を使用して作成されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="210">
          <source>You don't have to instantiate an object before you use static methods.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">静的メソッドを使用する前に、オブジェクトのインスタンスを作成する必要はありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="211">
          <source>Static methods are often used to work with data that is stored in tables.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">静的メソッドは多くの場合、テーブルに格納されているデータを操作するために使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="212">
          <source>Member variables can't be used in a static method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メンバー変数は静的メソッドで使用できません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="213">
          <source>You use the following syntax to call static methods.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">静的メソッドを呼び出すには、次の構文を使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="214">
          <source>Main methods</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">主要メソッド</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="215">
          <source>A <bpt id="p1">**</bpt>main<ept id="p1">**</ept> method is a class method that is run directly from a menu option.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>メイン<ept id="p1">**</ept>メソッドは、メニュー オプションから直接実行されるクラス メソッドです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="216">
          <source>The method should only create an instance of the object and then call the required member methods.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このメソッドでは、オブジェクトのインスタンスを作成してから、必要なメンバー メソッドを呼び出す必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="217">
          <source>The <bpt id="p1">**</bpt><ph id="ph1">\_</ph>args<ept id="p1">**</ept> parameter lets you transfer data to the method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt><ph id="ph1">\_</ph>args<ept id="p1">**</ept> パラメーターを使用して、メソッドにデータを転送できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="218">
          <source>Declaration of methods</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドの宣言</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="219">
          <source>Method declarations consist of a header and a body.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドの宣言は、ヘッダーと本文で構成されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="220">
          <source>The method header declares the method's name and return type), the method modifiers, and parameters.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッド ヘッダーは、メソッドの名前と戻り値の型、メソッド モディファイア、およびパラメーターを宣言します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="221">
          <source>(The return type might be <bpt id="p1">**</bpt>void<ept id="p1">**</ept>.) The method body consists of variable declarations, method declarations, and statements.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">(戻り値の型が<bpt id="p1">**</bpt>無効<ept id="p1">**</ept>である可能性があります。) メソッド本体は、変数宣言、メソッド宣言、および明細書で構成されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="222">
          <source>Return type</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">戻り値の型</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="223">
          <source>If a method doesn't return anything, you must use the <bpt id="p1">**</bpt>void<ept id="p1">**</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドが何も返さない場合、<bpt id="p1">**</bpt>無効<ept id="p1">**</ept>キーワードを使用する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="224">
          <source>The following example shows two methods.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の例は、2 つのメソッドを示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="225">
          <source>One method has a return type, but the other method doesn't have a return type.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">1 つの方法に戻り値の型がありますが、他の方法には戻り値の型がありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="226">
          <source>Syntax</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">構文</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="227">
          <source>Method declaration = <bpt id="p1">*</bpt>Heading<ept id="p1">*</ept>  <bpt id="p2">*</bpt>Body<ept id="p2">*</ept> Heading = <bpt id="p3">**</bpt><ph id="ph1">\[</ph><ept id="p3">**</ept> <bpt id="p4">*</bpt>Modifiers<ept id="p4">*</ept> <bpt id="p5">**</bpt><ph id="ph2">\]</ph><ept id="p5">**</ept>  <bpt id="p6">*</bpt>ReturnType<ept id="p6">*</ept>  <bpt id="p7">*</bpt>MethodName<ept id="p7">*</ept>  <bpt id="p8">**</bpt>(<ept id="p8">**</ept>  <bpt id="p9">*</bpt>ParameterList<ept id="p9">*</ept>  <bpt id="p10">**</bpt>)<ept id="p10">**</ept> Modifiers = <bpt id="p11">**</bpt><ph id="ph3">\[</ph>client<ph id="ph4">\]</ph> <ph id="ph5">\[</ph>server<ph id="ph6">\]</ph> <ph id="ph7">\[</ph>edit | display | public | protected | private<ph id="ph8">\]</ph> <ph id="ph9">\[</ph>static | abstract | final <ph id="ph10">\]</ph><ept id="p11">**</ept> ReturnType = <bpt id="p12">*</bpt>Datatype<ept id="p12">*</ept>  <bpt id="p13">**</bpt>| void | anytype<ept id="p13">**</ept> MethodName = <bpt id="p14">*</bpt>Identifier<ept id="p14">*</ept> ParameterList = <bpt id="p15">**</bpt><ph id="ph11">\[</ph><ept id="p15">**</ept> <bpt id="p16">*</bpt>Parameter<ept id="p16">*</ept>  <bpt id="p17">**</bpt>{ ,<ept id="p17">**</ept>  <bpt id="p18">*</bpt>Parameter<ept id="p18">*</ept>  <bpt id="p19">**</bpt>}<ph id="ph12">\]</ph><ept id="p19">**</ept> Parameter = <bpt id="p20">*</bpt>Datatype<ept id="p20">*</ept>  <bpt id="p21">*</bpt>Variableidentifier<ept id="p21">*</ept>  <bpt id="p22">**</bpt><ph id="ph13">\[</ph><ph id="ph14"> =</ph><ept id="p22">**</ept>  <bpt id="p23">*</bpt>Expression<ept id="p23">*</ept>  <bpt id="p24">**</bpt><ph id="ph15">\]</ph><ept id="p24">**</ept> Body = <bpt id="p25">**</bpt>{ <ph id="ph16">\[</ph><ept id="p25">**</ept>  <bpt id="p26">*</bpt>VariableDeclarations<ept id="p26">*</ept>  <bpt id="p27">**</bpt><ph id="ph17">\]</ph> <ph id="ph18">\[</ph><ept id="p27">**</ept>  <bpt id="p28">*</bpt>EmbeddedFunctionDeclarations<ept id="p28">*</ept>  <bpt id="p29">**</bpt><ph id="ph19">\]</ph> <ph id="ph20">\[</ph><ept id="p29">**</ept>  <bpt id="p30">*</bpt>Statements<ept id="p30">*</ept>  <bpt id="p31">**</bpt><ph id="ph21">\]</ph> }<ept id="p31">**</ept> EmbeddedFunctionDeclaration = <bpt id="p32">*</bpt>Heading<ept id="p32">*</ept>  <bpt id="p33">**</bpt>{<ph id="ph22">\[</ph><ept id="p33">**</ept>  <bpt id="p34">*</bpt>VariableDeclarations<ept id="p34">*</ept>  <bpt id="p35">**</bpt><ph id="ph23">\]</ph> <ph id="ph24">\[</ph><ept id="p35">**</ept>  <bpt id="p36">*</bpt>Statements<ept id="p36">*</ept>  <bpt id="p37">**</bpt><ph id="ph25">\]</ph>}<ept id="p37">**</ept> If you use the <bpt id="p38">**</bpt>anytype<ept id="p38">**</ept> return type, the method can return any data type.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドの宣言 = <bpt id="p1">*</bpt>ヘッダー<ept id="p1">*</ept>  <bpt id="p2">*</bpt>本文<ept id="p2">*</ept>ヘッダー = <bpt id="p3">**</bpt><ph id="ph1">\[</ph><ept id="p3">**</ept> <bpt id="p4">*</bpt>モディファイアー<ept id="p4">*</ept> <bpt id="p5">**</bpt><ph id="ph2">\]</ph><ept id="p5">**</ept>  <bpt id="p6">*</bpt>ReturnType<ept id="p6">*</ept>  <bpt id="p7">*</bpt>MethodName<ept id="p7">*</ept>  <bpt id="p8">**</bpt>(<ept id="p8">**</ept>  <bpt id="p9">*</bpt>ParameterList<ept id="p9">*</ept>  <bpt id="p10">**</bpt>)<ept id="p10">**</ept> モディファイアー = <bpt id="p11">**</bpt><ph id="ph3">\[</ph>クライアント<ph id="ph4">\]</ph> <ph id="ph5">\[</ph>サーバー<ph id="ph6">\]</ph> <ph id="ph7">\[</ph>edit | display | public | protected | private<ph id="ph8">\]</ph> <ph id="ph9">\[</ph>static | abstract | final <ph id="ph10">\]</ph><ept id="p11">**</ept> ReturnType = <bpt id="p12">*</bpt>Datatype<ept id="p12">*</ept>  <bpt id="p13">**</bpt>| void | anytype<ept id="p13">**</ept> MethodName = <bpt id="p14">*</bpt>識別子<ept id="p14">*</ept> ParameterList = <bpt id="p15">**</bpt><ph id="ph11">\[</ph><ept id="p15">**</ept> <bpt id="p16">*</bpt>パラメーター<ept id="p16">*</ept>  <bpt id="p17">**</bpt>{ ,<ept id="p17">**</ept>  <bpt id="p18">*</bpt>パラメーター<ept id="p18">*</ept>  <bpt id="p19">**</bpt>}<ph id="ph12">\]</ph><ept id="p19">**</ept> パラメーター = <bpt id="p20">*</bpt>Datatype<ept id="p20">*</ept>  <bpt id="p21">*</bpt>Variableidentifier<ept id="p21">*</ept>  <bpt id="p22">**</bpt><ph id="ph13">\[</ph><ph id="ph14"> =</ph><ept id="p22">**</ept>  <bpt id="p23">*</bpt>式<ept id="p23">*</ept>  <bpt id="p24">**</bpt><ph id="ph15">\]</ph><ept id="p24">**</ept> 本文 = <bpt id="p25">**</bpt>{<ph id="ph16">\[</ph><ept id="p25">**</ept>  <bpt id="p26">*</bpt>VariableDeclarations<ept id="p26">*</ept>  <bpt id="p27">**</bpt><ph id="ph17">\]</ph> <ph id="ph18">\[</ph><ept id="p27">**</ept> <bpt id="p28">*</bpt>EmbeddedFunctionDeclarations<ept id="p28">*</ept>  <bpt id="p29">**</bpt><ph id="ph19">\]</ph> <ph id="ph20">\[</ph><ept id="p29">**</ept>  <bpt id="p30">*</bpt>ステートメント<ept id="p30">*</ept>  <bpt id="p31">**</bpt><ph id="ph21">\]</ph> }<ept id="p31">**</ept> EmbeddedFunctionDeclaration = <bpt id="p32">*</bpt>ヘッダー<ept id="p32">*</ept>  <bpt id="p33">**</bpt>{<ph id="ph22">\[</ph><ept id="p33">**</ept>  <bpt id="p34">*</bpt>VariableDeclarations<ept id="p34">*</ept>  <bpt id="p35">**</bpt><ph id="ph23">\]</ph> <ph id="ph24">\[</ph><ept id="p35">**</ept> <bpt id="p36">*</bpt>ステートメント<ept id="p36">*</ept>  <bpt id="p37">**</bpt><ph id="ph25">\]</ph>}<ept id="p37">**</ept> <bpt id="p38">**</bpt>anytype<ept id="p38">**</ept> の戻り値の型を使用した場合、メソッドはあらゆるデータ型を返すことができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="228">
          <source>Example of a method that doesn't have a return type</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">戻り値の型を設定していないメソッドの例</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="229">
          <source>Example of a method that has parameters</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">パラメーターを持つメソッドの例</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="230">
          <source>In the following example, the <bpt id="p1">**</bpt>checkAccountBlocked<ept id="p1">**</ept> method returns a Boolean value and acts on the <bpt id="p2">**</bpt>amountCur<ept id="p2">**</ept> parameter.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の例では、<bpt id="p1">**</bpt>checkAccountBlocked<ept id="p1">**</ept> メソッドはブール値を返し、<bpt id="p2">**</bpt>amountCur<ept id="p2">**</ept> パラメーターで動作します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="231">
          <source>Method modifiers</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッド modifiers</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="232">
          <source>Several modifiers can be applied to method declarations.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">いくつかのモディファイアーは、メソッドの宣言に適用することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="233">
          <source>Some of the modifiers can be combined (for example, <bpt id="p1">**</bpt>final static<ept id="p1">**</ept>).</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">一部の修飾子を結合できます (たとえば、<bpt id="p1">**</bpt>final static<ept id="p1">**</ept>)。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="234">
          <source>Here are the method modifier keywords:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッド モディファイア キーワードを次に示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="235">
          <source><bpt id="p1">**</bpt>abstract<ept id="p1">**</ept> – The method is declared but isn't implemented in a parent class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>抽象<ept id="p1">**</ept> – メソッドは宣言されていますが、親クラスで実装されていません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="236">
          <source>The method must be overridden in subclasses.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このメソッドはサブクラスで上書きする必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="237">
          <source>If you try to create an object from a subclass where one or more abstract methods that belong to the parent class haven't been overridden, you receive a compiler error.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">サブクラスに親クラスに属する 1 つ以上の抽象メソッドがあり、オーバーライドされていません。そのサブクラスからオブジェクトを作成しようとすると、コンパイラ エラーが発生します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="238">
          <source>Classes can also be abstract.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラスは抽象クラスにすることもできます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="239">
          <source>Sometimes, a class should not be instantiated even though it represents an abstract concept.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">場合によっては、抽象的な概念を表す場合でもクラスをインスタンス化しないでください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="240">
          <source>Only subclasses should be instantiated.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">サブクラスのみインスタンスを作成する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="241">
          <source>Base classes of this type can be declared as <bpt id="p1">**</bpt>abstract<ept id="p1">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このタイプの基本クラスは<bpt id="p1">**</bpt>抽象<ept id="p1">**</ept>として宣言できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="242">
          <source>For example, you want to model the concept of an account.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">たとえば、勘定の概念をモデル化します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="243">
          <source>Accounts are abstract, because only derived classes (ledger accounts and so on) exist in the real world.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">実際の世界には派生クラス (勘定科目など) しか存在しないため、勘定は抽象です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="244">
          <source>This examples describes a clear case where you should declare the <bpt id="p1">**</bpt>Account<ept id="p1">**</ept> class as <bpt id="p2">**</bpt>abstract<ept id="p2">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この例では、<bpt id="p1">**</bpt>勘定<ept id="p1">**</ept> クラスを<bpt id="p2">**</bpt>抽象<ept id="p2">**</ept>として宣言する必要があるという明確なケースについて説明します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="245">
          <source><bpt id="p1">**</bpt>display<ept id="p1">**</ept> – The method's return value should be shown on a page or a report.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>ディスプレイ<ept id="p1">**</ept> – メソッドの戻り値は、ページまたはレポートに表示される必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="246">
          <source>The value can't be modified on the page or report.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ページまたはレポートで値を変更することはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="247">
          <source>Typically, the return value is a calculated value, such as a sum.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">通常、戻り値は合計などの計算された値です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="248">
          <source><bpt id="p1">**</bpt>edit<ept id="p1">**</ept> – The method's return type should be used to provide information for a field that is used on a page.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>編集<ept id="p1">**</ept> – メソッドの戻り値のタイプは、ページで使用されるフィールドの情報を提供するために使用する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="249">
          <source>The value in the field can be modified.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このフィールドの値は修正できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="250">
          <source><bpt id="p1">**</bpt>final<ept id="p1">**</ept> – The method can't be overridden in any class that derives from its class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>最終<ept id="p1">**</ept> – 同じクラスから派生したクラスのメソッドに上書きすることはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="251">
          <source><bpt id="p1">**</bpt>public<ept id="p1">**</ept> – Methods that are declared as <bpt id="p2">**</bpt>public<ept id="p2">**</ept> can be accessed anywhere that the class is accessible, and they can be overridden by subclasses.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>パブリック<ept id="p1">**</ept> – <bpt id="p2">**</bpt>パブリック<ept id="p2">**</ept>として宣言されるメソッドは、クラスがアクセスできるどの場所にもアクセスでき、サブクラスによって上書きすることができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="252">
          <source>Methods that have no access modifier are implicitly public.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">アクセス修飾子を持たないメソッドは暗黙的にパブリックとなります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="253">
          <source><bpt id="p1">**</bpt>protected<ept id="p1">**</ept> – Methods that are declared as <bpt id="p2">**</bpt>protected<ept id="p2">**</ept> can be called only from methods in the class and in subclasses that extend the class where the method is declared.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>保護されている<ept id="p1">**</ept> – <bpt id="p2">**</bpt>保護されている<ept id="p2">**</ept>として宣言されるメソッドは、クラスおよびメソッドが宣言されている拡張されたクラスであるサブクラスの中のメソッドからのみ呼び出すことができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="254">
          <source><bpt id="p1">**</bpt>private<ept id="p1">**</ept> – Methods that are declared as <bpt id="p2">**</bpt>private<ept id="p2">**</ept> can be called only from methods in the class where the private method is declared.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>プライベート<ept id="p1">**</ept> – <bpt id="p2">**</bpt>プライベート<ept id="p2">**</ept>として宣言されるメソッドは、プライベートメソッドが宣言されているクラスのメソッドからのみ呼び出すことができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="255">
          <source><bpt id="p1">**</bpt>static<ept id="p1">**</ept> – The method is a class method and doesn't act on an instance.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>静的<ept id="p1">**</ept> – このメソッドはクラス メソッドであり、インスタンスを実行しません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="256">
          <source>Static methods can't refer to instance variables.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">静的メソッドは、インスタンス変数を参照できません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="257">
          <source>They aren't invoked on an instance of the class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラスのインスタンスでは呼び出されません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="258">
          <source>Instead, they are invoked by using the class name (for example, <bpt id="p1">**</bpt>MyClass::aStaticProcedure()<ept id="p1">**</ept>).</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">代わりに、クラス名を使用して呼び出されます (たとえば、<bpt id="p1">**</bpt>MyClass::aStaticProcedure()<ept id="p1">**</ept>)。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="259">
          <source>Methods that have modifiers</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">モディファイアーのあるメソッド</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="260">
          <source><bpt id="p1">**</bpt>Note:<ept id="p1">**</ept> The following examples show only the method headers.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>注記:<ept id="p1">**</ept> 次の例は、メソッド ヘッダーのみを示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="261">
          <source>Static class members</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">静的クラス メンバー</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="262">
          <source>You declare static class members by using the <bpt id="p1">**</bpt>static<ept id="p1">**</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">静的クラス メンバーを宣言するには、<bpt id="p1">**</bpt>静的<ept id="p1">**</ept> キーワードを使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="263">
          <source>The <bpt id="p1">**</bpt>static<ept id="p1">**</ept> keyword instructs the system to create only one instance of the method, regardless of the number of times that you call <bpt id="p2">**</bpt>new<ept id="p2">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>static<ept id="p1">**</ept> キーワードは、<bpt id="p2">**</bpt>new<ept id="p2">**</ept> を呼び出す回数に関係なく、メソッドの 1 つのインスタンスだけを作成するようシステムに指示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="264">
          <source>This one instance is used throughout your session.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この 1 つのインスタンスは、セッション全体で使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="265">
          <source>In general, static methods are intended for cases where the following criteria are met:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">一般に、静的メソッドは次の基準を満たしている場合を意図しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="266">
          <source>The method has no reason to access the member variables that are declared in the class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このメソッドは、クラス内で宣言されているメンバー変数にアクセスする必要はありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="267">
          <source>The method has no reason to call any instance (non-static) methods of the class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このメソッドは、クラスのインスタンス (静的でない) メソッドを呼び出す理由はありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="268">
          <source>Static methods</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">静的メソッド</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="269">
          <source>This section describes a scenario where a software key type is used to help prevent piracy.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このセクションでは、違法コピーを防止するためにソフトウェア キー タイプを使用するシナリオについて説明します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="270">
          <source>Each instance of a software key can have its own unique value.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ソフトウェア キーの各インスタンスには、固有の値を持つことが可能です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="271">
          <source>However, because all software keys must conform to the rules of software key design, the logic that tests for software key conformance is the same for all software keys.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、すべてのソフトウェア キーはソフトウェア キー設計のルールに準拠する必要があるため、ソフトウェア キーへの適合をテストするロジックはすべてのソフトウェア キーに対して同じです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="272">
          <source>Therefore, the method that contains the conformance validation logic should be static.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">したがって、適合性検証ロジックを含むメソッドは静的でなければなりません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="273">
          <source>Here is an example of a method that is declared by using the <bpt id="p1">**</bpt>static<ept id="p1">**</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>静的<ept id="p1">**</ept>キーワード使用して宣言されるメソッドの例を次に示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="274">
          <source>In the following example, you don't have to construct an instance of the <bpt id="p1">**</bpt>SoftwareKey<ept id="p1">**</ept> class before you call a static method on the class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の例では、クラスで静的メソッドを呼び出す前に <bpt id="p1">**</bpt>SoftwareKey<ept id="p1">**</ept> クラスのインスタンスを構築する必要はありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="275">
          <source>When you want to call the static <bpt id="p1">**</bpt>validateSoftwareKey<ept id="p1">**</ept> method, the syntax starts with the name of the class that contains the method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">静的な <bpt id="p1">**</bpt>validateSoftwareKey<ept id="p1">**</ept> メソッドを呼び出すときは、構文はそのメソッドを含むクラスの名前で始まります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="276">
          <source>A pair of colons (::) is used to connect the class name to the static method name.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コロンのペア (::) は、クラス名を静的メソッド名に接続するために使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="277">
          <source>Static fields</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">静的フィールド</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="278">
          <source>Static fields are fields that are declared by using the <bpt id="p1">**</bpt>static<ept id="p1">**</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">静的フィールドは<bpt id="p1">**</bpt>静的<ept id="p1">**</ept>キーワードを使用して宣言されているフィールドです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="279">
          <source>Conceptually, they apply to the class, not to instances of the class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">概念的には、クラスに適用され、クラスのインスタンスには適用されません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="280">
          <source>Static constructors</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">静的コンストラクター</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="281">
          <source>Static constructors are guaranteed to run before any static or instance calls are made to the class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">静的コンストラクターは、静的またはインスタンス呼び出しがクラスに対して行われる前に実行されることが保証されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="282">
          <source>In C<ph id="ph1">\#</ph>, the <bpt id="p1">*</bpt>static<ept id="p1">*</ept> concept is related to the whole executing application domain.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">C<ph id="ph1">\#</ph> では、<bpt id="p1">*</bpt>静的<ept id="p1">*</ept>の概念が実行中のアプリケーション ドメイン全体に関係します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="283">
          <source>However, in X++, the execution of the static constructor is relative to the user’s session.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、X++ では、静的コンストラクターの実行は、ユーザーのセッションに対して相対的です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="284">
          <source>The static constructor has the following syntax.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">静的コンストラクターには、次の構文があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="285">
          <source>You never explicitly call the static constructor.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">静的コンストラクターは明示的に呼び出さないでください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="286">
          <source>The compiler will generate code to make sure that the constructor is called exactly one time before any other method on the class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コンパイラは、コンストラクターがクラスの他のメソッドの前に正確に 1 回呼び出されるようにするコードを生成します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="287">
          <source>A static constructor is used to initialize any static data or perform a particular action that must be performed only one time.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">静的コンストラクターは、任意の静的データを初期化したり、一度だけ実行する必要のある特定のアクションを実行するために使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="288">
          <source>No parameters can be provided for the static constructor, and it must be marked as <bpt id="p1">**</bpt>static<ept id="p1">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">静的コンストラクターに指定できるパラメーターはなく、<bpt id="p1">**</bpt>静的<ept id="p1">**</ept>としてマークする必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="289">
          <source>The following example shows how to create a singleton instance by using a static constructor.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の例は、静的コンストラクターを使用して単一のインスタンスを作成する方法を示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="290">
          <source>The singleton guarantees that only one instance of the class will ever be called.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">単一は、クラスのインスタンスが 1 つしか呼び出されないことを保証します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="291">
          <source>The following example shows how to instantiate the singleton.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の例は、単一をインスタンス化する方法を示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="292">
          <source>Method access control</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッド アクセス制御</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="293">
          <source>You use the accessor keywords <bpt id="p1">**</bpt>public<ept id="p1">**</ept>, <bpt id="p2">**</bpt>protected<ept id="p2">**</ept>, and <bpt id="p3">**</bpt>private<ept id="p3">**</ept> to control whether the methods in other classes can call the methods on your class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">その他のクラスのメソッドがお客様のクラスのメソッドを呼び出すことができるかどうかを制御するには、アクセサー キーワード <bpt id="p1">**</bpt>public<ept id="p1">**</ept>、<bpt id="p2">**</bpt>protected<ept id="p2">**</ept>、および <bpt id="p3">**</bpt>private<ept id="p3">**</ept> を使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="294">
          <source>The accessor keywords on methods also interact with the rules for class inheritance.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドのアクセス キーワードは、クラス継承のルールとも連携します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="295">
          <source>Here are the accessor keywords that you use with methods:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドを使用するアクセサー キーワードを次に示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="296">
          <source><bpt id="p1">**</bpt>public<ept id="p1">**</ept> – Methods that are declared as <bpt id="p2">**</bpt>public<ept id="p2">**</ept> can be called from anywhere that the class is accessible.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>パブリック<ept id="p1">**</ept> – <bpt id="p2">**</bpt>パブリック<ept id="p2">**</ept>として宣言されるメソッドは、クラスがアクセスできるどの場所からでも呼び出すことができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="297">
          <source>In addition, a public method can be overridden by a subclass, unless the method is declared as <bpt id="p1">**</bpt>final<ept id="p1">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">さらに、メソッドが<bpt id="p1">**</bpt>最終<ept id="p1">**</ept>として宣言されていない限り、パブリック メソッドをサブクラスでオーバーライドできます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="298">
          <source><bpt id="p1">**</bpt>protected<ept id="p1">**</ept> – Methods that are declared as <bpt id="p2">**</bpt>protected<ept id="p2">**</ept> can be called only from the following methods:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>保護されている<ept id="p1">**</ept> – <bpt id="p2">**</bpt>保護されている<ept id="p2">**</ept>として宣言されるメソッドは、次のメソッドからのみ呼び出すことができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="299">
          <source>Methods in the class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラスのメソッド。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="300">
          <source>Methods in a subclass of the class that contains the protected method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">保護されたメソッドを含むクラスのサブクラス内のメソッド。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="301">
          <source>Methods that are protected can be overridden in subclasses.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">保護されているメソッドは、サブクラスで上書きできます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="302">
          <source><bpt id="p1">**</bpt>private<ept id="p1">**</ept> – Methods that are declared as <bpt id="p2">**</bpt>private<ept id="p2">**</ept> can be called only from methods in the class where the private method is declared.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>プライベート<ept id="p1">**</ept> – <bpt id="p2">**</bpt>プライベート<ept id="p2">**</ept>として宣言されるメソッドは、プライベートメソッドが宣言されているクラスのメソッドからのみ呼び出すことができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="303">
          <source>No private method can be overridden in a subclass.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">サブクラスでプライベート メソッドをオーバーライドできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="304">
          <source>By default, when you create a new method, the <bpt id="p1">**</bpt>private<ept id="p1">**</ept> accessor keyword appears in the code editor.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">既定では、新しいメソッドを作成するときに、<bpt id="p1">**</bpt>プライベート<ept id="p1">**</ept> アクセサー キーワードがコード エディターに表示されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="305">
          <source>For maximum security, <bpt id="p1">**</bpt>private<ept id="p1">**</ept> is the most conservative default accessor keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">最大限のセキュリティについては、<bpt id="p1">**</bpt>プライベート<ept id="p1">**</ept>が最も保守的な既定のアクセス キーワードです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="306">
          <source>Static and instance methods</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">静的およびインスタンス メソッド</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="307">
          <source>The accessor keywords on methods never restrict calls between two methods that are in the same class, regardless of which method is static or non-static.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドのアクセサー キーワードは、どのメソッドが静的であるか、静的でないかに関係なく、同じクラスにある 2 つのメソッド間の呼び出しを制限することはありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="308">
          <source>In a static method, calls to the <bpt id="p1">**</bpt>new<ept id="p1">**</ept> constructor method are valid even if the <bpt id="p2">**</bpt>new<ept id="p2">**</ept> constructor method is decorated with the <bpt id="p3">**</bpt>private<ept id="p3">**</ept> modifier.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">静的メソッドでは、<bpt id="p2">**</bpt>新しい<ept id="p2">**</ept>コンストラクター メソッドが<bpt id="p3">**</bpt>プライベート<ept id="p3">**</ept> モディファイアーで修飾されている場合でも、<bpt id="p1">**</bpt>新しい<ept id="p1">**</ept>コンストラクター メソッドに対する呼び出しは有効です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="309">
          <source>The syntax for these calls requires that the <bpt id="p1">**</bpt>new<ept id="p1">**</ept> keyword be used.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これらの呼び出しの構文では、<bpt id="p1">**</bpt>新しい<ept id="p1">**</ept>キーワードを使用する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="310">
          <source>The code in a static method must construct an instance object of its own class before it can call any instance methods on the class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">静的メソッドのコードは、クラスのインスタンス メソッドを呼び出す前に、独自のクラスのインスタンス オブジェクトを構築する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="311">
          <source>Increasing access during overrides</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">オーバーライド中のアクセス増加</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="312">
          <source>When a method is overridden in a subclass, the overriding method must be at least as accessible as the overridden method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">サブクラス内でメソッドがオーバーライドされると、オーバーライドするメソッドは少なくともオーバーライドされるメソッドと同程度のアクセスが可能なことが必要です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="313">
          <source>For example, the following compiler rules apply when a protected method is overridden in a subclass:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">たとえば、次のコンパイラ ルールは、サブクラスで保護されたメソッドが上書きされる時に適用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="314">
          <source>A public method in a superclass can be overridden only by a public method in the subclass.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">スーパークラスのパブリック メソッドは、サブクラスのパブリック メソッドによってのみ上書きできます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="315">
          <source>In a subclass, a public or protected method can override a protected method of the superclass.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">サブクラスでは、パブリック メソッドまたは保護対象のメソッドはスーパークラスの保護対象のメソッドをオーバーライドできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="316">
          <source>In a subclass, a private method can't override a protected method of the superclass.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">サブクラスでは、プライベート メソッドはスーパークラスの保護対象のメソッドをオーバーライドできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="317">
          <source>Optional parameters</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">オプションのパラメーター</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="318">
          <source>Parameters can be initialized in the method declaration.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">パラメーターは、メソッド宣言で初期化することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="319">
          <source>In this case, the parameter becomes an <bpt id="p1">*</bpt>optional parameter<ept id="p1">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この場合、パラメーターは<bpt id="p1">*</bpt>オプションのパラメーター<ept id="p1">*</ept>となります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="320">
          <source>If no value is supplied in the method call, the default value is used.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドの呼び出しの値が指定されていない場合は、既定値が使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="321">
          <source>All required parameters must be listed before the first optional parameter.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">すべての必須パラメータは最初のオプション パラメーターの前に一覧表示する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="322">
          <source>The following examples show how to create and call a method that has optional parameters.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の例では、オプションのパラメーターを持つメソッドを作成して呼び出す方法を示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="323">
          <source>The example of the <bpt id="p1">**</bpt>AddThreeInts<ept id="p1">**</ept> method shows that you can't skip default parameters when you call a method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>AddThreeInts<ept id="p1">**</ept> メソッドの例は、メソッドを呼び出すときにデフォルトのパラメーターをスキップできないことを示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="324">
          <source>Examples of optional parameters</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">オプション パラメーターの例</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="325">
          <source>Accessor methods</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">アクセサー メソッド</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="326">
          <source>Class variables are private.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラス変数はプライベートです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="327">
          <source>By hiding details of the internal implementation of a class, you can change the implementation of the class later without breaking any code that uses that class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラスの内部実装の詳細を非表示にすることで、そのクラスを使用するコードを破棄することなくクラスの実装を後で変更することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="328">
          <source>To access the data from reference variables, you must create accessor methods.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">参照変数からデータにアクセスするには、アクセサー メソッドを作成する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="329">
          <source>The following example defines a <bpt id="p1">**</bpt>Point<ept id="p1">**</ept> class that uses accessor methods to access the variables <bpt id="p2">**</bpt>x<ept id="p2">**</ept> and <bpt id="p3">**</bpt>y<ept id="p3">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の例では、アクセス メソッドを使用して変数 <bpt id="p1">**</bpt>x<ept id="p1">**</ept> および <bpt id="p2">**</bpt>y<ept id="p2">**</ept> にアクセスする <bpt id="p3">**</bpt>Point<ept id="p3">**</ept> クラスを定義します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="330">
          <source>These method declarations show how the <bpt id="p1">**</bpt>Point<ept id="p1">**</ept> class provides access to its variables from the outside world.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これらのメソッド宣言は、<bpt id="p1">**</bpt>Point<ept id="p1">**</ept> クラスが外部からの変数へのアクセスを提供する方法を示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="331">
          <source>Other objects can manipulate the instance variables of <bpt id="p1">**</bpt>Point<ept id="p1">**</ept> objects by using the accessor methods.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">その他のオブジェクトは、アクセサー メソッドを使ってインスタンス変数 <bpt id="p1">**</bpt>Point<ept id="p1">**</ept> オブジェクトを操作できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="332">
          <source>The depth of the call stack is limited to 100.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コール スタックの深さは 100 に制限されています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="333">
          <source>Overriding a method</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドのオーバーライド</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="334">
          <source>The methods in a class are inherited by any class that extends it.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラス内のメソッドは、それを拡張するクラスによって継承されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="335">
          <source>To change the functionality of an inherited method, you can create a method in the subclass, and then give that method the same name and parameters as the method in the superclass.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">継承されたメソッドの機能を変更するには、サブクラスでメソッドを作成し、そのメソッドにスーパークラスのメソッドと同じ名前とパラメーターを指定します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="336">
          <source>This process is known as <bpt id="p1">*</bpt>overriding<ept id="p1">*</ept> the method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このプロセスは、メソッドを<bpt id="p1">*</bpt>オーバーライドする<ept id="p1">*</ept>として知られています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="337">
          <source>In the following example, <bpt id="p1">**</bpt>ColorAttribute<ept id="p1">**</ept> is a subclass of <bpt id="p2">**</bpt>Attribute<ept id="p2">**</ept> and therefore inherits the <bpt id="p3">**</bpt>methodAttr<ept id="p3">**</ept> method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の例では、<bpt id="p1">**</bpt>ColorAttribute<ept id="p1">**</ept> は<bpt id="p2">**</bpt>属性<ept id="p2">**</ept>のサブクラスであるため、<bpt id="p3">**</bpt>methodAttr<ept id="p3">**</ept> メソッドを継承します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="338">
          <source>However, because <bpt id="p1">**</bpt>ColorAttribute<ept id="p1">**</ept> defines a method that has the same name and the same number of arguments, the method in the superclass is overridden.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、<bpt id="p1">**</bpt>ColorAttribute<ept id="p1">**</ept> は同じ名前および同じ数の引数を持つメソッドを定義するため、スーパークラスのメソッドは上書きされます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="339">
          <source>Preventing method overrides</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドのオーバーライドを禁止する</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="340">
          <source>Static methods can't be overridden, because they exist per class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">静的メソッドは、クラスごとに存在するため上書きすることはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="341">
          <source>To protect other sensitive methods, or core methods, from being overridden, use the <bpt id="p1">**</bpt>final<ept id="p1">**</ept> modifier.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">他の重要なメソッドやコア メソッドがオーバーライドされないようにするには、<bpt id="p1">**</bpt>final<ept id="p1">**</ept> 修飾子を使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="342">
          <source>In the following example, because <bpt id="p1">**</bpt>methodAtt<ept id="p1">**</ept> is declared as <bpt id="p2">**</bpt>final<ept id="p2">**</ept>, it can't be overridden in any class that extends <bpt id="p3">**</bpt>Attribute<ept id="p3">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の例では、<bpt id="p1">**</bpt>methodAtt<ept id="p1">**</ept> が <bpt id="p2">**</bpt>final<ept id="p2">**</ept> として宣言されているため、<bpt id="p3">**</bpt>属性<ept id="p3">**</ept>を拡張するクラスでオーバーライドできません</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="343">
          <source>You should not specify <bpt id="p1">**</bpt>new<ept id="p1">**</ept> or <bpt id="p2">**</bpt>finalize<ept id="p2">**</ept> methods as <bpt id="p3">**</bpt>final<ept id="p3">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p3">**</bpt>最終<ept id="p3">**</ept> に <bpt id="p1">**</bpt>新規<ept id="p1">**</ept> または <bpt id="p2">**</bpt>確定<ept id="p2">**</ept> のメソッドを指定しないでください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="344">
          <source>The following example shows how to use the <bpt id="p1">**</bpt>final<ept id="p1">**</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の例は、<bpt id="p1">**</bpt>final<ept id="p1">**</ept> キーワードの使用方法を示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="345">
          <source>Overriding vs. overloading</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">オーバーライドとオーバーロード</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="346">
          <source>Overriding occurs when the superclass's implementation of a method is changed by the subclass's implementation of that method, but the signatures of both methods are the same.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">オーバーライドは、メソッドのスーパークラスの実装がそのメソッドのサブクラスの実装によって変更されるが、両方のメソッドのシグネチャが同じ場合に行われます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="347">
          <source>By contrast, <bpt id="p1">*</bpt>overloading<ept id="p1">*</ept> occurs when more than one method has the same name, but the methods have different signatures (return types, parameter lists, or both).</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">対照的に、<bpt id="p1">*</bpt>オーバーロード<ept id="p1">*</ept>は複数のメソッドが同じ名前を持つ場合に発生しますが、メソッドは異なるシグネチャ (戻り値の型、パラメーター リスト、または両方) を持ちます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="348">
          <source>X++ supports overriding, but it doesn't support overloading.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ はオーバーライドをサポートしますが、オーバーロードはサポートしていません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="349">
          <source>Parameters</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">パラメーター</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="350">
          <source>All methods have their own <bpt id="p1">*</bpt>scope<ept id="p1">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">すべてのメソッドは独自の<bpt id="p1">*</bpt>スコープ<ept id="p1">*</ept>を持っています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="351">
          <source>A method can take one or more parameters.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドは、1 つ以上のパラメーターを受け取ることができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="352">
          <source>Within the scope of the method, these parameters are treated as local variables and are initialized with a value from the parameter in the method call.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドのスコープ内では、これらのパラメーターはローカル変数として処理され、メソッド呼び出しのパラメーターからの値で初期化されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="353">
          <source>All parameters are passed by value.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">すべてのパラメーターは値で渡されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="354">
          <source>You can't change the value of the original variable.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">元の変数の値を変更することはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="355">
          <source>You can change only the local variable in the method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッド内のローカル変数のみを変更することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="356">
          <source>This local variable is a copy of the original variable.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このローカル変数は元の変数のコピーです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="357">
          <source>Scope of variables in methods</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッドでの変数の範囲</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="358">
          <source>A scope defines the area in which an item can be accessed.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">スコープは、品目にアクセスできるエリアを定義します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="359">
          <source>Variables that are defined in a class are available to the methods within that class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラスで定義されている変数は、そのクラス内のメソッドで使用できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="360">
          <source>Variables in methods can be accessed only within the current block.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッド内の変数は、現在のブロック内でのみアクセスできます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="361">
          <source>Local functions</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ローカル関数</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="362">
          <source>You can declare local functions inside a method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッド内部のローカル関数を宣言することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="363">
          <source>However, as a best practice, you shouldn't add local functions inside the method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、ベスト プラクティスとしては、メソッド内のローカル機能を追加する必要はありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="364">
          <source>Instead, you should add private methods to the class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">代わりに、プライベート メソッドをクラスに追加する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="365">
          <source>The following example shows valid declarations of two local functions, <bpt id="p1">**</bpt>localFunc55b<ept id="p1">**</ept> and <bpt id="p2">**</bpt>localFunc66c<ept id="p2">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の例は、2 つのローカル関数、<bpt id="p1">**</bpt>localFunc55b<ept id="p1">**</ept> および <bpt id="p2">**</bpt>localFunc66c<ept id="p2">**</ept> の有効な宣言を示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="366">
          <source>Calls to the local functions occur after the function declarations in the example, as is required.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ローカル関数への呼び出しは、必要に応じて、この例の関数宣言の後に行われます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="367">
          <source>Declaration of local functions</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ローカルの関数の宣言</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="368">
          <source>The declarations of local functions must physically precede any non-declaration statements in the method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ローカル関数の宣言は、メソッド内の宣言されていないステートメントの前に物理的に先行する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="369">
          <source>You can declare more than one local function in your method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メソッド内で 1 つ以上のローカル関数を宣言することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="370">
          <source>However, all local functions must be declared in an uninterrupted series, and the set must be terminated by one semicolon (;).</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、すべてのローカル関数は中断のないシリーズで宣言され、セットは 1 つのセミコロン (;) で終了する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="371">
          <source>Variable scope</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">変数のスコープ</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="372">
          <source>Code that is inside the local function can access variables that are declared in the method that contains the local function.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ローカル関数内にあるコードは、ローカル関数を含むメソッドで宣言されている変数にアクセスできます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="373">
          <source>Code that is outside the local function can't access variables that are declared in the local function.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ローカル関数の外にあるコードは、ローカル関数で宣言された変数にアクセスすることはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="374">
          <source>Calls to local functions</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ローカルの関数への呼び出し</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="375">
          <source>A local function can be called only by code in the same method where the local function is declared.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ローカル関数は、ローカル関数が宣言されているのと同じメソッド内のコードによってのみ呼び出すことができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="376">
          <source>A local function should never call itself.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ローカル関数が、それ自体を呼び出すことはありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="377">
          <source>Such recursion can prevent successful compilation.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このような再帰は、正常に行われるコンパイルを防ぐことができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="378">
          <source>The this keyword</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このキーワード</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="379">
          <source>The <bpt id="p1">**</bpt>this<ept id="p1">**</ept> keyword is a reference to the instance of the class or table where the <bpt id="p2">**</bpt>this<ept id="p2">**</ept> keyword is used.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>this<ept id="p1">**</ept> キーワードは、<bpt id="p2">**</bpt>this<ept id="p2">**</ept> キーワードが使用されるクラスやテーブルのインスタンスへの参照です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="380">
          <source>The <bpt id="p1">**</bpt>this<ept id="p1">**</ept> reference is never required, but it can clarify your code and enhances the behavior of IntelliSense in the code editor.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>this<ept id="p1">**</ept> 参照が必須になることはありませんが、コードを明確にし、コード エディターで IntelliSense の動作を強化することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="381">
          <source>All calls to instance methods must be qualified by either the <bpt id="p1">**</bpt>this<ept id="p1">**</ept> reference or a variable.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">すべての呼び出しインスタンス メソッドは<bpt id="p1">**</bpt>これ<ept id="p1">**</ept>を参照または変数のいずれかにより修飾される必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="382">
          <source>The <bpt id="p1">**</bpt>this<ept id="p1">**</ept> reference can be used to qualify the following information:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>this<ept id="p1">**</ept> 参照は、次の情報を修飾するために使用できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="383">
          <source>The names of other instance (non-static) methods in the same class where the <bpt id="p1">**</bpt>this<ept id="p1">**</ept> reference is used.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>this<ept id="p1">**</ept> 参照が使用されている同じクラス内の他のインスタンス (静的でない) メソッドの名前。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="384">
          <source>Here is an example: <bpt id="p1">**</bpt>boolColorChanged = this.colorItOrange();<ept id="p1">**</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次に例を示します: <bpt id="p1">**</bpt>boolColorChanged = this.colorItOrange();<ept id="p1">**</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="385">
          <source>The names of methods that are inherited by the <bpt id="p1">**</bpt>this<ept id="p1">**</ept> object.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>this<ept id="p1">**</ept> オブジェクトによって継承されるメソッドの名前。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="386">
          <source>The names of fields on the table that contains the method that the <bpt id="p1">**</bpt>this<ept id="p1">**</ept> keyword is used in.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>this<ept id="p1">**</ept> キーワードが使用されるメソッドを含むテーブル上のフィールドの名前。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="387">
          <source>The <bpt id="p1">**</bpt>this<ept id="p1">**</ept> reference can't be used in the following ways:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>this<ept id="p1">**</ept> 参照は、次の方法で使用できません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="388">
          <source>It can't qualify the names of member variables that are declared in the <bpt id="p1">**</bpt>classDeclaration<ept id="p1">**</ept> code.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>classDeclaration<ept id="p1">**</ept> コードで宣言されているメンバー変数の名前を限定することはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="389">
          <source>It can't be used in a static method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">静的メソッドで使用できません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="390">
          <source>It can't qualify the names of static methods of the class or table.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラスやテーブルの静的メソッドの名前を限定することはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="391">
          <source>Interfaces</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">インターフェイス</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="392">
          <source>An <bpt id="p1">&lt;em&gt;</bpt>interface<ept id="p1">&lt;/em&gt;</ept> is a specification for a set of public instance methods.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;em&gt;</bpt>インターフェイス<ept id="p1">&lt;/em&gt;</ept>はパブリック インスタンス メソッドのセットを指定します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="393">
          <source>An interface defines and enforces similarities between unrelated classes without having to derive one class from the other.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">他から 1 つのクラスを派生させることなく、インターフェイスは無関係なクラス間の類似点を定義し適用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="394">
          <source>All interfaces are public, even if you don't explicitly add the <bpt id="p1">&lt;strong&gt;</bpt>public<ept id="p1">&lt;/strong&gt;</ept> keyword *<bpt id="p2">&lt;strong&gt;</bpt><bpt id="p3">&lt;em&gt;</bpt>in front of the *<ept id="p3">&lt;/em&gt;</ept>interface<ept id="p2">&lt;/strong&gt;</ept> keyword *<bpt id="p4">&lt;strong&gt;</bpt><bpt id="p5">&lt;em&gt;</bpt>in the *<ept id="p5">&lt;/em&gt;</ept>classDeclaration<ept id="p4">&lt;/strong&gt;</ept> code.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">*<bpt id="p4">&lt;strong&gt;</bpt><bpt id="p5">&lt;em&gt;</bpt>*<ept id="p5">&lt;/em&gt;</ept>classDeclaration<ept id="p4">&lt;/strong&gt;</ept> コード内の<bpt id="p2">&lt;strong&gt;</bpt>インターフェイス キーワード*<bpt id="p3">&lt;em&gt;</bpt>の前に<ept id="p3">&lt;/em&gt;</ept><ept id="p2">&lt;/strong&gt;</ept><bpt id="p1">&lt;strong&gt;</bpt>パブリック<ept id="p1">&lt;/strong&gt;</ept> キーワード*を明示的に追加しなくても、すべてのインターフェイスはパブリックです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="395">
          <source>The methods on an interface are also public.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">インターフェイス上のメソッドも公開されています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="396">
          <source>Once again, explicit inclusion of the keyword <bpt id="p1">&lt;strong&gt;</bpt>public<ept id="p1">&lt;/strong&gt;</ept> is optional.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この場合も、<bpt id="p1">&lt;strong&gt;</bpt>パブリック<ept id="p1">&lt;/strong&gt;</ept>というキーワードを明示的に含めることはオプションです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="397">
          <source>To create an interface, follow these steps.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">インターフェイスを作成するには、次の手順を実行します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="398">
          <source>In Server Explorer, right-click the project, and then click <bpt id="p1">**</bpt>Add<ept id="p1">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">サーバー エクスプローラーで、プロジェクトを右クリックしてから<bpt id="p1">**</bpt>追加<ept id="p1">**</ept>をクリックします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="399">
          <source>In the <bpt id="p1">**</bpt>New Item<ept id="p1">**</ept> dialog box, select <bpt id="p2">**</bpt>Interface<ept id="p2">**</ept>, and then enter a name for the interface.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>新しい項目<ept id="p1">**</ept>ダイアログ ボックスで、<bpt id="p2">**</bpt>インターフェイス<ept id="p2">**</ept>を選択してからインターフェイスの名前を入力します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="400">
          <source>Click <bpt id="p1">**</bpt>Add<ept id="p1">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>追加<ept id="p1">**</ept> をクリックします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="401">
          <source>When you add the <bpt id="p1">**</bpt>implements<ept id="p1">**</ept> keyword on a class declaration, the class must declare the methods that are specified by the interface.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラス宣言に <bpt id="p1">**</bpt>implements<ept id="p1">**</ept> キーワードを追加すると、そのクラスは、インターフェイスによって指定されるメソッドを宣言する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="402">
          <source>A class declaration can implement multiple interfaces.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラス宣言では、複数のインターフェイスを実装することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="403">
          <source>Just list the interfaces after the single occurrence of the <bpt id="p1">**</bpt>implements<ept id="p1">**</ept> keyword, and separate the interface names by using commas.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>implements<ept id="p1">**</ept> キーワードの単一の発生後にインターフェイスを一覧表示し、インターフェイス名をコンマで区切ります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="404">
          <source>All interface methods that a class implements must be explicitly declared as <bpt id="p1">**</bpt>public<ept id="p1">**</ept> by using the <bpt id="p2">**</bpt>public<ept id="p2">**</ept> keyword in the class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラスで実装するすべてのインターフェイス メソッドはクラスの<bpt id="p1">**</bpt>パブリック<ept id="p1">**</ept>を使用して<bpt id="p2">**</bpt>パブリック<ept id="p2">**</ept>キーワードを明示的に宣言する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="405">
          <source>A class that implements an interface must also be declared as <bpt id="p1">**</bpt>public<ept id="p1">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">インターフェイスを実装するクラスも<bpt id="p1">**</bpt>パブリック<ept id="p1">**</ept>として宣言する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="406">
          <source>An interface can extend another interface by using the <bpt id="p1">**</bpt>extends<ept id="p1">**</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">インターフェイスを<bpt id="p1">**</bpt>拡張<ept id="p1">**</ept>キーワードを使用して別のインターフェイスに拡張できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="407">
          <source>However, an interface can't extend more than one interface.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、インターフェイスは、複数のインターフェイスを拡張することはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="408">
          <source>Interface example</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">インターフェイスの例</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="409">
          <source>In the following example, an <bpt id="p1">**</bpt>Automobile<ept id="p1">**</ept> class implements an <bpt id="p2">**</bpt>IDrivable<ept id="p2">**</ept> interface.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の例では、<bpt id="p1">**</bpt>Automobile<ept id="p1">**</ept> クラスは <bpt id="p2">**</bpt>IDrivable<ept id="p2">**</ept> インターフェイスを実装しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="410">
          <source>The <bpt id="p1">**</bpt>is<ept id="p1">**</ept> keyword is supported and lets you test whether a class implements an interface.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>is<ept id="p1">**</ept> キーワードはサポートされており、クラスがインターフェイスを実装するかどうかをテストすることができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="411">
          <source>Class library overview</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラス ライブラリの概要</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="412">
          <source>There are two kinds of classes: <bpt id="p1">*</bpt>application classes<ept id="p1">*</ept> and <bpt id="p2">*</bpt>system classes<ept id="p2">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">*</bpt>アプリケーション クラス<ept id="p1">*</ept>および<bpt id="p2">*</bpt>システム クラス<ept id="p2">*</ept>の、2 種類のクラスがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="413">
          <source><bpt id="p1">**</bpt>Application classes<ept id="p1">**</ept> – These classes are implemented in X++.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>アプリケーション クラス<ept id="p1">**</ept> - これらのクラスは X++ で実装されています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="414">
          <source>They are available in the <bpt id="p1">**</bpt>Classes<ept id="p1">**</ept> node in Application Explorer.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これらはアプリケーション エクスプローラーの <bpt id="p1">**</bpt>Classes<ept id="p1">**</ept> ノードで使用できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="415">
          <source><bpt id="p1">**</bpt>System classes<ept id="p1">**</ept> – These classes are sometimes known as <bpt id="p2">*</bpt>kernel classes<ept id="p2">*</ept> and are implemented in C++.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>システム クラス<ept id="p1">**</ept> – これらのクラスは <bpt id="p2">*</bpt>カーネル クラス<ept id="p2">*</ept> としても知られており、C++ では実装されています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="416">
          <source>They are listed under the <bpt id="p1">**</bpt>System Documentation<ept id="p1">**</ept> <ph id="ph1">&amp;gt;</ph> <bpt id="p2">**</bpt>Classes<ept id="p2">**</ept> node in Application Explorer.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">アプリケーション エクスプローラーの <bpt id="p1">**</bpt>System Documentation<ept id="p1">**</ept> <ph id="ph1">&amp;gt;</ph> <bpt id="p2">**</bpt>Classes<ept id="p2">**</ept> ノードの下に一覧表示されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="417">
          <source>However, the source code for these classes isn't available.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、これらのクラスのソース コードは使用できません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="418">
          <source>For a list of these classes, see <bpt id="p1">[</bpt>API, class, and table reference<ept id="p1">](api-reference.md)</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これらのクラスの一覧については、<bpt id="p1">[</bpt>API、クラス、およびテーブルの参照<ept id="p1">](api-reference.md)</ept> を参照してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="419">
          <source>Substituting application classes for system classes</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">システム クラス用のアプリケーション クラスの置き換え</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="420">
          <source>You should call the <bpt id="p1">*</bpt>substitute application classes<ept id="p1">*</ept> instead of the system classes that they extend.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">拡張するシステム クラスの代わりに <bpt id="p1">*</bpt>アプリケーション クラスの置き換え<ept id="p1">*</ept> を呼び出す必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="421">
          <source>In Application Explorer, under <bpt id="p1">**</bpt>System Documentation<ept id="p1">**</ept> <ph id="ph1">&amp;gt;</ph> <bpt id="p2">**</bpt>Classes<ept id="p2">**</ept>, several kernel or system classes have names that begin with a lowercase <bpt id="p3">*</bpt>x<ept id="p3">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">アプリケーション エクスプローラーの<bpt id="p1">**</bpt>システムのドキュメント<ept id="p1">**</ept> <ph id="ph1">&amp;gt;</ph> <bpt id="p2">**</bpt>クラス<ept id="p2">**</ept>で、いくつかのカーネルまたはシステム クラスの名前は小文字 <bpt id="p3">*</bpt>x<ept id="p3">*</ept> で始まります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="422">
          <source>These classes are known as <bpt id="p1">*</bpt>x-system classes<ept id="p1">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これらのクラスは、<bpt id="p1">*</bpt>x-system classes<ept id="p1">*</ept> とも呼ばれています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="423">
          <source>Examples of these system classes are <bpt id="p1">**</bpt>xApplication<ept id="p1">**</ept> and <bpt id="p2">**</bpt>xVersionControl<ept id="p2">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これらのシステム クラスの例には、<bpt id="p1">**</bpt>xApplication<ept id="p1">**</ept> および <bpt id="p2">**</bpt>xVersionControl<ept id="p2">**</ept> が存在します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="424">
          <source>Some of these classes are extended by application classes.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これらのクラスのいくつかは、アプリケーション クラスによって拡張されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="425">
          <source>For example, the <bpt id="p1">**</bpt>Application<ept id="p1">**</ept> class extends the <bpt id="p2">**</bpt>xApplication<ept id="p2">**</ept> system class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">たとえば、<bpt id="p1">**</bpt>アプリケーション<ept id="p1">**</ept>クラスは <bpt id="p2">**</bpt>xApplication<ept id="p2">**</ept> システム クラスを拡張します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="426">
          <source>The classes that derive from x-system classes are known as substitute application classes.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X システム クラスから派生するクラスは、アプリケーション クラスの代用として知られています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="427">
          <source>In Application Explorer, under the <bpt id="p1">**</bpt>Classes<ept id="p1">**</ept> node, the icon next to the substitute application classes differs from the standard icon.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">アプリケーション エクスプローラーの<bpt id="p1">**</bpt>クラス<ept id="p1">**</ept> ノードで、代替アプリケーション クラスの横にあるアイコンは標準のアイコンと異なります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="428">
          <source>x-system classes</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">x システム クラス</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="429">
          <source>Some of the substitute application classes are associated with a special global variable that represents an instance of the class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">代替アプリケーション クラスの一部は、クラスのインスタンスを表す特殊なグローバル変数に関連付けられます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="430">
          <source>For example, the <bpt id="p1">**</bpt>appl<ept id="p1">**</ept> variable references a pre-instantiated object from the <bpt id="p2">**</bpt>Application<ept id="p2">**</ept> class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">たとえば、<bpt id="p1">**</bpt>appl<ept id="p1">**</ept> 変数は、<bpt id="p2">**</bpt>アプリケーション<ept id="p2">**</ept>クラスから事前にインスタンス化されたオブジェクトを参照します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="431">
          <source>The advantage of the <bpt id="p1">**</bpt>appl<ept id="p1">**</ept> variable is that the system maintains the object throughout the scope of your session.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>appl<ept id="p1">**</ept> 変数の利点は、セッションの範囲全体にわたってシステムがオブジェクトを保持することです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="432">
          <source>Your code would be less efficient if it repeatedly used the <bpt id="p1">**</bpt>new Application()<ept id="p1">**</ept> syntax to obtain an instance of the <bpt id="p2">**</bpt>Application<ept id="p2">**</ept> class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p2">**</bpt>Application<ept id="p2">**</ept> クラスのインスタンスを取得するために <bpt id="p1">**</bpt>new Application()<ept id="p1">**</ept> 構文を繰り返し使用した場合、コードの効率が低下します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="433">
          <source>You should not use the <bpt id="p1">**</bpt>xApplication<ept id="p1">**</ept> system class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>xApplication<ept id="p1">**</ept> システム クラスは使用しないでください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="434">
          <source>Instead, use the <bpt id="p1">**</bpt>Application<ept id="p1">**</ept> substitute application class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">代わりに、<bpt id="p1">**</bpt>アプリケーション<ept id="p1">**</ept>の代替アプリケーション クラスを使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="435">
          <source>You can reference the static members of the <bpt id="p1">**</bpt>Application<ept id="p1">**</ept> class by using the following standard syntax: <bpt id="p2">**</bpt>Application::checkForNewBatchJobs()<ept id="p2">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">標準構文 <bpt id="p2">**</bpt>Application::checkForNewBatchJobs()<ept id="p2">**</ept> を使用することにより、<bpt id="p1">**</bpt>アプリケーション<ept id="p1">**</ept> クラスの静的メンバーを参照することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="436">
          <source>However, to reference the instance members of the <bpt id="p1">**</bpt>Application<ept id="p1">**</ept> class, you should use that class's <bpt id="p2">**</bpt>appl<ept id="p2">**</ept> variable, if it exists.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、<bpt id="p1">**</bpt>アプリケーション<ept id="p1">**</ept>クラスのインスタンス メンバーを参照するには、そのクラスの <bpt id="p2">**</bpt>appl<ept id="p2">**</ept> 変数 (存在する場合) を使用する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="437">
          <source>This pattern applies to most of the x-system classes.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このパターンは、ほとんどの x システム クラスに適用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="438">
          <source>The <bpt id="p1">**</bpt>Session<ept id="p1">**</ept> substitute application class is one exception, because there is no special global variable for <bpt id="p2">**</bpt>Session<ept id="p2">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>セッション<ept id="p1">**</ept> 代替アプリケーション クラスは、<bpt id="p2">**</bpt>セッション<ept id="p2">**</ept> の特殊なグローバル変数がないため 1 つの例外です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="439">
          <source>The following table lists the x-system classes that have a corresponding substitute application class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルは、対応するアプリケーション クラスの代用を持つ x システム クラスの一覧です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="440">
          <source>The special global variables are also shown for those classes that have one.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">特殊なグローバル変数は、それらを持つクラスに対しても表示されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="441">
          <source>Application class</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">アプリケーション クラス</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="442">
          <source>x-system class</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">x システム クラス</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="443">
          <source>Global variable</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">グローバル変数</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="444">
          <source>Args</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">引数</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="445">
          <source>xArgs</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">xArgs</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="446">
          <source>Not applicable</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">該当なし</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="447">
          <source>Application</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">申請</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="448">
          <source>xApplication</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">xApplication</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="449">
          <source><bpt id="p1">**</bpt>appl<ept id="p1">**</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>appl<ept id="p1">**</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="450">
          <source>ClassFactory</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ClassFactory</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="451">
          <source>xClassFactory</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">xClassFactory</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="452">
          <source><bpt id="p1">**</bpt>classFactory<ept id="p1">**</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>classFactory<ept id="p1">**</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="453">
          <source>Company</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">法人</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="454">
          <source>xCompany</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">xCompany</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="455">
          <source><bpt id="p1">**</bpt>appl.company<ept id="p1">**</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>appl.company<ept id="p1">**</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="456">
          <source>Global</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">グローバル</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="457">
          <source>xGlobal</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">xGlobal</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="458">
          <source>Not applicable</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">該当なし</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="459">
          <source>Info</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">情報</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="460">
          <source>xInfo</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">xInfo</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="461">
          <source><bpt id="p1">**</bpt>Infolog<ept id="p1">**</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>情報ログ<ept id="p1">**</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="462">
          <source>MenuFunction</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">MenuFunction</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="463">
          <source>xMenuFunction</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">xMenuFunction</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="464">
          <source>Not applicable</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">該当なし</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="465">
          <source>Session</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">セッション</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="466">
          <source>xSession</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">xSession</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="467">
          <source>Not applicable</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">該当なし</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="468">
          <source>VersionControl</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">VersionControl</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="469">
          <source>xVersionControl</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">xVersionControl</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="470">
          <source><bpt id="p1">**</bpt>versionControl<ept id="p1">**</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>versionControl<ept id="p1">**</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="471">
          <source>Example of x-system classes</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">x システム クラスの例</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="472">
          <source>The following example shows the syntax for using several special variables that reference instances of the substitute application classes.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の例は、代替アプリケーション クラスのインスタンスを参照するいくつかの特殊な変数を使用するための構文を示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="473">
          <source>Running startup commands</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">起動コマンドの実行</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="474">
          <source>You use the <bpt id="p1">**</bpt>SysStartupCmd<ept id="p1">**</ept> class framework to run commands at startup.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">起動時にコマンドを実行するには、<bpt id="p1">**</bpt>SysStartupCmd<ept id="p1">**</ept> クラス フレームワークを使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="475">
          <source>When Finance and Operations starts, calls are made to the <bpt id="p1">**</bpt>startup<ept id="p1">**</ept> methods on the application-substituted kernel classes <bpt id="p2">**</bpt>Application<ept id="p2">**</ept> (<bpt id="p3">**</bpt>Application.startup<ept id="p3">**</ept>) and <bpt id="p4">**</bpt>Info<ept id="p4">**</ept> (<bpt id="p5">**</bpt>Info.startup<ept id="p5">**</ept>).</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Finance and Operations の起動時に、アプリケーション代替カーネル クラスである <bpt id="p2">**</bpt>Application<ept id="p2">**</ept> (<bpt id="p3">**</bpt>Application.startup<ept id="p3">**</ept>) および <bpt id="p4">**</bpt>Info<ept id="p4">**</ept> (<bpt id="p5">**</bpt>Info.startup<ept id="p5">**</ept>) の <bpt id="p1">**</bpt>*startup<ept id="p1">**</ept> メソッドへの呼び出しが行われます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="476">
          <source>The <bpt id="p1">**</bpt>startup<ept id="p1">**</ept> methods are used for vital system and version-specific calls, and you must never directly modify these methods.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>startup<ept id="p1">**</ept> メソッドは必須システムおよびバージョン固有の呼び出しで使用されるものであり、直接変更することはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="477">
          <source>Instead, use the <bpt id="p1">**</bpt>SysStartupCmd<ept id="p1">**</ept> framework.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">代わりに、<bpt id="p1">**</bpt>SysStartupCmd<ept id="p1">**</ept> フレームワークを使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="478">
          <source>Serious issues can occur if the SYS layer versions of the <bpt id="p1">**</bpt>startup<ept id="p1">**</ept> methods aren't called.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">SYS レイヤ バージョンの <bpt id="p1">**</bpt>startup<ept id="p1">**</ept> メソッドが呼び出されなかった場合、深刻な問題が生じる可能性があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="479">
          <source>The following example shows the order that calls are run in when Finance and Operations starts.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の例は、Finance and Operations の起動時に呼び出しが実行される順序を示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="480">
          <source>Commands that are available when Finance and Operations starts</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Finance and Operations 起動時に使用できるコマンド</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="481">
          <source>The <bpt id="p1">**</bpt>SysStartupCmd.construct<ept id="p1">**</ept> method lists the commands that are available when Finance and Operations starts.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>SysStartupCmd.construct<ept id="p1">**</ept> メソッドは、Finance and Operations が起動したときに使用できるコマンドを一覧表示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="482">
          <source>Here are some of these commands:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これらのコマンド例を次に示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="483">
          <source>AutoRun</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">AutoRun</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="484">
          <source>AOTImport</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">AOTImport</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="485">
          <source>Synchronize</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">同期</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="486">
          <source>The following example shows how to run a new command when Finance and Operations starts.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の例は、Finance and Operations の起動時に新しいコマンドを実行する方法を示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="487">
          <source>First, a class that extends <bpt id="p1">&lt;strong&gt;</bpt>SysStartupCmd<ept id="p1">&lt;/strong&gt;</ept> is created.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">最初に、<bpt id="p1">&lt;strong&gt;</bpt>SysStartupCmd<ept id="p1">&lt;/strong&gt;</ept> を拡張するクラスが作成されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="488">
          <source>This new class performs your specific task.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この新しいクラスは特定のタスクを実行します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="489">
          <source>You then modify the construct method on <bpt id="p1">&lt;strong&gt;</bpt>SysStartupCmd<ept id="p1">&lt;/strong&gt;</ept> to call your class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次に、自分のクラスを呼び出すために、<bpt id="p1">&lt;strong&gt;</bpt>SysStartupCmd<ept id="p1">&lt;/strong&gt;</ept> の construct メソッドを変更します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="490">
          <source>In the Finance and Operations Configuration Utility, on the <bpt id="p1">&lt;strong&gt;</bpt>General<ept id="p1">&lt;/strong&gt;</ept> tab, in the <bpt id="p2">&lt;strong&gt;</bpt>Command to run at application startup<ept id="p2">&lt;/strong&gt;</ept> field, you can add commands that are run at startup.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Finance and Operations のコンフィギュレーション ユーティリティの<bpt id="p1">&lt;strong&gt;</bpt>一般<ept id="p1">&lt;/strong&gt;</ept>タブにある<bpt id="p2">&lt;strong&gt;</bpt>アプリケーション起動時に実行するコマンド<ept id="p2">&lt;/strong&gt;</ept> フィールドで、起動時に実行するコマンドを追加できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="491">
          <source>Alternatively, you can use the <bpt id="p1">&lt;strong&gt;</bpt>-startupcmd= <bpt id="p2">*</bpt>MyCommand<ept id="p2">&lt;/strong&gt;</ept><ept id="p1">*</ept> command-line parameter.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">または、<bpt id="p1">&lt;strong&gt;</bpt>-startupcmd= <bpt id="p2">*</bpt>MyCommand<ept id="p2">&lt;/strong&gt;</ept><ept id="p1">*</ept> コマンド ライン パラメーターを使用できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="492">
          <source>Batch processing classes</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">バッチ処理クラス</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="493">
          <source>You implement classes by using the batch processing system, and by extending the <bpt id="p1">**</bpt>RunBase<ept id="p1">**</ept> and <bpt id="p2">**</bpt>RunBaseBatch<ept id="p2">**</ept> classes.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラスを実装するには、バッチ処理システムを使用し、<bpt id="p1">**</bpt>RunBase<ept id="p1">**</ept> および <bpt id="p2">**</bpt>RunBaseBatch<ept id="p2">**</ept> クラスを拡張します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="494">
          <source>To remove the <bpt id="p1">**</bpt>Recurrence<ept id="p1">**</ept> button from the <bpt id="p2">**</bpt>Batch processing<ept id="p2">**</ept> dialog box, you use the <bpt id="p3">**</bpt>Args::parmEnum<ept id="p3">**</ept> method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p2">**</bpt>バッチ処理<ept id="p2">**</ept>ダイアログ ボックスから<bpt id="p1">**</bpt>繰り返し<ept id="p1">**</ept>ボタンを削除するには、<bpt id="p3">**</bpt>Args::parmEnum<ept id="p3">**</ept> メソッドを使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="495">
          <source>We recommend that you designate a class to run as a server-bound batch method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">サーバー バインド バッチ メソッドとして実行するクラスを指定することをお勧めします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="496">
          <source>Server-bound batch methods are more secure than batch methods that aren't server-bound for the following reasons:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">サーバー バインド バッチ メソッドは、以下の理由のため、サーバー バインドでないバッチ メソッドより安全です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="497">
          <source>The method is run by using the permissions of the user who submitted the method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このメソッドは、メソッドを送信したユーザーのアクセス許可を使用して実行されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="498">
          <source>The method can use only specific <bpt id="p1">**</bpt>Info<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Global<ept id="p2">**</ept> class methods to interact with the client that is processing it.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このメソッドは、特定の <bpt id="p1">**</bpt>情報<ept id="p1">**</ept> および <bpt id="p2">**</bpt>グローバル<ept id="p2">**</ept> クラス メソッドのみを使用して、それを処理しているクライアントと対話できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="499">
          <source>This restriction limits interaction with the client.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この制限により、クライアントとのやり取りが制限されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="500">
          <source>Enable a class to run as a server-bound batch method</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">サーバー バインド バッチ メソッドとして実行するクラスを有効化</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="501">
          <source>Create a class that extends the <bpt id="p1">**</bpt>RunBaseBatch<ept id="p1">**</ept> class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>RunBaseBatch<ept id="p1">**</ept> クラスを拡張するクラスを作成します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="502">
          <source>Override the <bpt id="p1">**</bpt>RunBaseBatch.runsImpersonated<ept id="p1">**</ept> method to return a value of <bpt id="p2">**</bpt>true<ept id="p2">**</ept>, as shown in the following example.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の例に示すように、<bpt id="p1">**</bpt>RunBaseBatch.runsImpersonated<ept id="p1">**</ept> メソッドをオーバーライドし、値 <bpt id="p2">**</bpt>true<ept id="p2">**</ept> を返します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="503">
          <source>Confirm that the class calls only the following <bpt id="p1">**</bpt>Info<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Global<ept id="p2">**</ept> class methods:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クラスが次の<bpt id="p1">**</bpt>情報<ept id="p1">**</ept>および<bpt id="p2">**</bpt>グローバル<ept id="p2">**</ept>クラスのメソッドのみを呼び出すことを確認します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="504">
          <source>add</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">追加</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="505">
          <source>Info.copy</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Info.copy</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="506">
          <source>Info.cut</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Info.cut</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="507">
          <source>Info.import</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Info.import</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="508">
          <source>Info.export</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Info.export</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="509">
          <source>Info.line</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Info.line</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="510">
          <source>Info.num</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Info.num</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="511">
          <source>Global::error</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Global::error</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="512">
          <source>Global::info</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Global::info</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="513">
          <source>Global::warning</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Global::warning</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="514">
          <source><bpt id="p1">**</bpt>Note:<ept id="p1">**</ept> The <bpt id="p2">**</bpt>Info.line<ept id="p2">**</ept> and <bpt id="p3">**</bpt>Info.num<ept id="p3">**</ept> methods are inherited from the <bpt id="p4">**</bpt>xInfo<ept id="p4">**</ept> class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>注記:<ept id="p1">**</ept> <bpt id="p2">**</bpt>Info.line<ept id="p2">**</ept> および <bpt id="p3">**</bpt>Info.num<ept id="p3">**</ept> メソッドは、<bpt id="p4">**</bpt>xInfo<ept id="p4">**</ept> クラスから継承されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="515">
          <source>Removing the Recurrence button from the batch processing dialog box</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">バッチ処理ダイアログ ボックスから定期的なアイテムを削除</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="516">
          <source>When you implement a class by using the batch processing system, you can remove the <bpt id="p1">**</bpt>Recurrence<ept id="p1">**</ept> button by calling the <bpt id="p2">**</bpt>Args.parmEnum<ept id="p2">**</ept> method and passing the <bpt id="p3">**</bpt>NoYes::Yes<ept id="p3">**</ept> system enumeration value.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">バッチ処理システムを使用してクラスを実装するときは、<bpt id="p2">**</bpt>Args.parmEnum<ept id="p2">**</ept> メソッドを呼び出し、<bpt id="p3">**</bpt>NoYes::Yes<ept id="p3">**</ept> システム列挙値を渡して、<bpt id="p1">**</bpt>再実行<ept id="p1">**</ept>ボタンを削除できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="517">
          <source>The <bpt id="p1">**</bpt>NoYes<ept id="p1">**</ept> system enumeration determines whether the <bpt id="p2">**</bpt>Recurrence<ept id="p2">**</ept> button is removed from the dialog box.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>NoYes<ept id="p1">**</ept> システム列挙は、<bpt id="p2">**</bpt>繰り返し<ept id="p2">**</ept> ボタンがダイアログ ボックスから削除されるかどうかを決定します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="518">
          <source>The default value is <bpt id="p1">**</bpt>NoYes::No<ept id="p1">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">既定値は <bpt id="p1">**</bpt>NoYes::No<ept id="p1">**</ept> です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="519">
          <source>In the following example, the <bpt id="p1">**</bpt>InventTransferMultiShip<ept id="p1">**</ept> class is implemented.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の例では、<bpt id="p1">**</bpt>InventTransferMultiShip<ept id="p1">**</ept> クラスが実装されています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="520">
          <source>The <bpt id="p1">**</bpt>BatchDialog::main<ept id="p1">**</ept> method creates the <bpt id="p2">**</bpt>Batch processing<ept id="p2">**</ept> dialog box.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>BatchDialog::main<ept id="p1">**</ept> メソッドは、<bpt id="p2">**</bpt>バッチ処理<ept id="p2">**</ept>ダイアログ ボックスを作成します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="521">
          <source>Image manipulation classes</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">イメージ操作クラス</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="522">
          <source>Two system classes let you to manipulate graphics and icons: <bpt id="p1">**</bpt>Image<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Imagelist<ept id="p2">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>Image<ept id="p1">**</ept> と <bpt id="p2">**</bpt>Imagelist<ept id="p2">**</ept> の 2 つのシステム クラスにより、グラフィックスとアイコンを操作できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="523">
          <source><bpt id="p1">**</bpt>Image<ept id="p1">**</ept> – This class lets you load, save, and manipulate individual images.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>Image<ept id="p1">**</ept> – このクラスでは、個々の画像の読み込み、保存、操作などができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="524">
          <source>For example, you can capture a screen and save it as an image, crop or rotate an image, or manipulate the color depth.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">たとえば、画面をキャプチャして画像として保存し、画像をトリミングまたは回転させる、または色深度を操作します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="525">
          <source><bpt id="p1">&lt;strong&gt;</bpt>Imagelist<ept id="p1">&lt;/strong&gt;</ept> – This class lets you work with a set of images that have common properties, such as the size and transparency color.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>Imagelist<ept id="p1">&lt;/strong&gt;</ept> - このクラスを使用すると、サイズや透明色などの一般的なプロパティを持つ一連の画像を操作できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="526">
          <source>You can view the image lists that are used in Finance and Operations in the <ph id="ph1">&lt;strong&gt;</ph>ImageListAppl<ph id="ph2">\_</ph><ph id="ph3">\&lt;</ph>/strong&gt;* application classes.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">&lt;strong&gt;</ph>ImageListAppl<ph id="ph2">\_</ph><ph id="ph3">\&lt;</ph>/strong&gt;* アプリケーション クラス の Finance and Operations で使用されるイメージ リストを表示できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="527">
          <source>Query object model</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クエリ オブジェクト モデル</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="528">
          <source>The query object model contains classes that are used to define and run a query.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クエリ オブジェクト モデルには、クエリの定義と実行に使用されるクラスが含まれています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="529">
          <source>The query objects are used to define the query data source, the fields that are returned, record ranges, and relations to child data sources.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クエリ オブジェクトは、クエリ データ ソース、返されるフィールド、レコード範囲、子データ ソースとの関係を定義するために使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="530">
          <source>The query classes are more visible when you create a dynamic query in code, but they are also used behind the scenes when you create a static query in Application Explorer.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">動的クエリをコードで作成すると、クエリ クラスの可視性が高まります。さらに、これらは、アプリケーション エクスプローラーで静的クエリを作成するときにもシーン裏で使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="531">
          <source>The following table describes the classes in the query object model.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルでは、クエリ オブジェクト モデルのクラスについて説明します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="532">
          <source>System class</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">システム クラス</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="533">
          <source>Description</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">説明</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="534">
          <source>QueryRun</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">QueryRun</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="535">
          <source>This class runs the query and fetches the data.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このクラスは、クエリを実行し、データをフェッチします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="536">
          <source>Query</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クエリ</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="537">
          <source>This class holds some properties, and has one or more related data sources.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このクラスはいくつかのプロパティを保持し、1 つ以上の関連するデータ ソースを持ちます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="538">
          <source>It's the top level of the query definition.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クエリの定義の最上位です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="539">
          <source>QueryBuildDataSource</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">QueryBuildDataSource</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="540">
          <source>This class defines access to a single data source in the query.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このクラスは、クエリ内の単一のデータ ソースへのアクセスを定義します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="541">
          <source>If there is more than one data source at the same level in a query, separate SQL statements are produced and are run sequentially.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クエリに同じレベルの 1 つ以上のデータ ソースある場合、独立した SQL ステートメントが生産され、順番に実行されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="542">
          <source>If one data source is a child of another data source, a join is created between the two data sources.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">データ ソースが別のデータ ソースの子である場合は、2 つのデータ ソース間に結合が作成されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="543">
          <source>QueryBuildFieldList</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">QueryBuildFieldList</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="544">
          <source>This class defines the fields that are returned from the database.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このクラスは、データベースから返されるフィールドを定義します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="545">
          <source>By default, the field list is dynamic, and all fields are returned from the data source table, map, or view.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">既定では、フィールド リストは動的であり、すべてのフィールドはデータ ソース テーブル、マップ、またはビューから戻されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="546">
          <source>Each data source has only one <bpt id="p1">**</bpt>QueryBuildFieldList<ept id="p1">**</ept> object.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">各データ ソースには、<bpt id="p1">**</bpt>QueryBuildFieldList<ept id="p1">**</ept> オブジェクトが 1 つだけあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="547">
          <source>This object contains information about all selected fields.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このオブジェクトには、選択したすべてのフィールドに関する情報が含まれます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="548">
          <source>You can specify aggregate functions, such as <bpt id="p1">**</bpt>SUM<ept id="p1">**</ept>, <bpt id="p2">**</bpt>COUNT<ept id="p2">**</ept>, and <bpt id="p3">**</bpt>AVG<ept id="p3">**</ept>, on the field list object.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">フィールド リスト オブジェクトで、<bpt id="p1">**</bpt>SUM<ept id="p1">**</ept>、<bpt id="p2">**</bpt>COUNT<ept id="p2">**</ept>、および <bpt id="p3">**</bpt>AVG<ept id="p3">**</ept> などの、集計関数を指定することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="549">
          <source>QueryBuildRange</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">QueryBuildRange</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="550">
          <source>This class defines a subset of records that is returned, based on a single field.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このクラスは、単一フィールドに基づいて、返されるレコードのサブセットを定義します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="551">
          <source>A range is translated into a <bpt id="p1">**</bpt>WHERE<ept id="p1">**</ept> clause in the query SQL statement.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">範囲は、クエリ SQL ステートメントの <bpt id="p1">**</bpt>WHERE<ept id="p1">**</ept> 句に変換されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="552">
          <source>If more than one field is used to limit the query (<bpt id="p1">**</bpt>WHERE<ept id="p1">**</ept> clause), the data source will contain more than one range.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クエリを制限するために 1 つ以上のフィールドが使用されている場合 (<bpt id="p1">**</bpt>WHERE<ept id="p1">**</ept>句)、データ ソースには 1 つ以上の範囲が含まれます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="553">
          <source>QueryBuildDynalink</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">QueryBuildDynalink</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="554">
          <source>This class contains information about a relation (limitation) to an external record.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このクラスには、外部レコードとの関係 (制限) に関する情報が含まれます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="555">
          <source>When the query is run, this information is converted to additional entries in the <bpt id="p1">**</bpt>WHERE<ept id="p1">**</ept> clause of the query SQL statement.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">クエリを実行すると、この情報は、クエリ SQL ステートメントの <bpt id="p1">**</bpt>WHERE<ept id="p1">**</ept> 句内で追加のエントリに変換されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="556">
          <source>This class can exist only on the parent data source of a query.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このクラスは、クエリの親データ ソースにのみ存在できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="557">
          <source>Forms use the function when two data sources are synchronized.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">フォームは、2 つのデータ ソースが同期されるときにこの機能を使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="558">
          <source>The child data source will then contain one or more DLLs to the parent data source.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">子データ ソースは、親データ ソース に対する 1 つ以上の DLL を格納します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="559">
          <source>The function is used even if the two data sources are put in two different forms but are still synchronized.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この関数は、2 つのデータソースが 2 つの異なる形式になっていて、まだ同期されている場合でも使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="560">
          <source>QueryBuildLink</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">QueryBuildLink</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="561">
          <source>This class specifies the relation between the two data sources in the join.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このクラスは、結合に 2 つのデータ ソースの間の関係を指定します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="562">
          <source>This class can exist only on a child data source.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このクラスは、子データ ソースにのみ存在できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="563">
          <source>System classes overview</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">システム クラスの概要</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="564">
          <source>System classes (or kernel classes) are implemented in C++.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">システム クラス (またはカーネル クラス) は C++ で実装されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="565">
          <source>The source for these classes isn't available.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これらのクラスのソースは使用できません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="566">
          <source>A system class can have the following characteristics:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">システム クラスは、次の特性を持つことができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="567">
          <source>Static methods (or class methods)</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">静的メソッド (またはクラス メソッド)</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="568">
          <source>Dynamic methods</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">動的メソッド</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="569">
          <source>Properties – These properties are member functions that are used to set properties.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">プロパティ - これらのプロパティは、プロパティを設定するために使用されるメンバー関数です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="570">
          <source>An example is <bpt id="p1">**</bpt>LeftMargin<ept id="p1">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">たとえば <bpt id="p1">**</bpt>LeftMargin<ept id="p1">**</ept> です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="571">
          <source>You can't override system class methods.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">システム クラスのメソッドをオーバーライドすることはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="572">
          <source>It isn't our intention that you will use the system classes to design your application objects from scratch.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">最初からアプリケーション オブジェクトをデザインするためにシステム クラスを使用することを意図していません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="573">
          <source>Instead, use them to extend or modify the default functionality in Application Explorer.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">代わりに、アプリケーション エクスプローラーで既存の機能を拡張または変更するために使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="574">
          <source>For example, you can dynamically add extra information to an existing report.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">たとえば、既存のレポートに追加情報を動的に追加することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="575">
          <source>Alternatively, you can change the options that are available on a page, based on the user's selection on a previous page.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">または、前のページでのユーザーの選択に基づいて、ページ上で使用可能なオプションを変更することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="576">
          <source>Collection classes</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コレクション クラス</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="577">
          <source>The <bpt id="p1">*</bpt>collection classes<ept id="p1">*</ept> let you create lists, sets, structs, maps, and arrays.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">*</bpt>コレクション クラス<ept id="p1">*</ept>を使用すると、リスト、セット、構造体、マップ、および配列を作成できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="578">
          <source>Application object classes</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">アプリケーション オブジェクト クラス</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="579">
          <source>These system classes hold functions that are activated whenever you use Application Explorer to create your application.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これらのシステム クラスは、アプリケーション エクスプローラーを使用してアプリケーションを作成するたびにアクティブ化される関数を保持します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="580">
          <source>For example, the system uses the <bpt id="p1">**</bpt>FormDesign<ept id="p1">**</ept> class when you define the layout of your form in the <bpt id="p2">**</bpt>Designs<ept id="p2">**</ept> node in Application Explorer.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">たとえば、システムは、アプリケーション エクスプローラーの<bpt id="p2">**</bpt>設計<ept id="p2">**</ept>ノードでフォームのレイアウトを定義する時、<bpt id="p1">**</bpt>FormDesign<ept id="p1">**</ept> クラスを使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="581">
          <source>These classes also let you to create and modify application objects.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これらのクラスを使用すると、アプリケーション オブジェクトを作成したり変更したりすることもできます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="582">
          <source>Integration classes</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">統合クラス</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="583">
          <source>The integration with the environment is typically implemented by classes.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">環境との統合は、通常、クラスによって実装されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="584">
          <source>Here are some examples of the classes in this category:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このカテゴリ内のクラスの例を次に示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="585">
          <source><bpt id="p1">**</bpt>COM<ept id="p1">**</ept> – The call of methods on COM objects.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>COM<ept id="p1">**</ept> - COM オブジェクトのメソッドの呼び出しです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="586">
          <source><bpt id="p1">**</bpt>DLL<ept id="p1">**</ept> – The call of Microsoft Windows DLL functions.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>DLL<ept id="p1">**</ept> – Microsoft Windows DLL 関数の呼び出し。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="587">
          <source><bpt id="p1">**</bpt>IO<ept id="p1">**</ept> – Read and write external files.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>IO<ept id="p1">**</ept> – 外部ファイルの読み取りと書き込みを行います。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="588">
          <source><bpt id="p1">**</bpt>ODBCConnection<ept id="p1">**</ept> – An Open Database Connectivity (ODBC) interface to a foreign database.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>ODBCConnection<ept id="p1">**</ept> – 外部データベースへの Open Database Connectivity (ODBC) インターフェイス。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="589">
          <source>Event terminology and keywords</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">イベントの用語およびキーワード</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="590">
          <source>You can use the event design pattern to make your code more modular and reusable.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">イベント設計パターンを使用すると、コードをさらにモジュール化して再使用可能にすることができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="591">
          <source>The term <bpt id="p1">*</bpt>event<ept id="p1">*</ept> is a metaphor that explains how delegates are used.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">*</bpt>イベント<ept id="p1">*</ept> という用語は、デリゲートの使用方法を説明するメタファです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="592">
          <source>When something important occurs during a program run, other modules might have to process the occurrence.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">プログラム実行中に何か重要なことが発生したときは、他のモジュールがその発生を処理することが必要な場合があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="593">
          <source>These important occurrences are known as <bpt id="p1">*</bpt>events<ept id="p1">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これらの重要な出来事は<bpt id="p1">*</bpt>イベント<ept id="p1">*</ept>と呼ばれています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="594">
          <source>When an event occurs, the program tells its notifier for the event that the notifier must send notifications about the event.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">イベントが発生すると、プログラムは、Notifier がイベントに関する通知を送信する必要があることを、そのイベントの Notifier に指示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="595">
          <source>A notification must be sent to all the event handlers that are subscribers of the notifier.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">通知は、通知のサブスクライバーであるすべてのイベント ハンドラーに送信する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="596">
          <source>When the program tells its notifier to send the notifications, we call that process <bpt id="p1">*</bpt>raising<ept id="p1">*</ept> an event.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">プログラムがその通知機能に通知を送信するように指示するとき、そのプロセスをイベントの <bpt id="p1">*</bpt>発生<ept id="p1">*</ept> と呼んでいます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="597">
          <source>The following table shows the terms that are used to describe the event metaphor.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルは、イベント メタファを説明するために使用される用語を示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="598">
          <source>Term</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">期間</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="599">
          <source>Description</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">説明</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="600">
          <source>Event</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">イベント</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="601">
          <source>An important occurrence in a program module where additional modules must process the occurrence.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">追加モジュールは発生を処理するプログラム モジュールで重要な発生です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="602">
          <source>Notifier</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">通知機能</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="603">
          <source>The program element that sends information about the event to all the event handlers that are subscribed to the notifier.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">通知機能に登録されているすべてのイベント ハンドラーに、イベントに関する情報を送信するプログラム要素。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="604">
          <source>Subscriber</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">サブスクライバー</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="605">
          <source>The program functions or methods that are subscribed to an event notifier.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">イベント通知機能を登録しているプログラム機能またはメソッド。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="606">
          <source>Event handler</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">イベント ハンドラー</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="607">
          <source>The methods that subscribe to an event notifier.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">イベント通知を購読するメソッド。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="608">
          <source>Only the appropriate kind of methods can be event handlers.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">適切な種類のメソッドのみ、イベント ハンドラーになることができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="609">
          <source>Keywords that are used for programming that uses delegates</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">デリゲートを使用するプログラミングに使用されるキーワード</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="610">
          <source>The following table shows the keywords that describe the use of delegates.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルに、デリゲートの使用方法を説明するキーワードを示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="611">
          <source>Keyword or term</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">キーワードや用語</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="612">
          <source>Code</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">区分</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="613">
          <source>Description</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">説明</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="614">
          <source>delegate</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">デリゲート</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="615">
          <source>delegate myDelegate(str <ph id="ph1">\_</ph>information) <ph id="ph2">{}</ph></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">delegate myDelegate(str <ph id="ph1">\_</ph>information) <ph id="ph2">{}</ph></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="616">
          <source>The code shows what the delegate looks like in the method editor in the Microsoft MorphX client.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このコードは、Microsoft MorphX クライアントのメソッド エディターでのデリゲートの外観を示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="617">
          <source>Because the return type is always <bpt id="p1">**</bpt>void<ept id="p1">**</ept>, it isn't mentioned in the syntax.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">戻り値の型は常に<bpt id="p1">**</bpt>無効<ept id="p1">**</ept>なので、構文には示されていません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="618">
          <source>No code is allowed inside the braces (<ph id="ph1">{}</ph>).</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">かっこ (<ph id="ph1">{}</ph>) 内にコードは使用できません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="619">
          <source>eventHandler</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">eventHandler</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="620">
          <source>myClassInstance.myDelegate += eventHandler(otherClass.myInstanceMethod);</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">myClassInstance.myDelegate += eventHandler(otherClass.myInstanceMethod);</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="621">
          <source>Although the syntax of the <bpt id="p1">**</bpt>eventHandler<ept id="p1">**</ept> keyword might give the impression that <bpt id="p2">**</bpt>eventHandler<ept id="p2">**</ept> is an X++ function, it isn't a function.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>eventHandler<ept id="p1">**</ept> キーワードの構文は <bpt id="p2">**</bpt>eventHandler<ept id="p2">**</ept> X++ 関数であるという印象を与えますが、それは関数ではありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="622">
          <source>The <bpt id="p1">**</bpt>eventHandler<ept id="p1">**</ept> keyword tells the compiler that a method is being subscribed to a delegate.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>eventHandler<ept id="p1">**</ept> キーワードは、メソッドがデリゲートにサブスクライブされることをコンパイラに伝えます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="623">
          <source>Subscribe or add a method to a delegate</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">デリゲートにメソッドをサブスクライブまたは追加</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="624">
          <source>myClassInstance.myDelegate += eventHandler(OtherClass::aStaticMethod);</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">myClassInstance.myDelegate += eventHandler(OtherClass::aStaticMethod);</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="625">
          <source>In the code, the static method <bpt id="p1">**</bpt>OtherClass::aStaticMethod<ept id="p1">**</ept> becomes subscribed to the delegate.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コードでは、静的メソッド <bpt id="p1">**</bpt>OtherClass::aStaticMethod<ept id="p1">**</ept> がデリゲートにサブスクライブされます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="626">
          <source>Call a delegate</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">デリゲートの呼び出し</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="627">
          <source>myClassInstance.myDelegate("Hello");</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">myClassInstance.myDelegate("Hello");</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="628">
          <source>This call to the delegate prompts the delegate to call each method that is subscribed to the delegate.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">デリゲートへのこの呼び出しは、デリゲートにサブスクライブしている各メソッドを呼び出すようにデリゲートに要求します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="629">
          <source>The subscribed methods are called in the same order in which they were added to the delegate.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">サブスクライブされたメソッドは、デリゲートに追加されたのと同じ順序で呼び出されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="630">
          <source>One subscribed method must be completed before the delegate calls the next method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">1 つのサブスクライブされたメソッドは、そのデリゲードが次のメソッドを呼び出す前に完了される必要があります。</target></trans-unit>
      </group>
    </body>
  </file>
</xliff>