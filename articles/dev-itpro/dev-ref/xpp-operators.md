<?xml version="1.0" encoding="UTF-8"?>
<xliff xmlns:logoport="urn:logoport:xliffeditor:xliff-extras:1.0" xmlns:tilt="urn:logoport:xliffeditor:tilt-non-translatables:1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-US" original="xpp-operators.md" target-language="ja-JP">
    <header>
      <tool tool-company="Microsoft" tool-version="1.0-7889195" tool-name="mdxliff" tool-id="mdxliff"/>
      <xliffext:skl_file_name>xpp-operators.3d83e8.3a16408380d40248478636d88c9f172e4a3a62d0.skl</xliffext:skl_file_name>
      <xliffext:version>1.2</xliffext:version>
      <xliffext:ms.openlocfilehash>3a16408380d40248478636d88c9f172e4a3a62d0</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit>9d4c7edd0ae2053c37c7d81cdd180b16bf3a9d3b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff>05/15/2019</xliffext:ms.lasthandoff>
      <xliffext:ms.openlocfilepath>articles\dev-itpro\dev-ref\xpp-operators.md</xliffext:ms.openlocfilepath>
    </header>
    <body>
      <group extype="content" id="content">
        <trans-unit xml:space="preserve" translate="yes" id="101" restype="x-metadata">
          <source>X++ operators</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ 演算子</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="102" restype="x-metadata">
          <source>This topic describes the operators supported in X++.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このトピックでは、X++ でサポートされている演算子について説明します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="103">
          <source>X++ operators</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ 演算子</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="104">
          <source>This topic describes the operators supported in X++.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このトピックでは、X++ でサポートされている演算子について説明します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="105">
          <source>Assignment operators</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">代入演算子</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="106">
          <source>An assignment changes the value of a variable or field.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">割り当ては、変数やフィールドの値を変更します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="107">
          <source>The following table shows the X++ assignment operators.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルは、X++ の代入演算子を示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="108">
          <source>There is no difference between prefix and postfix operators.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">接頭辞と接尾辞の演算子には違いはありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="109">
          <source>Operator</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">オペレーター</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="110">
          <source>Description</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">説明</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="111">
          <source>Assign the expression on the right of the equal sign to the variable on the left.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">等号の右側の式を左側の変数に割り当てます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="112">
          <source>Assign the current variable value plus the expression on the right to the variable on the left.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">現在の変数の値に右側の式を足したものを左側の変数に割り当てます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="113">
          <source>Increment the variable by 1.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">変数を 1 ずつ増加します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="114">
          <source>Assign the current variable value minus the expression on the right to the variable on the left.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">現在の変数の値から右側の式を差し引いたものを左側の変数に割り当てます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="115">
          <source>Decrement the variable by 1.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">変数を 1 ずつ減分します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="116">
          <source>Code examples for assignment operators</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">代入演算子のコード例</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="117">
          <source>Arithmetic operators</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">算術演算子</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="118">
          <source>You use arithmetic operators to perform numeric calculations.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">算術演算子を使用して、数値計算を実行します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="119">
          <source>Most of the operators are binary and take two operands.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">演算子のほとんどはバイナリであり、2 つのオペランドを取ります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="120">
          <source>However, the <bpt id="p1">**</bpt>not<ept id="p1">**</ept> (<bpt id="p2">**</bpt><ph id="ph1">~</ph><ept id="p2">**</ept>) operator is unary and takes only one operand.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、<bpt id="p1">**</bpt>not<ept id="p1">**</ept> (<bpt id="p2">**</bpt><ph id="ph1">~</ph><ept id="p2">**</ept>) 演算子は単項で 1 つのオペランドのみを取ります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="121">
          <source>Syntax for binary operators: <bpt id="p1">*</bpt>expression1<ept id="p1">*</ept> <bpt id="p2">*</bpt>ArithmeticOperator<ept id="p2">*</ept> <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept> Syntax for unary operators: <bpt id="p4">*</bpt>ArithmeticOperator<ept id="p4">*</ept> <bpt id="p5">*</bpt>expression1<ept id="p5">*</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">バイナリ演算子の構文: <bpt id="p1">*</bpt>expression1<ept id="p1">*</ept> <bpt id="p2">*</bpt>ArithmeticOperator<ept id="p2">*</ept> <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept> 単項演算子の構文: <bpt id="p4">*</bpt>ArithmeticOperator<ept id="p4">*</ept> <bpt id="p5">*</bpt>expression1<ept id="p5">*</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="122">
          <source>Operator</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">オペレーター</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="123">
          <source>Description</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">説明</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="124">
          <source>The <bpt id="p1">**</bpt>left shift<ept id="p1">**</ept> operator performs <bpt id="p2">*</bpt>expression2<ept id="p2">*</ept> left shift (multiplication by 2) on <bpt id="p3">*</bpt>expression1<ept id="p3">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>left shift<ept id="p1">**</ept> 演算子は、<bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> で <bpt id="p2">*</bpt>expression2<ept id="p2">*</ept> の左シフト (2 により乗算) を実行します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="125">
          <source>The <bpt id="p1">**</bpt>right shift<ept id="p1">**</ept> operator performs <bpt id="p2">*</bpt>expression2<ept id="p2">*</ept> right shift (division by 2) on <bpt id="p3">*</bpt>expression1<ept id="p3">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>right shift<ept id="p1">**</ept> 演算子は、<bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> で <bpt id="p2">*</bpt>expression2<ept id="p2">*</ept> の右シフト (2 で除算) を実行します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="126">
          <source>The <bpt id="p1">**</bpt>multiply<ept id="p1">**</ept> operator multiplies <bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> by <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>multiply<ept id="p1">**</ept> 演算子は、<bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> を <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept> で乗算します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="127">
          <source>The <bpt id="p1">**</bpt>divide<ept id="p1">**</ept> operator divides <bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> by <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>divide<ept id="p1">**</ept> 演算子は、<bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> を <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept> で除算します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="128">
          <source>DIV</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">DIV</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="129">
          <source>The <bpt id="p1">**</bpt>integer division<ept id="p1">**</ept> operator performs an integer division of <bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> by <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>integer division<ept id="p1">**</ept> 演算子は、<bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> の整数除算を <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept> で実行します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="130">
          <source>MOD</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">MOD</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="131">
          <source>The <bpt id="p1">**</bpt>integer remainder<ept id="p1">**</ept> operator returns the remainder of an integer division of <bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> by <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>integer remainder<ept id="p1">**</ept> 演算子は、<bpt id="p3">*</bpt>expression2<ept id="p3">*</ept>による <bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> の整数除算の余りを返します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="132">
          <source>The <bpt id="p1">**</bpt>not<ept id="p1">**</ept> operator, or unary operator, performs a binary not operation.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>not<ept id="p1">**</ept> 演算子、つまり単項演算子は、操作ではなくバイナリを実行します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="133">
          <source>The <bpt id="p1">**</bpt>binary AND<ept id="p1">**</ept> operator performs a binary and operation on <bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> and <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>binary AND<ept id="p1">**</ept> 演算子は、<bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> および <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept> でバイナリおよび演算を実行します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="134">
          <source>The <bpt id="p1">**</bpt>binary XOR<ept id="p1">**</ept> operator performs a binary XOR-operation on <bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> and <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>binary XOR<ept id="p1">**</ept> 演算子は、<bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> および <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept> でバイナリ XOR 演算を実行します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="135">
          <source>&amp;#124;</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">&amp;#124;</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="136">
          <source>The <bpt id="p1">**</bpt>binary OR<ept id="p1">**</ept> operator performs a binary or operation on <bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> and <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>binary OR<ept id="p1">**</ept> 演算子は、<bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> および <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept> でバイナリまたは演算を実行します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="137">
          <source>The <bpt id="p1">**</bpt>plus<ept id="p1">**</ept> operator adds <bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> to <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>plus<ept id="p1">**</ept> 演算子は <bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> を <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept> に追加します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="138">
          <source>The <bpt id="p1">**</bpt>minus<ept id="p1">**</ept> operator subtracts <bpt id="p2">*</bpt>expression2<ept id="p2">*</ept> from <bpt id="p3">*</bpt>expression1<ept id="p3">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>minus<ept id="p1">**</ept> 演算子は、<bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> から <bpt id="p2">*</bpt>expression2<ept id="p2">*</ept> を減算します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="139">
          <source>?</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">?</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="140">
          <source>The <bpt id="p1">**</bpt>ternary<ept id="p1">**</ept> operator takes three expressions: <bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> ?</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>ternary<ept id="p1">**</ept> 演算子は、3 つの式を取ります: <bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> ?</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="141">
          <source><bpt id="p1">*</bpt>expression2<ept id="p1">*</ept> : <bpt id="p2">*</bpt>expression3<ept id="p2">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">*</bpt>式2<ept id="p1">*</ept> : <bpt id="p2">*</bpt>式3<ept id="p2">*</ept>。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="142">
          <source>If <bpt id="p1">*</bpt>expression1<ept id="p1">*</ept> is true, <bpt id="p2">*</bpt>expression2<ept id="p2">*</ept> is returned.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">*</bpt>expression1<ept id="p1">*</ept> が true の場合、<bpt id="p2">*</bpt>expression2<ept id="p2">*</ept> が返されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="143">
          <source>Otherwise, <bpt id="p1">*</bpt>expression3<ept id="p1">*</ept> is returned.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">それ以外の場合、<bpt id="p1">*</bpt>expression3<ept id="p1">*</ept> が返されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="144">
          <source>Code examples for arithmetic operators</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">算術演算子のコード例</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="145">
          <source>Expression operators</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">式の演算子</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="146">
          <source>The <bpt id="p1">**</bpt>as<ept id="p1">**</ept> and <bpt id="p2">**</bpt>is<ept id="p2">**</ept> expression operators control downcast assignments.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>as<ept id="p1">**</ept> および <bpt id="p2">**</bpt>is<ept id="p2">**</ept> 式演算子はダウンキャストの割り当てを制御します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="147">
          <source>Downcast assignments involve class or table inheritance.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ダウン キャストの割り当てには、クラスまたはテーブルの継承が含まれています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="148">
          <source>Assignment statements that implicitly downcast can cause errors that are difficult to predict and diagnose.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">暗黙的にダウンキャストされた代入ステートメントは、予測および診断が困難なエラーを引き起こす可能性があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="149">
          <source>You can use the <bpt id="p1">**</bpt>as<ept id="p1">**</ept> keyword to make your downcasts explicit.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>as<ept id="p1">**</ept> キーワードを使用するとダウンキャストを明示的にすることができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="150">
          <source>You can use the <bpt id="p1">**</bpt>is<ept id="p1">**</ept> keyword to test whether a downcast is valid at run time.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>is<ept id="p1">**</ept> キーワードを使用すると、ダウンキャストが実行時に有効かどうかテストすることができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="151">
          <source>The as keyword</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">as キーワード</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="152">
          <source>Use the <bpt id="p1">**</bpt>as<ept id="p1">**</ept> keyword for assignments that downcast from a base class variable to a derived class variable.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">基本クラス変数から派生クラス変数にダウンキャストする代入には <bpt id="p1">**</bpt>as<ept id="p1">**</ept> キーワードを使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="153">
          <source>The <bpt id="p1">**</bpt>as<ept id="p1">**</ept> keyword tells other programmers and the compiler that you believe that the downcast will be valid during run time.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>as<ept id="p1">**</ept> キーワードは、実行にダウンキャストが有効になると思うことを他のプログラマーとコンパイラに伝えます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="154">
          <source>The compiler reports an error for downcast assignment statements that lack the <bpt id="p1">**</bpt>as<ept id="p1">**</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コンパイラは、<bpt id="p1">**</bpt>as<ept id="p1">**</ept> キーワードがないダウンキャストされた代入ステートメントのエラーを報告します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="155">
          <source>At run time, the <bpt id="p1">**</bpt>as<ept id="p1">**</ept> keyword causes the downcast assignment statement to assign <bpt id="p2">**</bpt>null<ept id="p2">**</ept> if the downcast isn't valid.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">実行時に、ダウンキャストが有効でない場合 <bpt id="p1">**</bpt>as<ept id="p1">**</ept> キーワードは、ダウンキャストされた代入ステートメントに <bpt id="p2">**</bpt>null<ept id="p2">**</ept> を割り当てます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="156">
          <source>This <bpt id="p1">**</bpt>is<ept id="p1">**</ept> keyword is often used to safely test whether the <bpt id="p2">**</bpt>as<ept id="p2">**</ept> keyword will work.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これは <bpt id="p2">**</bpt>as<ept id="p2">**</ept> キーワードが機能するかどうかを安全にテストするためによく使われるキーワード<bpt id="p1">**</bpt>です<ept id="p1">**</ept>。  </target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="157">
          <source>Code example for the as keyword</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">キーワードとしてのコード例</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="158">
          <source>In the following code example, the <bpt id="p1">**</bpt>DerivedClass<ept id="p1">**</ept> class extends the <bpt id="p2">**</bpt>BaseClass<ept id="p2">**</ept> class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のコード例では、<bpt id="p1">**</bpt>DerivedClass<ept id="p1">**</ept> クラスが <bpt id="p2">**</bpt>BaseClass<ept id="p2">**</ept> クラスを拡張します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="159">
          <source>The code example contains two valid assignments between its <bpt id="p1">**</bpt>basec<ept id="p1">**</ept> and <bpt id="p2">**</bpt>derivedc<ept id="p2">**</ept> variables.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このコード例には、<bpt id="p1">**</bpt>basec<ept id="p1">**</ept> と <bpt id="p2">**</bpt>derivedc<ept id="p2">**</ept> 変数の間に 2 つの有効な割り当てが含まれています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="160">
          <source>The upcast assignment to <bpt id="p1">**</bpt>basec<ept id="p1">**</ept> doesn't require the <bpt id="p2">**</bpt>as<ept id="p2">**</ept> keyword, but the downcast assignment to <bpt id="p3">**</bpt>derivedc<ept id="p3">**</ept> does require the <bpt id="p4">**</bpt>as<ept id="p4">**</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>basec<ept id="p1">**</ept> へのアップキャスト割り当てには <bpt id="p2">**</bpt>as<ept id="p2">**</ept> キーワードは必要ありませんが、<bpt id="p3">**</bpt>derivedc<ept id="p3">**</ept> へのダウンキャスト割り当てには <bpt id="p4">**</bpt>as<ept id="p4">**</ept> キーワードが必要です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="161">
          <source>The following code will compile and run without errors.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のコードはエラーなしでコンパイルして実行します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="162">
          <source>The is keyword</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">is キーワード</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="163">
          <source>The <bpt id="p1">**</bpt>is<ept id="p1">**</ept> keyword verifies whether an object is a subtype of a specified class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>is<ept id="p1">**</ept> キーワードは、オブジェクトが指定されたクラスのサブタイプであるかどうかを確認します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="164">
          <source>The <bpt id="p1">**</bpt>is<ept id="p1">**</ept> expression returns <bpt id="p2">**</bpt>true<ept id="p2">**</ept> if the object is a subtype of the class, or if the object is the same type as the class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">オブジェクトがクラスのサブタイプの場合、またはオブジェクトがクラスと同じタイプである場合、<bpt id="p1">**</bpt>is<ept id="p1">**</ept> 式は <bpt id="p2">**</bpt>true<ept id="p2">**</ept> を返します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="165">
          <source>The compiler reports an error if an <bpt id="p1">**</bpt>is<ept id="p1">**</ept> keyword expression compares two types, but neither type is a subtype of the other, and they aren't of the same type.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>is<ept id="p1">**</ept> キーワード式が 2 つの型を比較する場合、コンパイラはエラーを報告しますが、どちらも一方の型のサブタイプではなく、同じ型ではありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="166">
          <source>The compiler reports a similar error for any plain assignment statement between two types, where neither type is a subtype of the other, and they aren't of the same type.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コンパイラは、2 つの型の間の任意の明示的な代入ステートメントについて同様のエラーを報告します。どちらの型も一方の型のサブタイプではなく、同じ型ではありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="167">
          <source>At run time, the type of variable that references the underlying object is irrelevant to the <bpt id="p1">**</bpt>is<ept id="p1">**</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">実行時に、基になるオブジェクトを参照する変数の型は <bpt id="p1">**</bpt>is<ept id="p1">**</ept> キーワードには無関係です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="168">
          <source>The <bpt id="p1">**</bpt>is<ept id="p1">**</ept> keyword causes the system to verify the object that the variable references, not the declared type of the variable that references the object.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>is<ept id="p1">**</ept> キーワードを使用すると、オブジェクトを参照する変数の宣言された型ではなく、変数を参照しているオブジェクトをシステムが確認します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="169">
          <source>Code examples for the is keyword</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">のコード例はキーワードです</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="170">
          <source>The following code examples illustrate the conditions that control whether an <bpt id="p1">**</bpt>is<ept id="p1">**</ept> expression returns <bpt id="p2">**</bpt>true<ept id="p2">**</ept> or <bpt id="p3">**</bpt>false<ept id="p3">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のコード例は、<bpt id="p1">**</bpt>is<ept id="p1">**</ept> の式が <bpt id="p2">**</bpt>true<ept id="p2">**</ept> または <bpt id="p3">**</bpt>false<ept id="p3">**</ept> を返すかどうかを制御する条件を示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="171">
          <source>The code examples depend on the fact that the <bpt id="p1">**</bpt>Form<ept id="p1">**</ept> class and the <bpt id="p2">**</bpt>Query<ept id="p2">**</ept> class both extend the <bpt id="p3">**</bpt>TreeNode<ept id="p3">**</ept> class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このコード例は、<bpt id="p1">**</bpt>Form<ept id="p1">**</ept> クラスと <bpt id="p2">**</bpt>Query<ept id="p2">**</ept> クラスの両方が <bpt id="p3">**</bpt>TreeNode<ept id="p3">**</ept> クラスを拡張しているという事実に依存しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="172">
          <source>Code example for the is and as keywords</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">と キーワードとしてのコード例</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="173">
          <source>The following code example contains a typical use of the <bpt id="p1">**</bpt>is<ept id="p1">**</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のコード例には、<bpt id="p1">**</bpt>is<ept id="p1">**</ept> キーワードの一般的な使用例が含まれています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="174">
          <source>The <bpt id="p1">**</bpt>as<ept id="p1">**</ept> keyword is used after the <bpt id="p2">**</bpt>is<ept id="p2">**</ept> keyword verifies that the <bpt id="p3">**</bpt>as<ept id="p3">**</ept> keyword will succeed.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>as<ept id="p1">**</ept> キーワードは、<bpt id="p3">**</bpt>as<ept id="p3">**</ept> キーワードが成功することを <bpt id="p2">**</bpt>is<ept id="p2">**</ept> キーワードが確認した後使用されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="175">
          <source>In this example, the <bpt id="p1">**</bpt>is<ept id="p1">**</ept> and <bpt id="p2">**</bpt>as<ept id="p2">**</ept> keywords are uppercase to make them more visible.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この例では、<bpt id="p1">**</bpt>is<ept id="p1">**</ept> および <bpt id="p2">**</bpt>as<ept id="p2">**</ept> キーワードは視認しやすくするために大文字になっています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="176">
          <source>Object class as a special case</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">特殊なケースとしてのオブジェクト クラス</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="177">
          <source>The <bpt id="p1">**</bpt>Object<ept id="p1">**</ept> class can appear as a special case in inheritance functionality.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>Object<ept id="p1">**</ept> クラスは、継承機能に特別なケースとして表示できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="178">
          <source>The compiler bypasses type checking for assignments to and from variables that are declared to be of type <bpt id="p1">**</bpt>Object<ept id="p1">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コンパイラは、<bpt id="p1">**</bpt>オブジェクト<ept id="p1">**</ept>型であると宣言された変数との間の割り当ての型チェックをバイパスします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="179">
          <source>Some classes inherit from the <bpt id="p1">**</bpt>Object<ept id="p1">**</ept> class, some classes inherit from another class, and some classes don't inherit from any class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>オブジェクト<ept id="p1">**</ept> クラスから継承されるクラス、別のクラスから継承されるクラス、どのクラスからも継承されないクラスがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="180">
          <source>Although the <bpt id="p1">**</bpt>Dialog<ept id="p1">**</ept> class doesn't inherit from any class, the assignment and call statements in the following code example work.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>ダイアログ<ept id="p1">**</ept> クラスはどのクラスからも継承しませんが、次のコード例の割り当ておよび呼び出しステートメントからの処理はおこなわれます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="181">
          <source>However, if the assignment is <bpt id="p1">**</bpt>bank4 = dlog3;<ept id="p1">**</ept>, it will fail at compile time, because the <bpt id="p2">**</bpt>Bank<ept id="p2">**</ept> and <bpt id="p3">**</bpt>Dialog<ept id="p3">**</ept> classes have no inheritance relationship to each other.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、割り当てが <bpt id="p1">**</bpt>bank4 = dlog3;<ept id="p1">**</ept> の場合、<bpt id="p2">**</bpt>銀行<ept id="p2">**</ept>および<bpt id="p3">**</bpt>ダイアログ<ept id="p3">**</ept>クラスには相互に継承関係がないため、コンパイル時に失敗します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="182">
          <source>The compiler performs only one small validation on assignments to a variable that is declared to be of the <bpt id="p1">**</bpt>Object<ept id="p1">**</ept> class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コンパイラは、<bpt id="p1">**</bpt>オブジェクト<ept id="p1">**</ept> クラスであると宣言された変数への割り当てに対して、1 つの小さな検証しか実行しません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="183">
          <source>The compiler verifies that the item that is being assigned to the <bpt id="p1">**</bpt>Object<ept id="p1">**</ept> variable is an instance of a class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コンパイラは、<bpt id="p1">**</bpt>オブジェクト<ept id="p1">**</ept>変数に割り当てられている項目がクラスのインスタンスであることを確認します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="184">
          <source>The compiler doesn't allow an instance of a table buffer to be assigned to the <bpt id="p1">**</bpt>Object<ept id="p1">**</ept> variable.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コンパイラでは、テーブル バッファーのインスタンスを<bpt id="p1">**</bpt>オブジェクト<ept id="p1">**</ept>変数に割り当てることはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="185">
          <source>Additionally, the compiler doesn't allow primitive data types, such as <bpt id="p1">**</bpt>int<ept id="p1">**</ept> or <bpt id="p2">**</bpt>str<ept id="p2">**</ept>, to be assigned to the <bpt id="p3">**</bpt>Object<ept id="p3">**</ept> variable.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">また、コンパイラは、<bpt id="p1">**</bpt>int<ept id="p1">**</ept> または <bpt id="p2">**</bpt>str<ept id="p2">**</ept> のようなプリミティブ データ型を<bpt id="p3">**</bpt>オブジェクト<ept id="p3">**</ept>変数に割り当てることはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="186">
          <source>Tables</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">テーブル</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="187">
          <source>All tables inherit directly from the Common system table, unless they explicitly inherit from a different table.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">すべての表は、異なる表から明示的に継承しない限り、共通システム表から直接継承します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="188">
          <source>The Common table can't be instantiated.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">共通テーブルをインスタンス化することはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="189">
          <source>It doesn't exist in the underlying physical database.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">基になる物理データベースに存在しません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="190">
          <source>The Common table inherits from the <bpt id="p1">**</bpt>xRecord<ept id="p1">**</ept> class, but in a special way that isn't appropriate for the <bpt id="p2">**</bpt>is<ept id="p2">**</ept> keyword or the <bpt id="p3">**</bpt>as<ept id="p3">**</ept> keyword.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">共通テーブルは、<bpt id="p1">**</bpt>xRecord<ept id="p1">**</ept> クラスから継承されますが、<bpt id="p2">**</bpt>is<ept id="p2">**</ept> キーワードまたは <bpt id="p3">**</bpt>as<ept id="p3">**</ept> キーワードに適切でない特別な方法で継承されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="191">
          <source>When the <bpt id="p1">**</bpt>as<ept id="p1">**</ept> keyword is used to perform an invalid downcast among tables, the target variable references an unusable non-null entity.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">テーブル間の無効なダウンキャストの実行に <bpt id="p1">**</bpt>as<ept id="p1">**</ept> キーワードが使用されるとき、ターゲット変数は使用不可能な null エンティティを参照します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="192">
          <source>Any attempt to de-reference the target variable will cause an error that stops the program.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ターゲット変数の参照を解除しようとすると、プログラムを停止させるエラーが発生します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="193">
          <source>The is and as keywords and extended data types</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">is キーワードと as キーワードと拡張データ型</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="194">
          <source>Each extended data type has an <bpt id="p1">**</bpt>Extends<ept id="p1">**</ept> property.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">各拡張データ タイプには、<bpt id="p1">**</bpt>拡張<ept id="p1">**</ept>プロパティがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="195">
          <source>The style of inheritance that this property controls differs from the style of inheritance that the <bpt id="p1">**</bpt>is<ept id="p1">**</ept> and <bpt id="p2">**</bpt>as<ept id="p2">**</ept> keywords are designed for.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このプロパティが制御する継承のスタイルは、<bpt id="p1">**</bpt>is<ept id="p1">**</ept> で、<bpt id="p2">**</bpt>as<ept id="p2">**</ept> のキーワードが設計されている継承のスタイルと異なります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="196">
          <source>Relational operators</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">リレーショナル演算子</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="197">
          <source>The following table lists the relational operators that can be used in X++.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルは、X++ で使用できるリレーショナル演算子の一覧です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="198">
          <source>Most of the operators are binary and take two operands.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">演算子のほとんどはバイナリであり、2 つのオペランドを取ります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="199">
          <source>However, the <bpt id="p1">**</bpt>not<ept id="p1">**</ept> (<bpt id="p2">**</bpt>!<ept id="p2">**</ept>) operator is unary and takes only one operand.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、<bpt id="p1">**</bpt>not<ept id="p1">**</ept> (<bpt id="p2">**</bpt>!<ept id="p2">**</ept>) 演算子は単項で 1 つのオペランドのみを取ります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="200">
          <source>Syntax for binary operators: <bpt id="p1">*</bpt>expression1<ept id="p1">*</ept> <bpt id="p2">*</bpt>relationalOperator<ept id="p2">*</ept> <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept> Syntax for unary operators: <bpt id="p4">*</bpt>relationalOperator<ept id="p4">*</ept> <bpt id="p5">*</bpt>expression1<ept id="p5">*</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">バイナリ演算子の構文: <bpt id="p1">*</bpt>expression1<ept id="p1">*</ept> <bpt id="p2">*</bpt>relationalOperator<ept id="p2">*</ept> <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept> 単項演算子の構文: <bpt id="p4">*</bpt>relationalOperator<ept id="p4">*</ept> <bpt id="p5">*</bpt>expression1<ept id="p5">*</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="201">
          <source>Operator</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">オペレーター</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="202">
          <source>Description</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">説明</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="203">
          <source>like</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">等号</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="204">
          <source>The <bpt id="p1">**</bpt>like<ept id="p1">**</ept> relational operator returns <bpt id="p2">**</bpt>true<ept id="p2">**</ept> if <bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> is like <bpt id="p4">*</bpt>expression2<ept id="p4">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>like<ept id="p1">**</ept> 関係演算子は、<bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> が <bpt id="p4">*</bpt>expression2<ept id="p4">*</ept> と似ている場合に <bpt id="p2">**</bpt>true<ept id="p2">**</ept> を返します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="205">
          <source>The <bpt id="p1">**</bpt>equal<ept id="p1">**</ept> relational operator returns <bpt id="p2">**</bpt>true<ept id="p2">**</ept> if both expressions are equal.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>equal<ept id="p1">**</ept> 関係演算子は、両方の式が等しい場合に <bpt id="p2">**</bpt>true<ept id="p2">**</ept> を返します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="206">
          <source>The <bpt id="p1">**</bpt>greater than or equal to<ept id="p1">**</ept> relational operator returns <bpt id="p2">**</bpt>true<ept id="p2">**</ept> if <bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> is greater than or equal to <bpt id="p4">*</bpt>expression2<ept id="p4">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>greater than or equal to<ept id="p1">**</ept> 関係演算子は、<bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> が <bpt id="p4">*</bpt>expression2<ept id="p4">*</ept> 以上の場合に <bpt id="p2">**</bpt>true<ept id="p2">**</ept> を返します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="207">
          <source>The <bpt id="p1">**</bpt>less than or equal to<ept id="p1">**</ept> relational operator returns <bpt id="p2">**</bpt>true<ept id="p2">**</ept> if <bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> is less than or equal to <bpt id="p4">*</bpt>expression2<ept id="p4">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>less than or equal to<ept id="p1">**</ept> 関係演算子は、<bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> が <bpt id="p4">*</bpt>expression2<ept id="p4">*</ept> 以下の場合に <bpt id="p2">**</bpt>true<ept id="p2">**</ept> を返します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="208">
          <source>The <bpt id="p1">**</bpt>greater than<ept id="p1">**</ept> relational operator returns <bpt id="p2">**</bpt>true<ept id="p2">**</ept> if <bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> is greater than <bpt id="p4">*</bpt>expression2<ept id="p4">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>greater than<ept id="p1">**</ept> 関係演算子は、<bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> が <bpt id="p4">*</bpt>expression2<ept id="p4">*</ept> より大きい場合に <bpt id="p2">**</bpt>true<ept id="p2">**</ept> を返します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="209">
          <source>The <bpt id="p1">**</bpt>less than<ept id="p1">**</ept> relational operator returns <bpt id="p2">**</bpt>true<ept id="p2">**</ept> if <bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> is less than <bpt id="p4">*</bpt>expression2<ept id="p4">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>less than<ept id="p1">**</ept> 関係演算子は、<bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> が <bpt id="p4">*</bpt>expression2<ept id="p4">*</ept> より小さい場合に <bpt id="p2">**</bpt>true<ept id="p2">**</ept> を返します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="210">
          <source>!=</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">!=</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="211">
          <source>The <bpt id="p1">**</bpt>not equal<ept id="p1">**</ept> relational operator returns <bpt id="p2">**</bpt>true<ept id="p2">**</ept> if <bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> differs from (that is, if it isn't equal to) <bpt id="p4">*</bpt>expression2<ept id="p4">*</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>not equal<ept id="p1">**</ept> 関係演算子は、<bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> が <bpt id="p4">*</bpt>expression2<ept id="p4">*</ept> と異なる (つまり等しくない) 場合に <bpt id="p2">**</bpt>true<ept id="p2">**</ept> を返します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="212">
          <source>The <bpt id="p1">**</bpt>and<ept id="p1">**</ept> relational operator returns <bpt id="p2">**</bpt>true<ept id="p2">**</ept> if both <bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> and <bpt id="p4">*</bpt>expression2<ept id="p4">*</ept> are true.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>and<ept id="p1">**</ept> 関係演算子は、<bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> と <bpt id="p4">*</bpt>expression2<ept id="p4">*</ept> の両方が true の場合に、<bpt id="p2">**</bpt>true<ept id="p2">**</ept> を返します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="213">
          <source>The <bpt id="p1">**</bpt>or<ept id="p1">**</ept> relational operator returns <bpt id="p2">**</bpt>true<ept id="p2">**</ept> if <bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> or <bpt id="p4">*</bpt>expression2<ept id="p4">*</ept> is true, or if both are true.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>or<ept id="p1">**</ept> 関係演算子は、<bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> または <bpt id="p4">*</bpt>expression2<ept id="p4">*</ept> が true の場合、または両方が true の場合に <bpt id="p2">**</bpt>true<ept id="p2">**</ept> を返します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="214">
          <source>!</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">!</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="215">
          <source>The <bpt id="p1">**</bpt>not<ept id="p1">**</ept> or <bpt id="p2">**</bpt>unary<ept id="p2">**</ept> relational operator negates the expression.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>not<ept id="p1">**</ept> または <bpt id="p2">**</bpt>unary<ept id="p2">**</ept> 関係演算子、式を無効にします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="216">
          <source>It returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> if the expression is false and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> if the expression is true.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">式が false の場合は <bpt id="p1">**</bpt>true<ept id="p1">**</ept>、式が true の場合は <bpt id="p2">**</bpt>false<ept id="p2">**</ept> を返します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="217">
          <source>The like operator</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">like 演算子</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="218">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>like<ept id="p1">&lt;/strong&gt;</ept> operator can use <bpt id="p2">&lt;strong&gt;</bpt><ph id="ph1">*</ph><ept id="p2">&lt;/strong&gt;</ept> as a wildcard character for zero or more characters, and <bpt id="p3">&lt;strong&gt;</bpt>?<ept id="p3">&lt;/strong&gt;</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>like<ept id="p1">&lt;/strong&gt;</ept> 演算子は、<bpt id="p2">&lt;strong&gt;</bpt><ph id="ph1">*</ph><ept id="p2">&lt;/strong&gt;</ept> を 0 文字以上のワイルドカード文字として使用できます。さらに、<bpt id="p3">&lt;strong&gt;</bpt>?<ept id="p3">&lt;/strong&gt;</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="219">
          <source>as a wildcard character for one character.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">1 つの文字に対する 1 つのワイルドカード文字として。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="220">
          <source>The operand can't be longer than 1,000 characters.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">オペランドは 1,000 文字を超えることはできません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="221">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>like<ept id="p1">&lt;/strong&gt;</ept> operator is evaluated by the underlying SQL, so the result might differ on different installations.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">&lt;strong&gt;</bpt>like<ept id="p1">&lt;/strong&gt;</ept> 演算子は、基になる SQL により評価されるため、インストールごとに結果が異なる可能性があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="222">
          <source>If the expressions that you're comparing contain a file path, you must include four backslashes between each element, as shown in the following example.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">比較している式にファイルのパスが含まれている場合は、次の例で示すように、各要素の間で次の 4 つのバックスラッシュを含める必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="223">
          <source>The equal (==) operator</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">等号 (==) 演算子</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="224">
          <source>When you use the <bpt id="p1">**</bpt>equal<ept id="p1">**</ept> (<bpt id="p2">**</bpt><ph id="ph1">==</ph><ept id="p2">**</ept>) operator to compare objects, the object references are compared, not the objects themselves.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>等号<ept id="p1">**</ept> (<bpt id="p2">**</bpt><ph id="ph1">==</ph><ept id="p2">**</ept>) 演算子を使用してオブジェクトを比較するとき、オブジェクト自体ではなく、オブジェクト参照が比較されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="225">
          <source>This behavior might cause issues if you compare two objects, one of which is located on the server, and the other of which is located on the client.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この動作は、2 つのオブジェクト (そのうちの 1 つはサーバー上にあり、もう 1 つはクライアント上にあるオブジェクト) を比較すると問題が発生する可能性があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="226">
          <source>In these cases, you should use the <bpt id="p1">**</bpt>equal<ept id="p1">**</ept> method in the <bpt id="p2">**</bpt>Object<ept id="p2">**</ept> class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">そのような場合、<bpt id="p1">**</bpt>equal<ept id="p1">**</ept> メソッドを<bpt id="p2">**</bpt>オブジェクト<ept id="p2">**</ept> クラスで使用する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="227">
          <source>You can override this method to specify what it means for two objects to be equal.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このメソッドをオーバーライドして、2つのオブジェクトが等しいことが何を意味するかを指定することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="228">
          <source>If you don't override the <bpt id="p1">**</bpt>equal<ept id="p1">**</ept> method, the comparison is identical to the comparison that is done by the <bpt id="p2">**</bpt>equal<ept id="p2">**</ept> (<bpt id="p3">**</bpt><ph id="ph1">==</ph><ept id="p3">**</ept>) operator.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>等号<ept id="p1">**</ept>メソッドを上書きしない場合、比較は<bpt id="p2">**</bpt>等号<ept id="p2">**</ept> (<bpt id="p3">**</bpt><ph id="ph1">==</ph><ept id="p3">**</ept>) 演算子によって行われる比較と同じになります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="229">
          <source>Code examples for relational operators</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">リレーショナル演算子のコード例</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="230">
          <source>Operator precedence</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">演算子の優先順位</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="231">
          <source>The order that a compound expression is evaluated in can be important.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">複合式が評価される順序は重要です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="232">
          <source>For example, <bpt id="p1">**</bpt>(x + y / 100)<ept id="p1">**</ept> gives a different result, depending on whether the addition or the division is done first.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">たとえば、<bpt id="p1">**</bpt>(x + y / 100)<ept id="p1">**</ept> は追加または区分を最初に実行するかどうかによって、結果が異なります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="233">
          <source>You can use parentheses (<bpt id="p1">**</bpt>()<ept id="p1">**</ept>) to explicitly tell the compiler how it should evaluate an expression.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">かっこ (<bpt id="p1">**</bpt>()<ept id="p1">**</ept>) を使用すると、式の評価方法を明示的にコンパイラに指示することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="234">
          <source>For example, you can specify <bpt id="p1">**</bpt>(x + y) / 100<ept id="p1">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">たとえば、<bpt id="p1">**</bpt>(x + y) / 100<ept id="p1">**</ept> を指定できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="235">
          <source>If you don't explicitly tell the compiler the order that you want operations to be done in, the order is based on the precedence that is assigned to the operators.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">オペレーションを実行する順序をコンパイラーに明示的に伝えていない場合、順序はオペレーターに割り当てられた優先順位に基づきます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="236">
          <source>For example, the division operator has higher precedence than the addition operator.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">たとえば、除算演算子には、加算演算子より高い優先順位があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="237">
          <source>Therefore, for the expression <bpt id="p1">**</bpt>x + y / 100<ept id="p1">**</ept>, the compiler evaluates <bpt id="p2">**</bpt>y / 100<ept id="p2">**</ept> first.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">したがって、<bpt id="p1">**</bpt>x + y / 100<ept id="p1">**</ept> の式では、コンパイラはまず <bpt id="p2">**</bpt>y / 100<ept id="p2">**</ept> を評価します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="238">
          <source>In other words,<ph id="ph1">` `</ph><bpt id="p1">**</bpt>x + y / 100<ept id="p1">**</ept> is equivalent to <bpt id="p2">**</bpt>x + (y / 100)<ept id="p2">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">つまり、<ph id="ph1">` `</ph><bpt id="p1">**</bpt>x + y/100<ept id="p1">**</ept> は <bpt id="p2">**</bpt>x + (y/100)<ept id="p2">**</ept> と等しくなります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="239">
          <source>To make your code easy to read and maintain, be explicit.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コードを読みやすく管理しやすくするために、明示的に記述します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="240">
          <source>Use parentheses to indicate which operators should be evaluated first.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">最初に評価する演算子を示すには、かっこを使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="241">
          <source>The following table lists the operators in order of precedence.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次のテーブルは、優先順位の順に演算子を示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="242">
          <source>The higher an operator appears in the table, the higher its precedence.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">テーブルの演算子は高いほど、優先順位が高くなります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="243">
          <source>Operators that have higher precedence are evaluated before operators that have lower precedence.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">高い優先順位がある演算子は、低い優先順位がある演算子より前に評価されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="244">
          <source>Note that the operator precedence of X++ isn't the same as the operator precedence of other languages, such as C<ph id="ph1">\#</ph> and Java.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ の演算子の優先順位は、C<ph id="ph1">\#</ph> および Java などの他の言語の演算子の優先順位と同じではないことに注意してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="245">
          <source>Operators, in order of precedence</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">演算子 (優先順位)</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="246">
          <source>Syntax</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">構文</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="247">
          <source>Unary</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">単項</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="248">
          <source>- ~ !</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">- ～ !</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="249">
          <source>Multiplicative, shift, bitwise <bpt id="p1">&lt;strong&gt;</bpt>AND<ept id="p1">&lt;/strong&gt;</ept>, bitwise exclusive <bpt id="p2">&lt;strong&gt;</bpt>OR<ept id="p2">&lt;/strong&gt;</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">乗算、シフト、ビット演算 <bpt id="p1">&lt;strong&gt;</bpt>AND<ept id="p1">&lt;/strong&gt;</ept>、ビット演算排他的 <bpt id="p2">&lt;strong&gt;</bpt>OR<ept id="p2">&lt;/strong&gt;</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="250">
          <source><ph id="ph1">\*</ph> / % DIV <ph id="ph2">&amp;lt;</ph><ph id="ph3">&amp;lt;</ph> <ph id="ph4">&amp;gt;</ph><ph id="ph5">&amp;gt;</ph> &amp; ^</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">\*</ph> / % DIV <ph id="ph2">&amp;lt;</ph><ph id="ph3">&amp;lt;</ph> <ph id="ph4">&amp;gt;</ph><ph id="ph5">&amp;gt;</ph> &amp; ^</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="251">
          <source>Additive, bitwise inclusive <bpt id="p1">&lt;strong&gt;</bpt>OR<ept id="p1">&lt;/strong&gt;</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">加法、ビット演算包括的 <bpt id="p1">&lt;strong&gt;</bpt>OR<ept id="p1">&lt;/strong&gt;</ept></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="252">
          <source>+ –</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">+ –</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="253">
          <source>Relational, equality</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">リレーショナル、同等</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="254">
          <source><ph id="ph1">&amp;lt;</ph> <ph id="ph2">&amp;lt;</ph>= == != <ph id="ph3">&amp;gt;</ph> <ph id="ph4">&amp;gt;</ph>= like as is</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><ph id="ph1">&amp;lt;</ph> <ph id="ph2">&amp;lt;</ph>= == != <ph id="ph3">&amp;gt;</ph> <ph id="ph4">&amp;gt;</ph>= 現状のとおり</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="255">
          <source>Logical (<bpt id="p1">&lt;strong&gt;</bpt>AND<ept id="p1">&lt;/strong&gt;</ept>, <bpt id="p2">&lt;strong&gt;</bpt>OR<ept id="p2">&lt;/strong&gt;</ept>)</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">論理 (<bpt id="p1">&lt;strong&gt;</bpt>AND<ept id="p1">&lt;/strong&gt;</ept>、<bpt id="p2">&lt;strong&gt;</bpt>OR<ept id="p2">&lt;/strong&gt;</ept>)</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="256">
          <source>Conditional</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">条件付</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="257">
          <source>?</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">?</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="258">
          <source>:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">:</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="259">
          <source>Operators on the same line have equal precedence.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">同じ行の演算子には、同等な優先順位があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="260">
          <source>If an expression includes more than one of these operators, it's evaluated from left to right, unless assignment operators are used.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">式にこれらの演算子のうち 1 つ以上が含まれる場合、代入演算子が使用されない限り、式は左から右に評価されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="261">
          <source>(Assignment operators are evaluated from right to left.) For example, <bpt id="p1">**</bpt><ph id="ph1">&amp;&amp;</ph><ept id="p1">**</ept> (logical <bpt id="p2">**</bpt>AND<ept id="p2">**</ept>) and <bpt id="p3">**</bpt><ph id="ph2">||</ph><ept id="p3">**</ept> (logical <bpt id="p4">**</bpt>OR<ept id="p4">**</ept>) have the same precedence, and are evaluated from left to right.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">(代入演算子は、右から左に評価されます)。たとえば、<bpt id="p1">**</bpt><ph id="ph1">&amp;&amp;</ph><ept id="p1">**</ept> (論理的<bpt id="p2">**</bpt>アンド<ept id="p2">**</ept>) および<bpt id="p3">**</bpt><ph id="ph2">||</ph><ept id="p3">**</ept> (論理的<bpt id="p4">**</bpt>または<ept id="p4">**</ept>) には、同じ優先順位があり、左から右に評価されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="262">
          <source>Therefore, <bpt id="p1">**</bpt>0&amp;&amp;0||1 == 1<ept id="p1">**</ept>, and <bpt id="p2">**</bpt>1||0&amp;&amp;0 == 0<ept id="p2">**</ept>.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">したがって、<bpt id="p1">**</bpt>0&amp;&amp;0||1 == 1<ept id="p1">**</ept>、および <bpt id="p2">**</bpt>1||0&amp;&amp;0 == 0<ept id="p2">**</ept> です。</target></trans-unit>
      </group>
    </body>
  </file>
</xliff>