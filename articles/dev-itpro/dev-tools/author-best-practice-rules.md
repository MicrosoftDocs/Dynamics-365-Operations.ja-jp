<?xml version="1.0" encoding="UTF-8"?>
<xliff xmlns:logoport="urn:logoport:xliffeditor:xliff-extras:1.0" xmlns:tilt="urn:logoport:xliffeditor:tilt-non-translatables:1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-US" original="author-best-practice-rules.md" target-language="ja-JP">
    <header>
      <tool tool-company="Microsoft" tool-version="1.0-7889195" tool-name="mdxliff" tool-id="mdxliff"/>
      <xliffext:skl_file_name>author-best-practice-rules.6d6750.0406f2b7b25a659aa84dedaff3dae9fa1c4b529d.skl</xliffext:skl_file_name>
      <xliffext:version>1.2</xliffext:version>
      <xliffext:ms.openlocfilehash>0406f2b7b25a659aa84dedaff3dae9fa1c4b529d</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit>9d4c7edd0ae2053c37c7d81cdd180b16bf3a9d3b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff>05/15/2019</xliffext:ms.lasthandoff>
      <xliffext:ms.openlocfilepath>articles\dev-itpro\dev-tools\author-best-practice-rules.md</xliffext:ms.openlocfilepath>
    </header>
    <body>
      <group extype="content" id="content">
        <trans-unit xml:space="preserve" translate="yes" id="101" restype="x-metadata">
          <source>Write best practice rules</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ベスト プラクティス ルールを記述する</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="102" restype="x-metadata">
          <source>This topic describes how you can author best practice rules in C#, for both metadata and X++ code.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このトピックでは、メタデータと X++ コードの両方について、C# でベスト プラクティス ルールを作成する方法について説明します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="103">
          <source>Write best practice rules</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ベスト プラクティス ルールを記述する</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="104">
          <source>This topic describes how you can author best practice rules in C#, for both metadata and X++ code.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このトピックでは、メタデータと X++ コードの両方について、C# でベスト プラクティス ルールを作成する方法について説明します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="105">
          <source>Best practice checks are run by the compiler and in daily builds to catch objectionable practices that are unacceptable in shipping code.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">推奨チェックは出荷コードで許容されない不都合なプラクティスをキャッチするためにコンパイラおよび日単位ビルドで実行されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="106">
          <source>The features can also be used to author simple one-of tools to gather information about the application.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この機能を使用して、アプリケーションに関する情報を収集するための簡単なツールを作成することもできます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="107">
          <source>This topic shows you how to author new best practice rules using the best practices framework.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このトピックでは、ベスト プラクティス フレームワークを使用して、新しいベスト プラクティス ルールを作成する方法を説明します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="108">
          <source>Best practice checks are run during development and in daily builds to catch coding practices that are deemed unacceptable in shipping code.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">推奨チェックは出荷コードで許容できないとみなされるコーディング プラクティスをキャッチするために開発時および日単位ビルドで実行されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="109">
          <source>Best practice rules are not restricted to this usage however; they can also be used to author simple one-of tools to gather information about the application.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、ベスト プラクティス ルールはこの使用に制限されません。アプリケーションに関する情報を収集するための簡単なツールを作成するのにも使用できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="110">
          <source>The framework is built on top of a managed framework called XLNT (shorthand for X++ LaNguage Toolkit) that can be used to build custom tools that extract information from, and modify, X++ code.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このフレームワークは、XLNT (X++ LaNguage ツールキットの省略形) と呼ばれるマネージド フレームワークの上に構築され、X++ コードから情報を抽出して変更するカスタム ツールを構築するのに使用できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="111">
          <source>There are two types of best practice rules: those that deal with metadata and those that deal with source code.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ベスト プラクティス ルールには、メタデータを処理するルールとソース コードを処理するルールの 2 種類があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="112">
          <source>Code Best Practice framework</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コードのベスト プラクティス フレームワーク</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="113">
          <source>The Code Best Practice Framework (CBPF) enables you to write your own tools for analyzing X++ source code.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コード ベスト プラクティス フレームワーク (CBPF) を使用すると、X++ ソース コードを分析するための独自のツールを作成できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="114">
          <source>These rules diagnose things that you consider to be problems with X++ source code.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これらのルールは、X++ ソース コードに問題があると判断するものを診断します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="115">
          <source>This section describes the foundation of the Best Practice functionality.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このセクションでは、ベスト プラクティス機能の基礎について説明します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="116">
          <source>This information is helpful for understanding the later sections that describe creating your own rules in greater detail.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この情報は、独自のルールの作成について詳しく説明する後のセクションの理解に役立ちます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="117">
          <source>It is also helpful to developers who want to code rules that are more complex than those demonstrated in this document.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">また、このドキュメントで示されているものよりも複雑なコード ルールを求める開発者にとっても便利です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="118">
          <source>The CBPF API is designed to allow you to focus on the rule you are expressing, without having to deal with infrastructure issues; you will not need to read tokens and piece them together to create something intelligible from them.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">CBPF API は、インフラストラクチャの問題に対しなくても、、表現するルールに焦点を当てることができるように設計されています。トークンを読み取り、それらを組み合わせてインテリジェンスなものを作成する必要はありません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="119">
          <source>Instead, the CBPF provides the following parts:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">代わりに、CBPF は次のパーツを提供します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="120">
          <source>A parser that builds an Abstract Syntax Tree (AST) from X++ source code.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ ソース コードから抽象構文ツリー (AST) を構築するパーサー。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="121">
          <source>A pipeline that runs a sequence of passes over the X++ code.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ コードでパスの順序を実行するパイプライン。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="122">
          <source>A number of prebuilt passes.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">作成済みのパスの数。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="123">
          <source>The first pass is the parsing of the source code.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">最初のパスは、ソース コードの解析です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="124">
          <source>Infrastructure to read metadata.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メタデータを読み取るインフラストラクチャ。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="125">
          <source>Because rules are based on ASTs, it is important to understand that concept before starting to write rules.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ルールは AST に基づいているために、ルールの作成を始める前にその概念を理解する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="126">
          <source>The parser and ASTs</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">パーサーと AST</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="127">
          <source>The parser reads  X++ code and produces an AST from it if it does not contain egregious syntax errors.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">パーサーは、X++ コードを読み込み、それに重大な構文エラーが含まれていない場合は、それから AST を生成します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="128">
          <source>The parser has a built-in error recovery scheme, so it can recover from most syntax errors reasonably well.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">パーサーは、組み込みのエラー回復スキームを持つため、大部分の構文エラーから適切に回復できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="129">
          <source>When a syntax error happens, the parser will read symbols until it encounters a semicolon, and then try to building the AST by unstacking its state until it reaches a state where a semicolon is a correct symbol.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">構文エラーが発生するときは、パーサーはセミコロンに到達するまで記号を読み取り、セミコロンが正しい記号となる状態に到達するまでその状態をアンスタックして AST の構築を試みます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="130">
          <source>In addition, the parser is able to suggest the correct set of symbols when a syntax error occurs.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">さらに、パーサーは構文エラーが発生したときに、適切な記号のセットを提案できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="131">
          <source>The parser is not intended to be directly interacted with by consumers of the API, but should be considered a black box that works without user intervention.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">パーサーは、API のコンシューマーと直接対話するようにはなっていませんが、ユーザーの介入なしに機能するブラック ボックスと見なす必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="132">
          <source>As the parser recognizes the language constructs in the source code, it builds an AST.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">パーサーはソース コードの言語構成を認識すると、AST を構築します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="133">
          <source>The AST consists of nodes that are abstractions of the X++ artifact they represent.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">AST は、それらが表す X++ コンポーネントの抽象化であるノードで構成されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="134">
          <source>We will illustrate the concept by showing a few AST nodes below:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この概念を、いくつかの AST ノードを表示することによって、下図に示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="135">
          <source>The Statement class is abstract; it does not make sense to instantiate a ”statement”; only concrete derived classes (like if statements, while statements etc.) can be instantiated.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Statement クラスは抽象的です。"ステートメント" のインスタンスを作成しても意味がありません。コンクリート派生クラス (if ステートメントや while ステートメントなど同様) のインスタンスのみ作成できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="136">
          <source>Since the Comments property is placed on this base class, it applies to all derived classes; in other words: all statements can have comments preceding the statement, which are accessible through the given property.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コメント プロパティはこの基本クラスに置かれるため、すべての派生クラスに適用されます。つまり、すべてのステートメントはステートメントの前にコメントを持つことができ、特定のプロパティを使用してアクセスできます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="137">
          <source>There are many different kinds of statement in X++ and each one is described by a class derived in one or more steps from the abstract Statement class shown above.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ にはさまざまな多数の種類のステートメントがあり、それぞれが上記の抽象ステートメント クラスの 1 つ以上のステップで派生したクラスによって記述されています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="138">
          <source>The following example shows the definition of a <bpt id="p1">**</bpt>while<ept id="p1">**</ept> statement.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の例は、<bpt id="p1">**</bpt>while<ept id="p1">**</ept> ステートメントの定義を示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="139">
          <source>The <bpt id="p1">**</bpt>while<ept id="p1">**</ept> statement consists of the condition (an expression) and the constituent statement, that is executed as long as the condition evaluates to true.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>while<ept id="p1">**</ept> ステートメントは条件 (式) と、条件が true と評価される限り実行される構成ステートメントで構成されています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="140">
          <source>The parser will maintain the source code positions where the represented artifact starts and ends (i.e. its extent).</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">パーサーは、表現された成果物が開始および終了するソース コードの位置 (つまり、その範囲) を保持します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="141">
          <source>As the ASTs are traversed it may be useful to add information to the individual nodes.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">AST がスキャンされるので、個々のノードに情報を追加すると便利です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="142">
          <source>For example, every expression has a type.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">たとえば、すべての式にはタイプがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="143">
          <source>As the tree is traversed to diagnose type compatibility problems it becomes useful to be able to place that information on the individual node.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">タイプの互換性の問題を診断するためにツリーがスキャンされるので、個々のノードにその情報を配置できるようになると便利です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="144">
          <source>Rather than having to modify the AST nodes for each requirement, there is a property collection that can be used to provide name/value pairs to each node.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">各要件の AST ノードを変更する必要はなく、各ノードに名前/値の組み合わせを提供するために使用するプロパティ コレクションがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="145">
          <source>Each AST node has a <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> method that will return a high fidelity string representation of the node, which is useful in debugging scenarios.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">各 AST ノードには、ノードの高精度の文字列表現を戻す <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> 方法があります。これはシナリオのデバッグに役立ちます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="146">
          <source>The AstSweeper class</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">AstSweeper クラス</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="147">
          <source>The AstSweeper applies a visitor pattern to the AST instance that it is given.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">AstSweeper は、指定された AST インスタンスに ビジター パターンを適用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="148">
          <source>The visitor pattern allows the programmer to separate the underlying data structure (i.e. the AST) from the operations that the user wants to perform on the nodes (i.e. the logic reasoning about the code).</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ビジター パターンを使用すると、プログラマーは、ユーザーがノード上で実行する操作 (コードに関する論理推論) から基礎となるデータ構造 (AST) を分離することが可能になります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="149">
          <source>The <bpt id="p1">**</bpt>AstSweeper<ept id="p1">**</ept> class has a virtual method for each of the AST node types, and it will call them as directed by the structure of the AST.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>AstSweeper<ept id="p1">**</ept> クラスには、AST ノード タイプごとに仮想メソッドがあり、AST の構造の指示に従って呼び出します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="150">
          <source>The following examples shows how the sweeper works.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の例では、スウィーパーの動作を示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="151">
          <source>Some details have been omitted for clarity.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">わかりやすくするためにいくつかの詳細が除外されました。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="152">
          <source>The name of the virtual method handling a particular AST node is the name of the AST class prepended with Visit.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">特定の AST ノードを扱う仮想メソッドの名前は、Visit が先頭に追加された AST クラスの名前です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="153">
          <source>The parameters are the node to visit and a payload that may be passed to all the visitors as they are called.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">そのパラメーターは、参照するノードと、呼び出されたときすべての参照者に渡すことのできるペイロードです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="154">
          <source>In this way, the sweeper will call the virtual method once for each and every one of the nodes in the AST that is passed to it in a depth-first traversal.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この方法で、スウィーパーは深さ優先トラバーサルで渡される AST のノードのそれぞれに対して 1 回仮想メソッドを呼び出します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="155">
          <source>The payload parameter can be used to pass information (e.g. a symbol table) to each node as required.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ペイロード パラメーターを使用して、必要に応じて、各ノードに情報 (シンボル テーブルなど) を渡すことができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="156">
          <source>Developers will build classes derived from the AstSweeper class, overriding the methods of particular interest to them.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">開発者は、AstSweeper クラスから派生したクラスを構築し、特定の関心のあるメソッドを上書きします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="157">
          <source>Example</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">例</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="158">
          <source>Suppose you need to determine the percentage of parameter names starting with an underscore character, thus conforming to the X++ coding guidelines.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">X++ コーディング ガイドラインに準拠するため、アンダースコア文字で始まるパラメーター名の割合を決定する必要があるとします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="159">
          <source>You would then write a class deriving from the <bpt id="p1">**</bpt>AstSweeper<ept id="p1">**</ept> class with logic that calculated the number of parameters and the number of parameters starting with underscore.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次に、パラメーター数とアンダー スコアで始まるパラメーター数を計算したロジックを使用して、<bpt id="p1">**</bpt>AstSweeper<ept id="p1">**</ept> から派生するクラスを記述します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="160">
          <source>The following example shows this code.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次の例は、このコードを示しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="161">
          <source>In this case, the tally is maintained in the <bpt id="p1">**</bpt>ParametersCount<ept id="p1">**</ept> and <bpt id="p2">**</bpt>UnderscoredParameters<ept id="p2">**</ept> properties that are defined in the class scope.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この場合、集計はクラス スコープで定義されている <bpt id="p1">**</bpt>ParametersCount<ept id="p1">**</ept> および <bpt id="p2">**</bpt>UnderscoredParameters<ept id="p2">**</ept> プロパティで維持されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="162">
          <source>Another equally valid approach would be to pass this information into the payload that is passed to all the <bpt id="p1">**</bpt>Visit<ept id="p1">**</ept> methods.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">もう 1 つの均等に有効なアプローチでは、すべての <bpt id="p1">**</bpt>Visit<ept id="p1">**</ept> メソッドに渡されるペイロードにこの情報を渡すことができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="163">
          <source>In most cases, the user should unconditionally call super() from the overridden method to make sure that the Visit methods are called for all nodes below the one being visited.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ほとんどの場合、ユーザーは Visit メソッドがアクセスしたノード以下のすべてのノードに対して呼び出されることを確認するために、オーバーライドされたメソッドから super() を無条件に呼び出す必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="164">
          <source>In the case above it does not make a difference so we opt to improve performance by pruning the AST tree traversal.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">上記の場合、相違が生じないため、AST ツリー トラバーサルを簡略化することでパフォーマンスを向上します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="165">
          <source>Writing code for Best Practice rules</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ベスト プラクティス ルールのコードを記述</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="166">
          <source>Now that the concepts have been introduced, we are ready to author business rules.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">概念が導入されたので、ビジネス ルールを作成する準備が整いました。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="167">
          <source>Basically you need to:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">基本的には次のことが必要です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="168">
          <source>Define the situation you want to diagnose in terms of properties of the AST.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">AST のプロパティに関して診断したい状況を定義します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="169">
          <source>You will write <ph id="ph1">&lt;strong&gt;</ph>Visit<ph id="ph2">\&lt;</ph>/strong&gt;* methods that can do the analysis.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">解析を実行できる <ph id="ph1">&lt;strong&gt;</ph>Visit<ph id="ph2">\&lt;</ph>/strong&gt;* メソッドを記述できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="170">
          <source>When the error condition has been found, a diagnostic message must be generated.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">エラー状態が検出されたとき、診断メッセージを生成する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="171">
          <source>There is an API that is used for this purpose; basically you need to write some boilerplate code for each diagnostic message.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この目的のために使用される API があります。基本的には、各診断メッセージの定型コードを書く必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="172">
          <source>You need to hook your new best practice rule into the rest of the framework, so the user can decide whether or not to include your rule in his work and to actually run it if so directed.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ユーザーが自分の作業にルールを含めるかどうか、またそう指定された場合に実行するかどうかを決められるように、新しいベスト プラクティス ルールを残りのフレームワークにフックする必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="173">
          <source>Create a best practice rules project in Visual Studio</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Visual Studio でのベスト プラクティス ルール プロジェクトの作成</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="174">
          <source>In this walkthrough we imagine the following scenario:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このチュートリアルでは、次のシナリオを考えてみましょう。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="175">
          <source>Some methods are adorned with an Author attribute, that provides the name of the individual who wrote the code.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">一部のメソッドには、コードを記述した個人の名前を指定する Author 属性が用意されています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="176">
          <source>This is useful when finding who to point the finger at when stack traces containing that method appear.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これは、そのメソッドを含むスタック トレースが表示されたときに指摘する人を見つけるときに便利です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="177">
          <source>Since we have a significant turnaround of developers, the names of the developers listed cannot be static.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">開発者の重要な納期があるので、一覧表示された開発者の名前は静的である必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="178">
          <source>We want to check which names are used in the Author attributes, and match them against a list of names of current developers.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Author 属性で使用されている名前を確認し、現在の開発者の名前のリストと照合します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="179">
          <source>The author attribute class is simply defined as:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">作成者属性クラスは、単に次のように定義されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="180">
          <source>In production code we would put in documentation comments and assertions to validate key assumptions about parameter values etc. For the sake of clarity, we omit these steps in this walkthrough, where the code is written for clarity.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">実稼働コードでは、パラメーターの値などに関する主な前提を検証するために、ドキュメント コメントとアサートを挿入します。このチュートリアルではコードをわかりやすく書くため、これらの手順を省略します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="181">
          <source>Now that we have set the stage for what we want to achieve, we can start up Visual Studio and create a best practice rules project.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">アーカイブするものに対してステージを設定したので、Visual Studio を開始してベスト プラクティス ルール プロジェクトを作成することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="182">
          <source>Provide a meaningful name that properly conveys what the rules are intended to do: Visual Studio creates a project with some source code snippets and project references set up.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ルールの目的を適切に伝えるわかりやすい名前を入力してください。Visual Studio は、いくつかのソース コード スニペットおよびプロジェクト参照が設定されたプロジェクトを作成します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="183">
          <source>You can save considerable time by using this source code as a starting point for your own code.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このソース コードを自分のコードの出発点として使用することにより、時間を大幅に節約することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="184">
          <source>The pre-canned example contains rules that prohibits the word “Microsoft” in any method names (presumably for copyright reasons) and a metadata based rule prohibiting certain characters in names.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">既定の例には、メソッド名に "Microsoft" という語を禁止するルール (著作権上の理由から)、また名前に特定の文字を禁止するというメタデータ ベースのルールが含まれています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="185">
          <source>Since we are not concerned with the metadata checks for now, you can delete the InvalidCharactersDiagnosticItem.cs and DemoMetadataCheck.cs files from the project.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ここではメタデータ チェックを行いませんので、プロジェクトから InvalidCharactersDiagnosticItem.cs ファイルと DemoMetadataCheck.cs ファイルを削除できます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="186">
          <source>Also, since we are not interested in the Microsoft name check, go ahead and delete the content of the VisitMethod method in the DemoAST class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">また、Microsoft の名前チェックに興味がないので、DemoAST クラスの VisitMethod メソッドのコンテンツを削除してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="187">
          <source>The first thing we need to do is to find out if there are one or more Author attributes for a particular method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">最初に行う必要があるのは、特定のメソッドの作成者属性が 1 つ以上あるかどうかを調べることです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="188">
          <source>You will notice that the Method type (that is passed as a parameter to the VisitMethod method) has an Attributes property of type AttributeList.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このメソッド タイプ (これは、VisitMethod メソッドにパラメーターとして渡されます) に AttributeList タイプの属性プロパティが含まれていることがわかります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="189">
          <source>Let's use it to see if any Author attributes are defined on this method:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これを使用して、Author 属性がこのメソッドで定義されるかどうかを確認しましょう。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="190">
          <source>At this point we have looped through any attributes, and collected a list of author names, i.e. names that are provided as the first parameters to the Author attributes.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この時点であらゆる属性をループし作成者名のリストを収集しています (Author 属性の最初のパラメータとして提供される名前など)。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="191">
          <source>Now we need to compare the list against a list of acceptable authors, that we maintain in a static list.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">現在は、リストを許可された作成者のリストと比較する必要があり、静的リストで維持しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="192">
          <source>Whenever an author is provided that is not mentioned in the list we need to issue an appropriate diagnostic message.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">リストに記載されていない作成者が指定されるときはいつでも、適切な診断メッセージを発行する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="193">
          <source>At this time, we have something like:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">現時点では、次のようなものがあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="194">
          <source>In other words, we need to create a diagnostic message to let the user know about the transgression of the rule.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">つまり、ルールの違反についてユーザーに通知するために診断メッセージを作成する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="195">
          <source>As noted before, it is important to call the base implementation of your visitor, which will then call visitor methods for all the nodes that are contained in the method.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">前述のように、ビジターの基本実装を呼び出すことが重要です。メソッドに含まれるすべてのノードのビジター メソッドを呼び出します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="196">
          <source>However, in this case, we do not want to do any further processing once we have determined if the author attribute is on the list.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ただし、この場合は、作成者属性がリストにあるかを判断した後の詳しい操作は行うことを望みません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="197">
          <source>Add a class for the diagnostic message</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">診断メッセージのクラスの追加</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="198">
          <source>The project already includes boilerplate code for an error message, so we will use that as our starting point to create the diagnostic message that will be returned if the rule is violated.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">プロジェクトにはすでにエラー メッセージの定型コードが含まれているため、ルールに違反した場合に返される診断メッセージを作成するための出発点として使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="199">
          <source>Each message is implemented as a class of its own.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">各メッセージは、独自のクラスとして実装されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="200">
          <source>Each error message may have any amount of contextual information encoded into it.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">各エラー メッセージは、コード化された文脈情報を任意の量で有することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="201">
          <source>In this case, the contextual information is the name of the author that is not found in the list.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この場合、コンテキスト情報は一覧にない作成者の名前です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="202">
          <source>We will start by adding the message to the messages resource file: Open that file in the project and add a string to it.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">「プロジェクトでそのファイルを開き、文字列を追加します」というメッセージをメッセージ リソース ファイルに追加することから開始します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="203">
          <source>We will use the name (also known as the error moniker) AuthorNotCurrent.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">AuthorNotCurrent という名前 (エラー モニカーとも呼ばれます) を使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="204">
          <source>The ‘<ph id="ph1">{0}</ph>’ string is a placeholder for the contextual information, in this case the name of the author who is not in the list.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">‘<ph id="ph1">{0}</ph>’ 文字列はコンテキスト情報のプレースホルダで、この場合、リストに含まれていない作成者の名前です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="205">
          <source>In addition to the actual text that will appear in the error message, there is also a string containing a description of the rule; this information is shown in the best practice dialog within Visual Studio and is designed to help the user decide which rules he wants to enable on his system.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">エラー メッセージに表示される実際のテキストに加えて、ルールの説明を含む文字列もあります。この情報は、Visual Studio 内のベスト プラクティス ダイアログに表示され、ユーザーがシステムで有効にできるルールを決定できるように設計されています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="206">
          <source>Create a class for the diagnostic message, and call it AuthorNotCurrentDiagnosticItem.cs.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">診断メッセージのクラスを作成し、AuthorNotCurrentDiagnosticItem.cs という名前を付けます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="207">
          <source>Add the following code inspired from the NotAllowedWordDiagnosticItem class.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">NotAllowedWordDiagnosticItem クラスから、次の基となるコードを追加します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="208">
          <source>The diagnostic message is ready for consumption.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">診断メッセージは消費の準備ができています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="209">
          <source>There is just one piece of bookkeeping that needs to be done; the rule needs to publish declaratively which diagnostics it potentially issues.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">実行する必要がある簿記は 1 つだけです。このルールは、潜在的にどの診断を行うかを宣言的に公表する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="210">
          <source>Go back to your rule and modify the BestPracticeRule attribute to reflect the new diagnostic message:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ルールに戻り、新しい診断メッセージを反映するように BestPracticeRule 属性を変更します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="211">
          <source>As you can see, there are four parameters specified for the <bpt id="p1">**</bpt>BestPracticeRule<ept id="p1">**</ept> attribute:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ご覧のように、<bpt id="p1">**</bpt>BestPracticeRule<ept id="p1">**</ept> 属性に 4 つのパラメータが指定されています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="212">
          <source>The rule moniker.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ルール モニカー</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="213">
          <source>The type of the resource file holding the rule description.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ルール記述を保持するリソース ファイルのタイプ。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="214">
          <source>In this example we are using the default resource file named Messages, which created a class called Messages.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この例では、メッセージと呼ばれるクラスを作成した、メッセージという名前の既定のリソース ファイルを使用しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="215">
          <source>We want the type of this class as the second argument.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このクラスのタイプを 2 番目の引数とすることを求めます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="216">
          <source>The name of the string resource that contains the description of the rule.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ルールの説明を含む文字列リソースの名前。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="217">
          <source>This is the string called <bpt id="p1">**</bpt>AuthorNotCurrentDescription<ept id="p1">**</ept> that we added to the resource file above; it contains a human legible string to describe the rule.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これは、上記のリソース ファイルに追加した <bpt id="p1">**</bpt>AuthorNotCurrentDescription<ept id="p1">**</ept> という文字列です。 ルールを記述するために人間に読みやすい文字列が含まれています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="218">
          <source>This string is used to describe the rule to the user in a best practice dialog within Visual Studio.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この文字列を使用して、Visual Studio 内のベスト プラクティスのダイアログでユーザーにルールを記述します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="219">
          <source>In Visual Studio, select <bpt id="p1">**</bpt>Dynamics 365 <ph id="ph1">&amp;gt;</ph> Best Practices Configuration<ept id="p1">**</ept> to view the dialog.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">Visual Studio で、<bpt id="p1">**</bpt>Dynamics 365 <ph id="ph1">&amp;gt;</ph> ベスト プラクティス コンフィギュレーション<ept id="p1">**</ept> を選択してダイアログを表示します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="220">
          <source>A description of the artifacts to check.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">チェックするアーティファクトの説明。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="221">
          <source>In our case the value specifies that the rule should only be applied to classes.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ここでは、値は、ルールをクラスにのみ適用する必要があることを指定します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="222">
          <source>Feel free to modify this to your needs by using one of the other literals in the BestPracticeCheckerTargets enumeration.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">BestPracticeCheckerTargets 列挙に含まれる他のリテラルのいずれかを使用して、ユーザーのニーズに自由に変更してください。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="223">
          <source>We still need to fill out the pending TODO item, that is now reduced to instantiating the class that describes the diagnostic message and adding it to the set of diagnostics:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">保留中の TODO 項目に今もなお入力する必要があります。これは、現在は、診断メッセージを記述するクラスのインスタンス化と診断セットにそのメッセージを追加することに縮小されています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="224">
          <source>At this point you have a complete best practice rule, ready to provide value in your organization.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">この時点で完全なベスト プラクティス ルールが整っており、組織内の値を提供可能です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="225">
          <source>Go ahead and build it and fix any errors that may have crept in.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">先に進んで構築し、入り込んだ可能性のあるエラーを修正します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="226">
          <source>Metadata based Best Practice rules</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メタデータ ベースのベスト プラクティス ルール</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="227">
          <source>Until now we have been describing how to write rules that deal with code.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これまではコードを扱うルールの記述方法について説明してきました。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="228">
          <source>In this section we show how to author rules that apply to metadata, not code.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">このセクションでは、コードではなく、メタデータに適用されるルールを作成する方法を説明します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="229">
          <source>Classes that deal with metadata rules are derived from <bpt id="p1">**</bpt>BestPracticeMetadataChecker.<ept id="p1">**</ept></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">メタデータ ルールを扱うクラスは、<bpt id="p1">**</bpt>BestPracticeMetadataChecker<ept id="p1">**</ept> から派生しています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="230">
          <source>The derived instance receives an instance of the metadata describing the artifact that must be checked.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">派生インスタンスは、チェックする必要があるコンポーネントを記述するメタデータのインスタンスを受け取ります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="231">
          <source>You then use the APIs in the Microsoft.Dynamics.AX.Metadata.Metamodel to fetch further metadata as needed, and use LINQ queries over the metadata graphs.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次に、Microsoft.Dynamics.AX.Metadata.Metamodel で API を使用して、必要に応じて追加のメタデータをフェッチし、メタデータ グラフに対して LINQ クエリを使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="232">
          <source>The template for best practice checks contains a class performing metadata checks as well as a code based one we discussed in the previous section.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ベスト プラクティス チェック用のテンプレートには、前のセクションで説明したコード ベースのものと同様に、メタデータ チェックを実行するクラスが含まれています。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="233">
          <source>The mechanics involved in issuing diagnostic messages is the same as we covered above.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">診断メッセージの発行に関する仕組みは、上記で説明したものと同じです。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="234">
          <source>Install, run, and test your rule</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ルールのインストール、実行、テスト</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="235">
          <source>When your code compiles cleanly, a DLL will be created.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コードが正しくコンパイルされたら、DLLが作成されます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="236">
          <source>In order for the tooling to be able to pick up the new rule, this DLL must be installed before running it.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ツールが新しいルールを選択できるようにするためには、実行する前にこの DLL をインストールする必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="237">
          <source>Installing the DLL can be done in two ways:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">DLL のインストールには、次の 2 つの方法があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="238">
          <source>By using the button on the Best Practice configuration dialog.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ベスト プラクティス コンフィギュレーション ダイアログのボタンを使用します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="239">
          <source>Click the <bpt id="p1">**</bpt>Install extension...<ept id="p1">**</ept> button.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>拡張機能をインストールする...<ept id="p1">**</ept>ボタンをクリックします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="240">
          <source>You will be asked to point to the assembly file that contains your rule (i.e. the DLL generated when you build the rule).</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">自分のルール (つまり、ルール作成時に生成される DLL) を含むアセンブリ ファイルを指さすように求められます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="241">
          <source>Press OK, and the system will copy the DLL where it needs to be (see below).</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">[OK] を押すと、システムが必要な DLL をコピーします (以下を参照)。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="242">
          <source>By manually installing the DLL into the C:<ph id="ph1">\\</ph>Packages<ph id="ph2">\\</ph>bin<ph id="ph3">\\</ph>BPExtensions folder.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">DLL を C:<ph id="ph1">\\</ph>Packages<ph id="ph2">\\</ph>bin<ph id="ph3">\\</ph>BPExtensions フォルダーに手動でインストールします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="243">
          <source>If you want to debug your rule, you will find it useful to copy the .pdb file to the same directory as the assembly After the DLL has been deployed to the target directory, Visual Studio needs to be restarted.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ルールをデバッグする場合は、.pdb ファイルをアセンブリと同じディレクトリにコピーすると便利です。DLL をターゲット ディレクトリに展開したら、Visual Studio を再起動する必要があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="244">
          <source>After that, the rule is available for use.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">その後は、ルールは使用可能です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="245">
          <source>You may have to debug your rule to iron out any remaining kinks.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">残りの欠陥を解決するルールをデバッグすることが必要な場合があります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="246">
          <source>In fact stepping through your rule and inspecting the ASTs is valuable when you are learning the ropes.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">実際、ロープを学習している場合、ルールに従って進み、AST を検査することは重要です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="247">
          <source>To debug a rule you need to know that the best practice rule is actually executed by the xppAgent process; it is therefore not run within the context of VS itself.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ルールをデバッグするには、ベスト プラクティス ルールが実際に xppAgent プロセスによって実行されることを確認する必要があります。したがって、VS 自体のコンテキスト内では実行されません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="248">
          <source>Make sure you have selected <bpt id="p1">**</bpt>Run best practice checks<ept id="p1">**</ept> in the Visual Studio Options dialog, in the <bpt id="p2">**</bpt>Finance and Operations<ept id="p2">**</ept> page.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p2">**</bpt>Finance and Operations<ept id="p2">**</ept> ページの Visual Studio オプション ダイアログ ボックスで <bpt id="p1">**</bpt>推奨チェックの実行<ept id="p1">**</ept> を選択したことを確認します。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="249">
          <source>Otherwise, your check will not run.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">それ以外の場合、チェックは実行されません。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="250">
          <source>Set a breakpoint in the <bpt id="p1">**</bpt>VisitMethod<ept id="p1">**</ept> method, and then do a build of a model that has the new rule switched on as shown above for the Fleet management model.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm"><bpt id="p1">**</bpt>VisitMethod<ept id="p1">**</ept> メソッドでブレークポイントを設定し、上記のようにフリート管理モデルでオンに切り替えられた新しいルールを含むモデルのビルドを行います。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="251">
          <source>Attach your VS instance to the xppcAgent process.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">VS インスタンスを xppcAgent プロセスにアタッチします。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="252">
          <source>When you do a build your breakpoint will be hit, and you can start drilling into your code.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ビルドを実行すると、ブレークポイントにヒットして、コードへのドリルダウンを開始することができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="253">
          <source>You can see all the properties, the list of declarations and statements, and find out all the details about them.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">すべてのプロパティ、宣言およびステートメントの一覧を表示し、それらに関するすべての詳細を見つけることができます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="254">
          <source>Running rules in XppBp.exe</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">XppBp.exe でルールを実行</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="255">
          <source>As described above the best practice rules are often run as part of the build of a project from Visual Studio, but there is also a dedicated command line tool to run them.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">上記のとおりベスト プラクティス ルールは、Visual Studio のプロジェクトのビルドのパーツとして多くの場合実行されますが、それを実行する専用のコマンド ライン ツールもあります。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="256">
          <source>This is the xppbp.exe tool, and it is intended mainly for nightly build scenarios.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">これは xppbp.exe ツールで、主に夜間のビルド シナリオ用です。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="257">
          <source>Invoking it from the command line yields a useful overview of the command line switches and arguments.</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">コマンド ラインから起動することにより、有効なコマンド ラインのスイッチと引数の概要が得られます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="258">
          <source>Here are some useful examples:</source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">次にいくつか役に立つ例を挙げます。</target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="259">
          <source>Run BP on all forms in a module: <ph id="ph1">`xppbp -module:FleetManagement form:*`</ph></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">モジュール内のすべてのフォームで BP を実行します: <ph id="ph1">`xppbp -module:FleetManagement form:*`</ph></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="260">
          <source>Run BP on specific elements: <ph id="ph1">`xppbp -module:FleetManagement class:MyClass form:MyForm`</ph></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">特定の要素で BP を実行します: <ph id="ph1">`xppbp -module:FleetManagement class:MyClass form:MyForm`</ph></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="261">
          <source>Run BP on all items in the model (and only for this one model in the module): <ph id="ph1">`xppbp -module:FleetManagement -model:FleetManagement –all`</ph></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">モデル内のすべての項目で BP を実行します (モジュール内のこの 1 つのモデルに対してのみ): <ph id="ph1">`xppbp -module:FleetManagement -model:FleetManagement –all`</ph></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="262">
          <source>Run BP on all items in all models in the module: <ph id="ph1">`xppbp -module:FleetManagement –all`</ph></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">モジュール内のすべてのモデルのすべての品目で BP を実行します: <ph id="ph1">`xppbp -module:FleetManagement –all`</ph></target></trans-unit>
        <trans-unit xml:space="preserve" translate="yes" id="263">
          <source>Write the output to log files: <ph id="ph1">`xppbp -module:FleetManagement -all -xmllog=Log.xml -log=Log.txt`</ph></source>
        <target logoport:matchpercent="101" state="translated" state-qualifier="leveraged-tm">ログ ファイルに対する出力を記述します: <ph id="ph1">`xppbp -module:FleetManagement -all -xmllog=Log.xml -log=Log.txt`</ph></target></trans-unit>
      </group>
    </body>
  </file>
</xliff>