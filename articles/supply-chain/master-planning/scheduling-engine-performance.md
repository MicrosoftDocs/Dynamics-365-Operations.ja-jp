---
title: スケジューリング エンジンのパフォーマンスの改善
description: このトピックでは、スケジューリング エンジンに関する情報とパフォーマンスを向上させる方法について説明します。
author: ChristianRytt
manager: tfehr
ms.date: 09/03/2020
ms.topic: article
ms.prod: ''
ms.service: dynamics-ax-applications
ms.technology: ''
ms.search.form: ''
audience: Application User
ms.reviewer: kamaybac
ms.search.scope: Core, Operations
ms.custom: 19311
ms.assetid: 5ffb1486-2e08-4cdc-bd34-b47ae795ef0f
ms.search.region: Global
ms.search.industry: ''
ms.author: kamaybac
ms.search.validFrom: 2020-09-03
ms.dyn365.ops.version: ''
ms.openlocfilehash: 1c1b940754021956998fe27ba16020d4b16aedf1
ms.sourcegitcommit: 092ef6a45f515b38be2a4481abdbe7518a636f85
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/16/2020
ms.locfileid: "4432276"
---
# <a name="improve-scheduling-engine-performance"></a><span data-ttu-id="78a93-103">スケジューリング エンジンのパフォーマンスの改善</span><span class="sxs-lookup"><span data-stu-id="78a93-103">Improve scheduling engine performance</span></span>

[!include [banner](../includes/banner.md)]

<span data-ttu-id="78a93-104">リソースのスケジューリング エンジンは、計画およびリリース済製造オーダーの工順をスケジューリングする際に使用されます。</span><span class="sxs-lookup"><span data-stu-id="78a93-104">The resource scheduling engine is used when scheduling routes for planned and released production orders.</span></span> <span data-ttu-id="78a93-105">エンジンは最初、Dynamics AX 2012 の一部としてリリースされ、そのリリース以来、いくつかの改善がなされました。</span><span class="sxs-lookup"><span data-stu-id="78a93-105">The engine was originally released as part of Dynamics AX 2012 and has gone through several improvements since its release.</span></span>

<span data-ttu-id="78a93-106">[ジョブ ショップのスケジューリングの問題](https://en.wikipedia.org/wiki/Job_shop_scheduling)は、意思決定変数の数によって、ソリューションの時間が指数関数的に増加する、非常に複雑な組み合わせの問題です。</span><span class="sxs-lookup"><span data-stu-id="78a93-106">The [job shop scheduling problem](https://en.wikipedia.org/wiki/Job_shop_scheduling) is an extremely complex combinatorial problem where solution time grows exponentially with the number of decision variables.</span></span> <span data-ttu-id="78a93-107">多くの場合、顧客は、最新のハードウェア上であっても、適切な時間内に解決できないスケジューリングの問題が発生するような方法で、生産工順および関連するデータを設定します。</span><span class="sxs-lookup"><span data-stu-id="78a93-107">Oftentimes, customers set up production routes and related data in a way that results in a scheduling problem that can't be solved in reasonable time even on the most modern hardware.</span></span> <span data-ttu-id="78a93-108">このトピックでは、スケジューリング エンジンと、特定の設定がパフォーマンスにどのように影響するかについて説明します。</span><span class="sxs-lookup"><span data-stu-id="78a93-108">This topic will help you understand the scheduling engine and how a specific setup can have influence on the performance.</span></span>

<span data-ttu-id="78a93-109">スケジューリングのパフォーマンスを向上させるために、一般的なガイドラインでは、エンジンで解決する必要がある問題の複雑さを軽減することが勧められています。</span><span class="sxs-lookup"><span data-stu-id="78a93-109">When it comes to improving the performance of the scheduling, general guidelines recommend reducing the complexity of the problem the engine needs to solve.</span></span> <span data-ttu-id="78a93-110">パフォーマンスに影響を与える主な要因には、次のようなものがあります。</span><span class="sxs-lookup"><span data-stu-id="78a93-110">Some of the main factors that can affect performance include:</span></span>

- <span data-ttu-id="78a93-111">多数の工程を含む工順</span><span class="sxs-lookup"><span data-stu-id="78a93-111">Routes with many operations</span></span>
- <span data-ttu-id="78a93-112">並行行程での工順</span><span class="sxs-lookup"><span data-stu-id="78a93-112">Routes with parallel operations</span></span>
- <span data-ttu-id="78a93-113">リソースの数量が 1 より高い工程</span><span class="sxs-lookup"><span data-stu-id="78a93-113">Operations with quantity of resources higher than one</span></span>
- <span data-ttu-id="78a93-114">適用可能な多くのリソースを使用する工程</span><span class="sxs-lookup"><span data-stu-id="78a93-114">Operations with many applicable resources</span></span>
- <span data-ttu-id="78a93-115">ハード リンクの使用</span><span class="sxs-lookup"><span data-stu-id="78a93-115">Use of hard links</span></span>
- <span data-ttu-id="78a93-116">有限能力の使用</span><span class="sxs-lookup"><span data-stu-id="78a93-116">Use of finite capacity</span></span>
- <span data-ttu-id="78a93-117">使用される異なるカレンダーの数</span><span class="sxs-lookup"><span data-stu-id="78a93-117">The number of different calendars used</span></span>
- <span data-ttu-id="78a93-118">カレンダーの 1 日あたりの作業タイム スロット数</span><span class="sxs-lookup"><span data-stu-id="78a93-118">The number of working time slots per day in the calendar</span></span>
- <span data-ttu-id="78a93-119">工順の合計期間</span><span class="sxs-lookup"><span data-stu-id="78a93-119">Total duration of the route</span></span>
- <span data-ttu-id="78a93-120">複数のスケジューリング エンジンの並列実行</span><span class="sxs-lookup"><span data-stu-id="78a93-120">Running multiple scheduling engines in parallel</span></span>

## <a name="overview-of-basic-scheduling-flow"></a><span data-ttu-id="78a93-121">基本的なスケジューリング フローの概要</span><span class="sxs-lookup"><span data-stu-id="78a93-121">Overview of basic scheduling flow</span></span>

<span data-ttu-id="78a93-122">特定の設定がどのようにパフォーマンスに影響するかを理解するには、プロセス フロー (エンジン内部と、それを取り囲む X++ コードの両方) を理解しておくことが重要です。</span><span class="sxs-lookup"><span data-stu-id="78a93-122">To understand how a given setup can affect performance, it is important to understand something about how the process flows, both inside the engine and in the X++ code that surrounds it.</span></span>

<span data-ttu-id="78a93-123">注文のスケジューリングの基本プロセスは、次の 3 つの主要なステップで構成されています。</span><span class="sxs-lookup"><span data-stu-id="78a93-123">The basic process of scheduling an order consists of three main steps:</span></span>

- <span data-ttu-id="78a93-124">**データの読み込み** – ここでは、X++ データ モデルが、ジョブと制約という形でエンジンの内部データ モデルに変換されます。</span><span class="sxs-lookup"><span data-stu-id="78a93-124">**Loading data** – Here, the X++ data models are transformed into the engine's internal data model in the form of jobs and constraints.</span></span>
- <span data-ttu-id="78a93-125">**スケジューリング** – 特定のモデルと制約を処理し、結果を生成するスケジューリングの主要なソースです。</span><span class="sxs-lookup"><span data-stu-id="78a93-125">**Scheduling** – This is the main source for scheduling that processes the given model and constraints, and generates a result.</span></span> <span data-ttu-id="78a93-126">このプロセス中に、エンジンは、必要に応じて、作業時間の情報と、X++ の既存の確保済能力を要求します。</span><span class="sxs-lookup"><span data-stu-id="78a93-126">During this process, the engine will request working time information and existing capacity reservations from X++ as needed.</span></span>
- <span data-ttu-id="78a93-127">**データの保存** – エンジンは、確保済能力を保存して、ジョブ/工程/注文の開始時刻と終了時刻を更新するために、X++ コードで処理された、ジョブの確保済能力スロットの形式になります。</span><span class="sxs-lookup"><span data-stu-id="78a93-127">**Save data** – The engine result in the form of job capacity reservation slots is processed by X++ code to save capacity reservations and update the start and end times of the jobs/operation/order.</span></span>

## <a name="load-data-into-the-engine"></a><span data-ttu-id="78a93-128">エンジンへのデータの読み込み</span><span class="sxs-lookup"><span data-stu-id="78a93-128">Load data into the engine</span></span>

<span data-ttu-id="78a93-129">スケジューリング エンジンは、データのさまざまなソースを処理できる汎用エンジンとして構築されているため、Supply Chain Management データベースよりも抽象的なデータ モデルが含まれています。</span><span class="sxs-lookup"><span data-stu-id="78a93-129">The scheduling engine has a more abstract data model than the Supply Chain Management database because it has been built as a generic engine that can handle different sources of data.</span></span> <span data-ttu-id="78a93-130">工順、二次工程、および実行時間の概念を、エンジンが公開する汎用ジョブおよび制約モデルに「変換」する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-130">The concepts of route, secondary operations, and run time need to be "translated" into the generic job and constraint model that the engine exposes.</span></span> <span data-ttu-id="78a93-131">モデルを構築するためのロジックには、膨大な量のビジネス ロジックが含まれており、ソース データによって異なります。</span><span class="sxs-lookup"><span data-stu-id="78a93-131">The logic for building the model has a significant amount of business logic to it and is different depending on the source data.</span></span> <span data-ttu-id="78a93-132">担当の X++ クラスは、`WrkCtrScheduler` です。これは、計画製造オーダー、リリース済製造オーダー、およびプロジェクト予測の派生クラスを備えています。</span><span class="sxs-lookup"><span data-stu-id="78a93-132">The responsible X++ class is `WrkCtrScheduler` and it has derived classes for planned production orders, released production orders, and project forecasts.</span></span>

<span data-ttu-id="78a93-133">例として、次の表と画像に示すように、比較的単純なルートについて検討します。</span><span class="sxs-lookup"><span data-stu-id="78a93-133">As an example, consider a route shown in the following table and image, which seems relatively simple.</span></span>

| <span data-ttu-id="78a93-134">工程</span><span class="sxs-lookup"><span data-stu-id="78a93-134">Oper.</span></span> <span data-ttu-id="78a93-135">No.</span><span class="sxs-lookup"><span data-stu-id="78a93-135">No.</span></span> | <span data-ttu-id="78a93-136">優先順位</span><span class="sxs-lookup"><span data-stu-id="78a93-136">Priority</span></span> | <span data-ttu-id="78a93-137">段取り時間</span><span class="sxs-lookup"><span data-stu-id="78a93-137">Setup time</span></span> | <span data-ttu-id="78a93-138">実行時間</span><span class="sxs-lookup"><span data-stu-id="78a93-138">Run time</span></span> | <span data-ttu-id="78a93-139">作業後待ち時間</span><span class="sxs-lookup"><span data-stu-id="78a93-139">Queue time after</span></span> | <span data-ttu-id="78a93-140">リソースの数量</span><span class="sxs-lookup"><span data-stu-id="78a93-140">Quantity of resources</span></span> | <span data-ttu-id="78a93-141">次</span><span class="sxs-lookup"><span data-stu-id="78a93-141">Next</span></span> |
| --- | --- | --- | --- | --- | --- | --- |
| <span data-ttu-id="78a93-142">10</span><span class="sxs-lookup"><span data-stu-id="78a93-142">10</span></span> | <span data-ttu-id="78a93-143">基本</span><span class="sxs-lookup"><span data-stu-id="78a93-143">Primary</span></span> | <span data-ttu-id="78a93-144">1.00</span><span class="sxs-lookup"><span data-stu-id="78a93-144">1.00</span></span> | <span data-ttu-id="78a93-145">2.00</span><span class="sxs-lookup"><span data-stu-id="78a93-145">2.00</span></span> | | <span data-ttu-id="78a93-146">1</span><span class="sxs-lookup"><span data-stu-id="78a93-146">1</span></span> | <span data-ttu-id="78a93-147">20</span><span class="sxs-lookup"><span data-stu-id="78a93-147">20</span></span> |
| <span data-ttu-id="78a93-148">10</span><span class="sxs-lookup"><span data-stu-id="78a93-148">10</span></span> | <span data-ttu-id="78a93-149">二次&nbsp;1</span><span class="sxs-lookup"><span data-stu-id="78a93-149">Secondary&nbsp;1</span></span> | | | | <span data-ttu-id="78a93-150">1</span><span class="sxs-lookup"><span data-stu-id="78a93-150">1</span></span> | <span data-ttu-id="78a93-151">20</span><span class="sxs-lookup"><span data-stu-id="78a93-151">20</span></span> |
| <span data-ttu-id="78a93-152">20</span><span class="sxs-lookup"><span data-stu-id="78a93-152">20</span></span> | <span data-ttu-id="78a93-153">基本</span><span class="sxs-lookup"><span data-stu-id="78a93-153">Primary</span></span> | | <span data-ttu-id="78a93-154">3.00</span><span class="sxs-lookup"><span data-stu-id="78a93-154">3.00</span></span> | <span data-ttu-id="78a93-155">1.00</span><span class="sxs-lookup"><span data-stu-id="78a93-155">1.00</span></span> | <span data-ttu-id="78a93-156">3</span><span class="sxs-lookup"><span data-stu-id="78a93-156">3</span></span> | <span data-ttu-id="78a93-157">0</span><span class="sxs-lookup"><span data-stu-id="78a93-157">0</span></span> |

<span data-ttu-id="78a93-158">![工順ダイアグラムの例](media/scheduling-engine-route.png "工順ダイアグラムの例")</span><span class="sxs-lookup"><span data-stu-id="78a93-158">![Example rout diagram](media/scheduling-engine-route.png "Example rout diagram")</span></span>

<span data-ttu-id="78a93-159">これをエンジンに送信すると、次の図に示すように 8 つのジョブに分割されます (画像を選択して拡大します)。</span><span class="sxs-lookup"><span data-stu-id="78a93-159">When sending this to the engine, it is split out into eight jobs, as shown in the following illustration (select the image to enlarge it).</span></span>

<span data-ttu-id="78a93-160">[![エンジン ジョブのスケジューリング](media/scheduling-engine-jobs.png "エンジン ジョブのスケジューリング")](media/scheduling-engine-jobs-large.png)</span><span class="sxs-lookup"><span data-stu-id="78a93-160">[![Scheduling engine jobs](media/scheduling-engine-jobs.png "Scheduling engine jobs")](media/scheduling-engine-jobs-large.png)</span></span>

<span data-ttu-id="78a93-161">2 つのジョブ間の標準リンクは、`FinishStart` です。1 つのジョブの終了時刻を別のジョブの開始時刻よりも前にする必要があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="78a93-161">The standard link between two jobs is `FinishStart`, meaning that the end time of one job must be before the start time of another job.</span></span> <span data-ttu-id="78a93-162">この設定は、後でプロセスを実行する同じリソースによって実行される必要があるため、これらには `OnSameResource` 制約があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-162">Because the setup must be performed by the same resource that will later do the process, there are `OnSameResource` constraints between them.</span></span> <span data-ttu-id="78a93-163">10 の基本工程と二次工程のジョブには、ジョブが両方同時に開始および終了する必要があることを意味する `StartStart` および `FinishFinish` リンクがあり、基本と二次で同じリソースを使用できないようにする `NotOnSameResource` 制約があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-163">Between the jobs for primary and secondary operation for 10, there are `StartStart` and `FinishFinish` links, which means that the jobs must both start and end at the same time, and there are `NotOnSameResource` constraints, which will prevent the same resource for primary and secondary.</span></span>

<span data-ttu-id="78a93-164">リソースの数量が 3 に設定されている工程 20 では、プロセス ジョブは 3 つの異なるジョブに分割され、すべてのジョブをまったく同時に実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-164">For operation 20, where the quantity of resources has been set to 3, the process job has been split into three distinct jobs where all the jobs must run at the exact same time.</span></span>
<span data-ttu-id="78a93-165">この場合、後のキューに対するジョブは 1 つだけのため、工順グループは後のキューのために能力を確保しないように設定されます。</span><span class="sxs-lookup"><span data-stu-id="78a93-165">In this case, the route group has been set up to not reserve capacity for queue after times, which is why there is only a single job for the queue after.</span></span>

<span data-ttu-id="78a93-166">スケジューリング エンジンはジョブの概念だけを理解し、工程の概念はありません。</span><span class="sxs-lookup"><span data-stu-id="78a93-166">The scheduling engine only understands the concepts of jobs and has no notion of operations.</span></span> <span data-ttu-id="78a93-167">つまり、工程のスケジューリングを実行する場合、工程はジョブに分割されますが、それらはデータベースには保持されません。</span><span class="sxs-lookup"><span data-stu-id="78a93-167">This means that when doing operation scheduling, the operations are also split into jobs, although these will not be persisted in the database.</span></span>

<span data-ttu-id="78a93-168">各ジョブについて、ジョブの能力要件 (必要な秒数) も定義します。</span><span class="sxs-lookup"><span data-stu-id="78a93-168">For each job, we will also define what the job capacity requirement is (the number of seconds required).</span></span> <span data-ttu-id="78a93-169">リソース要件の定義方法に応じて、各ジョブについて、ジョブを実行する可能性があるすべてのリソースの一覧と、特定のリソースに対して必要な容量を送信することもできます。</span><span class="sxs-lookup"><span data-stu-id="78a93-169">Depending on how the resource requirements have been defined, we may also, for each job, send a list of all the potential applicable resources that the job could run on and what the capacity requirement is for that specific resource.</span></span> <span data-ttu-id="78a93-170">モデルの作成時に適用可能なリソースの一覧が送信されますが、エンジンでは、リソース割り当てがジョブ期間全体に対して実際に有効であることを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-170">Even though the list of applicable resources is sent when building the model, the engine will still need to ensure that the resource assignment is actually valid for the entire job duration.</span></span>

## <a name="scheduling-engine-internals"></a><span data-ttu-id="78a93-171">スケジューリング エンジンの内部</span><span class="sxs-lookup"><span data-stu-id="78a93-171">Scheduling engine internals</span></span>

### <a name="scheduling-engine-interface"></a><span data-ttu-id="78a93-172">スケジューリング エンジンのインターフェイス</span><span class="sxs-lookup"><span data-stu-id="78a93-172">Scheduling engine interface</span></span>

<span data-ttu-id="78a93-173">エンジンが内部でどのように機能するかを把握するために、外部に公開する機能について確認することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78a93-173">To get an idea of how the engine works internally, it is best to look at the functionality it exposes externally.</span></span> <span data-ttu-id="78a93-174">X++ で、主なインターフェイスは、`WrkCtrSchedulerEngineInterface` です。</span><span class="sxs-lookup"><span data-stu-id="78a93-174">In X++, the main interface is `WrkCtrSchedulerEngineInterface`.</span></span> <span data-ttu-id="78a93-175">次のサブセクションで説明する方法があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-175">It has the methods described in the following subsections.</span></span>

#### <a name="general-engine"></a><span data-ttu-id="78a93-176">一般的なエンジン</span><span class="sxs-lookup"><span data-stu-id="78a93-176">General engine</span></span>

| <span data-ttu-id="78a93-177">**メソッド**</span><span class="sxs-lookup"><span data-stu-id="78a93-177">**Method**</span></span> | <span data-ttu-id="78a93-178">**目的**</span><span class="sxs-lookup"><span data-stu-id="78a93-178">**Purpose**</span></span> |
| --- | --- |
| `run` | <span data-ttu-id="78a93-179">読み込まれたジョブをすべてスケジュールし、エラー コードを返します。</span><span class="sxs-lookup"><span data-stu-id="78a93-179">Schedules all loaded jobs and returns the error code.</span></span> |
| `getJobSchedulingSequenceResult` | <span data-ttu-id="78a93-180">スケジュールの結果と、特定のジョブによって識別されたシーケンスの最初のエラー ジョブを取得します。</span><span class="sxs-lookup"><span data-stu-id="78a93-180">Gets the scheduling result and the first error job for the sequence identified by a specific job.</span></span> |
| `validateJobCapacityReservations` | <span data-ttu-id="78a93-181">エンジンによって保存されているすべてのジョブの確保済能力を検証します。</span><span class="sxs-lookup"><span data-stu-id="78a93-181">Validates the capacity reservations for all the jobs stored by the engine.</span></span> |
| `setReservationsTimeStamp` | <span data-ttu-id="78a93-182">エンジンのキャッシュにあるスケジュールされたジョブについて、すべての新しい確保済能力に設定されたエンジンにタイムスタンプを送信します。</span><span class="sxs-lookup"><span data-stu-id="78a93-182">Sends a timestamp to the engine set on all new capacity reservations for the scheduled jobs in the cache of the engine.</span></span> |
| `addPropertyToGroupAggregation` | <span data-ttu-id="78a93-183">能力の集計時に使用されるプロパティのセットに、プロパティの接頭語を追加します。</span><span class="sxs-lookup"><span data-stu-id="78a93-183">Adds a property prefix to the set of properties used when capacity is aggregated.</span></span> |
| `addResource` | <span data-ttu-id="78a93-184">スケジューリング エンジンのリソース プールにリソースを追加します。</span><span class="sxs-lookup"><span data-stu-id="78a93-184">Adds a resource to the scheduling engine resource pool.</span></span> |
| `addResourceGroup` | <span data-ttu-id="78a93-185">スケジューリング エンジンのリソース グループ プールにリソース グループを追加します。</span><span class="sxs-lookup"><span data-stu-id="78a93-185">Adds a resource group to the scheduling engine resource group pool.</span></span> |
| `addResourceGroupMembership` | <span data-ttu-id="78a93-186">リソース グループにリソースをメンバーとして追加します。</span><span class="sxs-lookup"><span data-stu-id="78a93-186">Adds a resource as a member to a resource group.</span></span> |
| `addOptimizationGoal` | <span data-ttu-id="78a93-187">スケジューリングの最適化目標 (期間または優先順位) を追加します。</span><span class="sxs-lookup"><span data-stu-id="78a93-187">Adds a scheduling optimization goal (duration or priority).</span></span> |

#### <a name="individual-jobs"></a><span data-ttu-id="78a93-188">個別のジョブ</span><span class="sxs-lookup"><span data-stu-id="78a93-188">Individual jobs</span></span>

| <span data-ttu-id="78a93-189">**メソッド**</span><span class="sxs-lookup"><span data-stu-id="78a93-189">**Method**</span></span> | <span data-ttu-id="78a93-190">**目的**</span><span class="sxs-lookup"><span data-stu-id="78a93-190">**Purpose**</span></span> |
| --- | --- |
| `addJobInfo` | <span data-ttu-id="78a93-191">スケジューリングする必要があるジョブについてエンジンに通知する、ジョブ情報レコードを追加します。</span><span class="sxs-lookup"><span data-stu-id="78a93-191">Adds a job information record that informs the engine about a job that should be scheduled.</span></span> |
| `addConstraintJobEndsAt` | <span data-ttu-id="78a93-192">指定した日時にジョブを終了する制約を追加します。</span><span class="sxs-lookup"><span data-stu-id="78a93-192">Adds a constraint that a job should end at a specified date and time.</span></span> |
| `addConstraintJobStartsAt` | <span data-ttu-id="78a93-193">指定した日時にジョブを開始する制約を追加します。</span><span class="sxs-lookup"><span data-stu-id="78a93-193">Adds a constraint that a job should start at a specified date and time.</span></span> |
| `addConstraintMaxJobDays` | <span data-ttu-id="78a93-194">ジョブが指定された最大日数にまたがることができるように制約を定義します。</span><span class="sxs-lookup"><span data-stu-id="78a93-194">Defines the constraint that a job can span over a specified maximal number of days.</span></span> |
| `addConstraintResourceRequirement` | <span data-ttu-id="78a93-195">特定のリソースでジョブをスケジューリングする必要があるようにする制約を追加します。</span><span class="sxs-lookup"><span data-stu-id="78a93-195">Adds the constraint that the job must be scheduled on a specific resource.</span></span> |
| `addJobBindPriority` | <span data-ttu-id="78a93-196">(ジョブ、制約レベル) ペアのジョブ バインド優先順位を追加します。</span><span class="sxs-lookup"><span data-stu-id="78a93-196">Adds a job bind priority for a (job, constraint level) pair.</span></span> <span data-ttu-id="78a93-197">優先順位の値が高いことは、ジョブ変数が先にバインドされることを意味します。</span><span class="sxs-lookup"><span data-stu-id="78a93-197">A higher priority value means the job variables will be bound earlier.</span></span> <span data-ttu-id="78a93-198">このジョブは、同じシーケンスの優先順位の値が低いジョブよりも先に処理されます。</span><span class="sxs-lookup"><span data-stu-id="78a93-198">The job will be processed before jobs with lower priority value in the same sequence.</span></span> |
| `addJobCapacity` | <span data-ttu-id="78a93-199">ジョブが実行されるリソースに依存しないジョブ (必要なジョブ ランタイムなど) の最大能力負荷の情報を追加します。</span><span class="sxs-lookup"><span data-stu-id="78a93-199">Adds capacity load information for a job (like the required job runtime) independent on which resource the job runs on.</span></span> |
| `addJobResourceCapacity` | <span data-ttu-id="78a93-200">ジョブを実行するために使用される可能性がある一連のリソースにリソースを追加し、そのリソースでの実行時に必要な能力を規定します。</span><span class="sxs-lookup"><span data-stu-id="78a93-200">Adds a resource to the set of resources that may be used to perform a job, and states the capacity required when running on that resource.</span></span> |
| `addJobGoal` | <span data-ttu-id="78a93-201">特定の制約レベルのジョブの目標情報 (最も早い終了時刻または最も遅い開始時刻) を追加します。</span><span class="sxs-lookup"><span data-stu-id="78a93-201">Adds job goal information for a specific constraint level (earliest end time or latest start time).</span></span> |
| `addJobResourcePriority` | <span data-ttu-id="78a93-202">リソースにジョブがスケジュールされている場合に使用する優先順位を追加します。</span><span class="sxs-lookup"><span data-stu-id="78a93-202">Adds the priority to use when a job is scheduled on a resource.</span></span> |
| `addJobResourceRuntime` | <span data-ttu-id="78a93-203">ジョブのスケジューリングが行われるリソースに依存するジョブ時間を指定します。</span><span class="sxs-lookup"><span data-stu-id="78a93-203">Specifies a job time that is dependent of the resource the job will be scheduled on.</span></span> |
| `addJobRuntime` | <span data-ttu-id="78a93-204">ジョブのスケジューリングが行われるリソースに依存しないジョブ時間を指定します。</span><span class="sxs-lookup"><span data-stu-id="78a93-204">Specifies a job time that is independent of the resource on which the job will be scheduled.</span></span> |
| `scheduleJobOnResourceGroup` | <span data-ttu-id="78a93-205">リソース グループ レベルのスケジューリングのジョブをマークします。</span><span class="sxs-lookup"><span data-stu-id="78a93-205">Marks a job for scheduling on the resource group level.</span></span> |
| `setJobResourcePreemptionAllowed` | <span data-ttu-id="78a93-206">リソースのジョブに対して強制排除を許可するかどうかを設定します (連続していない能力スロットのジョブのスケジュールをエンジンが許可されている場合)。</span><span class="sxs-lookup"><span data-stu-id="78a93-206">Sets whether preemption is allowed for a job on a resource (if engine is allowed to schedule the job in noncontiguous capacity slots).</span></span> |
| `setRequiredNumberOfResources` | <span data-ttu-id="78a93-207">ジョブをスケジュールするために必要なリソースの数を設定します (工程のスケジューリングに対してのみ)。</span><span class="sxs-lookup"><span data-stu-id="78a93-207">Sets the number of resources required to schedule a job (only for operations scheduling).</span></span> |

#### <a name="constraints-between-jobs"></a><span data-ttu-id="78a93-208">ジョブ間の制約</span><span class="sxs-lookup"><span data-stu-id="78a93-208">Constraints between jobs</span></span>

| <span data-ttu-id="78a93-209">**メソッド**</span><span class="sxs-lookup"><span data-stu-id="78a93-209">**Method**</span></span> | <span data-ttu-id="78a93-210">**目的**</span><span class="sxs-lookup"><span data-stu-id="78a93-210">**Purpose**</span></span> |
| --- | --- |
| `addJobLink` | <span data-ttu-id="78a93-211">2 つのジョブ間にリンク (完了 \> 開始など) を追加します。</span><span class="sxs-lookup"><span data-stu-id="78a93-211">Adds a link (such as finish\>start) between two jobs.</span></span> |
| `addConstraintEndsDelayed` | <span data-ttu-id="78a93-212">別のジョブの終了に一定の遅延時間を加えたものより前に、ジョブが終了することができないようにする制約を定義します。</span><span class="sxs-lookup"><span data-stu-id="78a93-212">Defines the constraint that a job cannot end before another jobs end plus some delay time.</span></span> |
| `addConstraintJobListWorkingTimeIntersect` | <span data-ttu-id="78a93-213">ジョブに予約された能力スロットが、ジョブによって使用される 2 つのリソースの重なりあう作業時間にある必要があるようにする制約を追加します。</span><span class="sxs-lookup"><span data-stu-id="78a93-213">Adds a constraint that the capacity slots reserved for the jobs must be on the intersecting working times for the two resources used by the jobs.</span></span> |
| `addConstraintJobOverlap` | <span data-ttu-id="78a93-214">最初のリソースが処理を終了しないうちに、2 つ目のリソースが処理を開始できるようにするため、特定の品目の数量が 2 つのリソース間で移動するときのジョブの順序付けを定義する制約を追加します。</span><span class="sxs-lookup"><span data-stu-id="78a93-214">Add a constraint that defines how jobs are sequenced when a given quantity of an item can be moved between two resources while the first resource is still not finished processing, so that the second resource can start processing.</span></span> |
| `addConstraintNotOnSameResource` | <span data-ttu-id="78a93-215">2 つのジョブを同じリソースに対してスケジュールできないようにする制約を追加します。</span><span class="sxs-lookup"><span data-stu-id="78a93-215">Adds a constraint that two jobs should not be scheduled on the same resource.</span></span> |
| `addConstraintOnSameResource` | <span data-ttu-id="78a93-216">2 つのジョブが必ず同じリソースを使用するようにする制約を追加します。</span><span class="sxs-lookup"><span data-stu-id="78a93-216">Adds a constraint that two jobs must be using the same resource.</span></span> |
| `addJobSameReservations` | <span data-ttu-id="78a93-217">ジョブが、基本ジョブと同じタイム スロットに対して確保済能力を持つ必要があるようにする制約を追加します。</span><span class="sxs-lookup"><span data-stu-id="78a93-217">Adds a constraint that a job must end up having capacity reservations for the same time slots as the primary job.</span></span> |
| `setPrimaryParallelJob` | <span data-ttu-id="78a93-218">一連の並列ジョブにおいて、どのジョブが基本ジョブであるかについての情報を追加します。</span><span class="sxs-lookup"><span data-stu-id="78a93-218">Adds information about what job is the primary job in a set of parallel jobs.</span></span> |

### <a name="solver"></a><span data-ttu-id="78a93-219">ソルバー</span><span class="sxs-lookup"><span data-stu-id="78a93-219">Solver</span></span>

<span data-ttu-id="78a93-220">エンジン自体は、基本的に、カスタム ヒューリスティックを追加するための特殊な制約ソルバーです。</span><span class="sxs-lookup"><span data-stu-id="78a93-220">The engine itself is essentially a specialized constraint solver with custom heuristics added.</span></span> <span data-ttu-id="78a93-221">ソルバーは、変数と制約という 2 つの主要な要素に基づいています。</span><span class="sxs-lookup"><span data-stu-id="78a93-221">The solver is based on two main elements: variables and constraints.</span></span>

#### <a name="variable"></a><span data-ttu-id="78a93-222">変数</span><span class="sxs-lookup"><span data-stu-id="78a93-222">Variable</span></span>

<span data-ttu-id="78a93-223">変数は、使用可能な値のドメインを表します。</span><span class="sxs-lookup"><span data-stu-id="78a93-223">A variable represents a domain of possible values.</span></span> <span data-ttu-id="78a93-224">スケジューリング エンジンには 2 つのタイプの変数があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-224">Scheduling engine has two types of variables:</span></span>

- <span data-ttu-id="78a93-225">**DateTime 変数** - すべての日付と時間のドメインがあり、変数の時間の上限と下限を互いに近づけることによってドメインを制限することができます。</span><span class="sxs-lookup"><span data-stu-id="78a93-225">**DateTime variable** - Has a domain of all dates and times, and the domain can be restricted by moving the lower and upper bound for the time of the variable closer to each other.</span></span>
- <span data-ttu-id="78a93-226">**リソース変数** - 適用可能なリソースのドメインがあり、一覧からリソースを除外することによってドメインを制限できます。</span><span class="sxs-lookup"><span data-stu-id="78a93-226">**Resource variable** - Has a domain of applicable resources, and the domain can be restricted by eliminating resources from the list.</span></span>

#### <a name="constraint"></a><span data-ttu-id="78a93-227">制約</span><span class="sxs-lookup"><span data-stu-id="78a93-227">Constraint</span></span>

<span data-ttu-id="78a93-228">制約は、ドメインを制限することによって変数に対して機能しますが、変数によって異なり、変数が変更されたときに有効になります。</span><span class="sxs-lookup"><span data-stu-id="78a93-228">A constraint acts on variables by restricting their domains, but it also depends on variables so it gets activated when variables change.</span></span> <span data-ttu-id="78a93-229">「制約の反映」のプロセスは、制約が主な機能を実行し、成功したときにレポートを主要なロジックに戻す場合に行われます。</span><span class="sxs-lookup"><span data-stu-id="78a93-229">The process of "constraint propagation" is when a constraint performs its main function and reports back to the main logic if successful.</span></span>

<span data-ttu-id="78a93-230">変数は、それ以上制約を受けることができない場合、バインドされていると見なされます。これは、DateTime 変数の場合には上限と下限が同じであること、リソース変数の場合には適用可能なリソースが 1 つしかないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="78a93-230">A variable is considered bound when it can't be restricted further, which for DateTime variable means that upper and lower bound is the same, and for the Resource variable that it has only a single applicable resource.</span></span> <span data-ttu-id="78a93-231">すべての変数がバインドされると、ソリューションが見つかります。</span><span class="sxs-lookup"><span data-stu-id="78a93-231">When all variables are bound, a solution is found.</span></span>

### <a name="constraint-levels"></a><span data-ttu-id="78a93-232">制約レベル</span><span class="sxs-lookup"><span data-stu-id="78a93-232">Constraint levels</span></span>

<span data-ttu-id="78a93-233">原材料の必要量の計画 (MRP) の補充フェーズの一部としてスケジューリングを実行すると、注文は要求日から逆算してスケジューリングされます。</span><span class="sxs-lookup"><span data-stu-id="78a93-233">When scheduling is executed as part of the material requirements planning (MRP) coverage phase, the orders will be scheduled backward from requirement date.</span></span> <span data-ttu-id="78a93-234">ただし、当日以降に開始され、要求日よりも前に終了するスケジュールが見つからない場合は、スケジューリング指示が今日以降に変更されます。</span><span class="sxs-lookup"><span data-stu-id="78a93-234">However, if it is not possible to find a schedule that starts today or later and ends before the requirement date, then the scheduling direction will change to forward from today.</span></span>

<span data-ttu-id="78a93-235">この主要なビジネス ルールは、制約をレベルで体系化することによって処理されます。</span><span class="sxs-lookup"><span data-stu-id="78a93-235">This main business rule is handled by organizing the constraints in levels.</span></span> <span data-ttu-id="78a93-236">最上位レベルでの制約の使用時にソリューションが見つからなかった場合、そのレベルの制約はすべて削除され、下位レベルのテストが試行されます。</span><span class="sxs-lookup"><span data-stu-id="78a93-236">If no solution is found when using the constraints on the highest level, then the constraints on that level are all dropped, and the lower level is tried.</span></span> <span data-ttu-id="78a93-237">実践においては、バックワード スケジューリングに対して、モデルには、最も遅い開始時刻のジョブの目標があり、最大の終了時刻制約 (要求日) が指定されたレベル 1 と、最も早い終了時刻のジョブの目標があり、当日の最小の開始時刻制約が指定されたレベル 0 が含まれます。</span><span class="sxs-lookup"><span data-stu-id="78a93-237">In praxis, this means that for backward scheduling the model will contain a level 1 with job goals of latest start time given a maximum end time constraint (the requirement date), and a level 0 with job goals of earliest end time and given a minimum start time constraint of today.</span></span>

### <a name="algorithm"></a><span data-ttu-id="78a93-238">アルゴリズム</span><span class="sxs-lookup"><span data-stu-id="78a93-238">Algorithm</span></span>

<span data-ttu-id="78a93-239">エンジン アルゴリズムの主要なステップは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="78a93-239">The main steps of the engine algorithm are:</span></span>

1. <span data-ttu-id="78a93-240">個別に解決できるシーケンス (ジョブ チェーン) を検索します。</span><span class="sxs-lookup"><span data-stu-id="78a93-240">Find sequences (job chains) which can be solved separately.</span></span>
1. <span data-ttu-id="78a93-241">制約レベルが最も高いシーケンスの最初のソリューションを見つけます。</span><span class="sxs-lookup"><span data-stu-id="78a93-241">Try to find an initial solution for the sequence for the highest constraint level.</span></span>
    1. <span data-ttu-id="78a93-242">ジョブの目標と優先順位に基づいて、シーケンス内のジョブを並べ替えます。開始ジョブが見つかる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-242">Sort the jobs in the sequence based on job goal and priorities, such that a start job can be found.</span></span>
    1. <span data-ttu-id="78a93-243">次のシーケンスでジョブをループします。</span><span class="sxs-lookup"><span data-stu-id="78a93-243">Loop the jobs in the following sequence:</span></span>
        1. <span data-ttu-id="78a93-244">反映する必要があるすべての制約を検索し、反映を実行します。</span><span class="sxs-lookup"><span data-stu-id="78a93-244">Find all constraints that need to be propagated and run propagation.</span></span>
        1. <span data-ttu-id="78a93-245">ジョブのすべての変数がバインドされている場合、そのジョブのソリューションは見つかります。</span><span class="sxs-lookup"><span data-stu-id="78a93-245">If all variables for the job have been bound, then a solution for that job has been found.</span></span>
        1. <span data-ttu-id="78a93-246">制約に違反せずにいずれかの変数をバインドできなかった場合、その変数のバインディングをロールバックし、ドメインの異なる値を試行して (リソース変数の場合)、制約の反映を再実行します。</span><span class="sxs-lookup"><span data-stu-id="78a93-246">If one of the variables could not be bound without violating the constraints, then roll back the variable binding, try a different value in the domain (for resource variable), and rerun the constraint propagation.</span></span>
1. <span data-ttu-id="78a93-247">ソリューションが見つからなかった場合は、現在の制約レベルのすべての制約が削除され、制約レベルが引き下げられ (下位のレベルが利用可能な場合)、新しい一連の制約を使用してソリューションの検索が再試行されます。</span><span class="sxs-lookup"><span data-stu-id="78a93-247">If no solution was found, then all constraints on the current constraint level is removed, the constraint level lowered (if any lower levels are available) and solution search retried with the new set of constraint.</span></span>
1. <span data-ttu-id="78a93-248">実行可能なソリューションが見つかった場合は、最適化フェーズが開始され、最適化タイムアウトに達するまで、またはすべてのリソースの組み合わせが使い果たされるまで、より優れたソリューションの検索を試行します。</span><span class="sxs-lookup"><span data-stu-id="78a93-248">If a feasible solution was found, then the optimization phase is started, which will try to find a better solution until the optimization timeout is reached or all resource combinations have been exhausted.</span></span>

<span data-ttu-id="78a93-249">制約ソルバーは、スケジューリング アルゴリズムの詳細を認識しません。</span><span class="sxs-lookup"><span data-stu-id="78a93-249">The constraint solver is not aware of the specifics of the scheduling algorithm.</span></span> <span data-ttu-id="78a93-250">これは、「マジック」が起こるさまざまな制約の定義および組み合わせに含まれています。</span><span class="sxs-lookup"><span data-stu-id="78a93-250">It is in the definition and combination of the various constraints that the "magic" happens.</span></span>

### <a name="determining-working-times"></a><span data-ttu-id="78a93-251">作業時間の決定</span><span class="sxs-lookup"><span data-stu-id="78a93-251">Determining working times</span></span>

<span data-ttu-id="78a93-252">エンジンの (内部) 制約の大部分は、リソースの作業時間と能力を制御します。</span><span class="sxs-lookup"><span data-stu-id="78a93-252">A large part of the (internal) constraints in the engine controls the working time and capacity of a resource.</span></span> <span data-ttu-id="78a93-253">基本的に、このタスクでは、特定の方向の特定のポイントからリソースの作業タイム スロットを移動して、ジョブの必要な能力 (時間) に合わせることができる十分な期間を見つけます。</span><span class="sxs-lookup"><span data-stu-id="78a93-253">Essentially, the task is to traverse the working time slots for a resource from a given point in a given direction, and find a long enough interval in which the jobs required capacity (time) can fit.</span></span>

<span data-ttu-id="78a93-254">これを行うために、エンジンはリソースの作業時間を把握している必要があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-254">To do this, the engine needs to know the working times of a resource.</span></span> <span data-ttu-id="78a93-255">主要なモデル データとは反対に、作業時間は必要に応じて、*遅延読み込み* で、エンジンに読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="78a93-255">Opposite to the main model data, the working times are *lazy loaded*, meaning that they are loaded into the engine as needed.</span></span> <span data-ttu-id="78a93-256">この方法を使用するのは、非常に長い期間にわたるカレンダーの Supply Chain Management の作業時間が発生し、通常、多くのカレンダーが存在して、多くの場合、プリロードに対してデータが非常に大きくなるためです。</span><span class="sxs-lookup"><span data-stu-id="78a93-256">The reason for this approach is that there are often working times in Supply Chain Management for a calendar for a very long period and typically many calendars exist so the data would be quite large to pre-load.</span></span>

<span data-ttu-id="78a93-257">カレンダー情報は、チャンクでエンジンが `WrkCtrSchedulingInteropDataProvider.getWorkingTimes` X++ クラス メソッドを呼び出すことによって要求されます。</span><span class="sxs-lookup"><span data-stu-id="78a93-257">Calendar information is requested by the engine in chunks, by invoking the X++ class method `WrkCtrSchedulingInteropDataProvider.getWorkingTimes`.</span></span> <span data-ttu-id="78a93-258">この要求は、特定の時間間隔における特定のカレンダー ID に対して行われます。</span><span class="sxs-lookup"><span data-stu-id="78a93-258">The request is for a specific calendar ID in a specific time interval.</span></span> <span data-ttu-id="78a93-259">Supply Chain Management でのサーバー キャッシュの状態に応じて、(純粋な計算時間を基準として) 時間がかかる各要求がいくつかのデータベース呼び出しで終了することがあります。</span><span class="sxs-lookup"><span data-stu-id="78a93-259">Depending on the state of the server cache in Supply Chain Management, each of these requests could end up in several database calls, which takes a long time (relative to the pure computational time).</span></span> <span data-ttu-id="78a93-260">また、カレンダーに、1 日あたりの多くの作業時間間隔を含む、非常に詳細な作業時間の定義が含まれている場合には、これが読み込み時間に加算されます。</span><span class="sxs-lookup"><span data-stu-id="78a93-260">Also, if the calendar contains very elaborate working time definitions with many working time intervals per day, this adds to the time the loading takes.</span></span>

<span data-ttu-id="78a93-261">スケジューリング エンジンに作業時間データが読み込まれると、データは、特定のカレンダーの内部キャッシュに保持されます。つまり、他のジョブまたはリソースが同じカレンダーを使用している場合、次のルックアップをメモリから迅速に実行できます。</span><span class="sxs-lookup"><span data-stu-id="78a93-261">When the working time data is loaded in the scheduling engine, this is retained in its internal cache for the specific calendar, meaning that if any other jobs or resources are using the same calendar then the next lookups can be performed quickly from memory.</span></span> <span data-ttu-id="78a93-262">カレンダーの内容が同じであっても、カレンダーごとにデータを要求する必要があるため、各リソースに個別のカレンダー ID が使用されて、パフォーマンスが低下する一般的な原因の 1 つとなる場合があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-262">One common cause of bad performance is if a separate calendar ID is used for each resource, because data will then need to be requested for each calendar, even though the content of the calendars might be the same.</span></span>

### <a name="finite-capacity"></a><span data-ttu-id="78a93-263">有限能力</span><span class="sxs-lookup"><span data-stu-id="78a93-263">Finite capacity</span></span>

<span data-ttu-id="78a93-264">有限能力を使用すると、カレンダーの作業タイム スロットが、既存の確保済能力に基づいて分割および削減されます。</span><span class="sxs-lookup"><span data-stu-id="78a93-264">When using finite capacity, the working time slots from the calendar are split and reduced based on the existing capacity reservations.</span></span> <span data-ttu-id="78a93-265">これらの予約は、カレンダーと同じ `WrkCtrSchedulingInteropDataProvider` クラスによっても取得されますが、代わりにこの `getCapacityReservations` メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="78a93-265">These reservations are also fetched through the same `WrkCtrSchedulingInteropDataProvider` class as the calendars, but instead use the method `getCapacityReservations`.</span></span> <span data-ttu-id="78a93-266">マスター プランのスケジューリング時に、特定のマスター プランの予約が考慮され、**マスター プラン パラメーター** ページで有効になると、確定した製造オーダーからの予約が含まれるようになります。</span><span class="sxs-lookup"><span data-stu-id="78a93-266">When scheduling during master planning, the reservations for the specific master plan are considered and if enabled on the **Master planning parameters** page, the reservations from firmed production orders are also included.</span></span> <span data-ttu-id="78a93-267">同様に、製造オーダーのスケジューリング時に、既存の計画オーダーからの予約を含めることもできますが、これは他の方法ほど一般的ではありません。</span><span class="sxs-lookup"><span data-stu-id="78a93-267">Similarly, when scheduling a production order, it is also an option to include reservations from existing planned orders, although this is not as common as the other way around.</span></span>

<span data-ttu-id="78a93-268">有限能力を使用すると、次のいくつかの理由によりスケジューリングに時間がかかります。</span><span class="sxs-lookup"><span data-stu-id="78a93-268">Using finite capacity will cause scheduling to take longer due to several reasons:</span></span>

- <span data-ttu-id="78a93-269">データベースから能力情報を取得する場合は処理速度が低下し、通常、サーバー側のリソース間で共有されていないため、能力情報のキャッシュは通常の作業時間ほど良くありません。</span><span class="sxs-lookup"><span data-stu-id="78a93-269">Fetching the capacity information from database is a slow operation and the server-side caching of capacity information is typically not as good as for working times because they are not shared among resources like calendars typically are.</span></span>
- <span data-ttu-id="78a93-270">分割によってスキャンする作業タイム スロットの数は増加しますが、通常、より長い期間のスロットを調査してからソリューションを見つける必要があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-270">The number of working time slots to traverse increases due to the splits, and slots for a longer time period must typically be investigated before a solution can be found.</span></span>
- <span data-ttu-id="78a93-271">スケジューリングが完了したら、競合する予約の確認を実行する必要があります (詳細については、「スケジューリング エンジンの並列実行」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="78a93-271">After the scheduling is complete, a check for conflicting reservations must be performed (see the "Running scheduling engines in parallel" section for details).</span></span>

### <a name="examining-the-resource-combinations"></a><span data-ttu-id="78a93-272">リソースの組み合わせの検証</span><span class="sxs-lookup"><span data-stu-id="78a93-272">Examining the resource combinations</span></span>

<span data-ttu-id="78a93-273">ジョブ順序に標準 `FinishStart` リンクのみが含まれている場合、つまり分岐がない単純なチェーンを形成する場合は、最初のジョブに対して最適なソリューションを見つけてから、次のジョブに最適なソリューションを見つけるため、(注文間ではなく 1 つの注文から見た) 最適な結果を達成できます。</span><span class="sxs-lookup"><span data-stu-id="78a93-273">If the job sequence only contains the standard `FinishStart` links, meaning it forms a simple chain without any branches, an optimal result (seen from the single order, not across orders) can be achieved by finding the best solution for the first job and then moving on to find the best solution for the next job.</span></span> <span data-ttu-id="78a93-274">ジョブの最適なソリューションは、制約を遵守しながら、ジョブの目標に最も近いジョブの開始日と終了日を取得できるリソースを特定することです (フォワード スケジューリングでは、ジョブの終了日をできるだけ早く取得することを意味します)。</span><span class="sxs-lookup"><span data-stu-id="78a93-274">The best solution for a job means finding the resource that can get the from and to date of the job closest to the job goal (in forward scheduling this means getting the end date of the job as early as possible) while still respecting the constraints.</span></span>

<span data-ttu-id="78a93-275">並列ジョブがある場合は、ソリューションを見つける際に、さまざまな組み合わせのリソースを調べる必要があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-275">When there are parallel jobs, finding a solution may involve examining different combinations of resources.</span></span> <span data-ttu-id="78a93-276">使用可能なリソースの組み合わせ数は、接続された並列ジョブに適用できるリソースの数によって設定されます。</span><span class="sxs-lookup"><span data-stu-id="78a93-276">The number of possible resource combinations is the product of the number of applicable resources for the connected parallel jobs.</span></span> <span data-ttu-id="78a93-277">特に、要求日から逆算して注文をスケジュールする場合、高性能な、または結果を出すさまざまなカレンダーを含むいくつかのリソースがある可能性があるため、今日の日付以前に並列ジョブを適合させるためにすべての組み合わせを確認する必要があり、ロジックが、問題のソリューションがないことを認識するのにかなり時間がかかる場合があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-277">Especially when scheduling an order backwards from a requirement date, it can take quite a while for the logic to realize that there is no solution to the problem that will make the parallel jobs fit before today's date, as it will need to check all the combinations because there could be some resources that had a higher efficiency or a different calendar that might give a result.</span></span> <span data-ttu-id="78a93-278">これは、タイムアウト制限が設定されていない場合、方向をフォワードに変更する前に長時間実行することを意味します。</span><span class="sxs-lookup"><span data-stu-id="78a93-278">This means that if no timeout limit has been set it will run for a long time before changing the direction to forward.</span></span>

<span data-ttu-id="78a93-279">また、この組み合わせロジックは、エンジンの実行速度を低下させる可能性のある適用可能なリソースをさらに追加することを意味します。</span><span class="sxs-lookup"><span data-stu-id="78a93-279">This combinatorial logic also means that adding more applicable resources may make the engine run slower.</span></span> <span data-ttu-id="78a93-280">並列処理と無限の能力でのスケジューリングによってパフォーマンスの問題が発生した場合は、使用するリソースについての決定を工順設計者に依頼して、工程にリソースを直接割り当てることにより、問題の一部を解決することができます (ほとんどの場合、エンジンは常に同じリソースを選択するので、最終結果は同じになります)。</span><span class="sxs-lookup"><span data-stu-id="78a93-280">If performance problems occur when having parallel operations and scheduling with infinite capacity, it can partly be fixed by having the route designer take a decision on which resource should be used and then assign the resource directly on the operation (because the engine in most cases will always end up picking the same resource, so the end result will be the same).</span></span>

### <a name="hard-links"></a><span data-ttu-id="78a93-281">ハード リンク</span><span class="sxs-lookup"><span data-stu-id="78a93-281">Hard links</span></span>

<span data-ttu-id="78a93-282">2 つのジョブ間のリンク タイプをハードに設定すると、1 つのジョブの終了と次のジョブの開始との間に時間のギャップがなくなります。</span><span class="sxs-lookup"><span data-stu-id="78a93-282">Setting the link type between two jobs to hard, ensures that there is no time gap between the finish of one job and the start of the next one.</span></span> <span data-ttu-id="78a93-283">この方法は、1 つのジョブで金属が加熱されて、次のジョブで処理される場合、その間に金属が冷却されることが望ましくないシナリオなどで役立ちます。</span><span class="sxs-lookup"><span data-stu-id="78a93-283">This can be very useful in scenarios like when metal is heated in one job and then processed in the next job, where it is not desirable to have the metal cool down in between.</span></span>

<span data-ttu-id="78a93-284">標準のソフト リンクとフォワード スケジューリングを使用すると、工順が分岐のない単純なチェーンを形成する場合、独自の制約を満たす最初のジョブに対するソリューションを見つけて、次のジョブに前のジョブの終了時刻を反映させることによって結果を実現できます。</span><span class="sxs-lookup"><span data-stu-id="78a93-284">With standard soft links and forward scheduling, if the route forms a simple chain without any branches, a result can be achieved by finding a solution for the first job that satisfies its own constraints and then moving on through the chain propagating the end time from the previous job to the next job.</span></span> <span data-ttu-id="78a93-285">現在のジョブで能力が不足している場合は、前のジョブによりジョブ間でギャップが作成される可能性が生じないように、開始時刻がさらに先に移動されます。</span><span class="sxs-lookup"><span data-stu-id="78a93-285">If the current job can't find any capacity, the start time for it will be moved out further, without any consequence for the previous jobs potentially creating gaps between the jobs.</span></span> <span data-ttu-id="78a93-286">ただし、同じシナリオに対して (特に有限能力に関連して) ハード リンクを使用した場合、チェーン内の後の 1 つのジョブで能力が見つからないことは、それまでのすべてのスケジュール済ジョブを 1 つずつ「ドラッグ」して、その回数を再スケジューリングすることを意味します。</span><span class="sxs-lookup"><span data-stu-id="78a93-286">However with hard links (especially in connection with finite capacity) for the same scenario, the fact that one job later in the chain cannot find capacity, will mean that all previous scheduled jobs will have to be "dragged" along one by one and thereby rescheduled a number of times.</span></span> <span data-ttu-id="78a93-287">特に、複数のリソースに対する負荷が高いシナリオでは、ハード リンクによって、ジョブが相互に影響を与えるチェーンに対する反応が生じ、結果が実現可能なスケジュールで安定する前に多数の繰り返しを実行する必要がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-287">Especially in scenarios with high load for multiple resources, the hard links can cause a chain reaction where the jobs will affect each other and a number of iterations will have to be performed before the result stabilizes into a feasible schedule.</span></span>

## <a name="running-scheduling-engines-in-parallel"></a><span data-ttu-id="78a93-288">スケジューリング エンジンの並列実行</span><span class="sxs-lookup"><span data-stu-id="78a93-288">Running scheduling engines in parallel</span></span>

<span data-ttu-id="78a93-289">ヘルパーが使用されているマスター プランの実行の一部としてスケジューリングを実行する場合、マスター プラン ヘルパーの各スレッドは、製造オーダーのスケジューリング タスクを選択することもできます。</span><span class="sxs-lookup"><span data-stu-id="78a93-289">When performing scheduling as part of a master planning run where helpers are used, each of the master planning helper threads can also pick up production order scheduling tasks.</span></span> <span data-ttu-id="78a93-290">これは、複数のスケジューリング エンジンを同時に実行できることを意味します。</span><span class="sxs-lookup"><span data-stu-id="78a93-290">This means that multiple scheduling engines can be running at the same time.</span></span> <span data-ttu-id="78a93-291">一般的なマルチスレッド処理はパフォーマンス上非常に重要ですが、スケジューリングに関しては、いくつかの機能的な弱点があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-291">While multithreading in general is a highly significant performance benefit, there are also some functional downsides when it comes to scheduling.</span></span>

<span data-ttu-id="78a93-292">MRP では、特定の部品表 (BOM) レベルのすべての製造オーダーは要求日シーケンスでスケジュールされます。つまり、要求日が最も早い注文は、最初にスケジュール設定する必要があります。その結果、利用可能なリソース能力を取得できる可能性が高くなります。</span><span class="sxs-lookup"><span data-stu-id="78a93-292">In MRP, all production orders for a given bill of materials (BOM) level are scheduled in requirement date sequence, meaning that those orders with the earliest requirement date should be scheduled first and thereby have the highest chance of getting the available resource capacity.</span></span> <span data-ttu-id="78a93-293">ただし、計画外の注文の一覧で複数のエンジンを選択した場合、シーケンスは保証されないため、他の注文よりも早く完了することがあります。</span><span class="sxs-lookup"><span data-stu-id="78a93-293">However, with multiple engines picking from the list of unscheduled orders the sequence is no longer ensured, as one might complete faster than the other.</span></span>

<span data-ttu-id="78a93-294">また、有限能力を使用してスケジューリングする場合や、複数のエンジン インスタンスが同じ時間間隔で同じリソースを使用する可能性のある注文をスケジュールしようとする場合、競合状態が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-294">Also, when scheduling using finite capacity and when multiple engine instances are trying to schedule orders that are potentially using the same resources at the same time interval, a race condition can occur.</span></span> <span data-ttu-id="78a93-295">このような競合状態の数は、マスター プランの履歴ページの **スケジューリングの競合** フィールドに記録されます。</span><span class="sxs-lookup"><span data-stu-id="78a93-295">The number of such race conditions is recorded in the **Scheduling conflicts** field on the master plans history page.</span></span> <span data-ttu-id="78a93-296">競合解決ロジックは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="78a93-296">The conflict resolution logic is as follows:</span></span>

- <span data-ttu-id="78a93-297">注文をスケジュール (ロックを解除) し、確保済能力を取得します。</span><span class="sxs-lookup"><span data-stu-id="78a93-297">Schedule an order (lock-free) and get capacity reservations.</span></span>
- <span data-ttu-id="78a93-298">ロックをかけます。</span><span class="sxs-lookup"><span data-stu-id="78a93-298">Take the lock.</span></span>
- <span data-ttu-id="78a93-299">期間内にスケジュールされたリソースに新しい確保済能力が存在するかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="78a93-299">Check if newer capacity reservations exist for the scheduled resources in the timespan.</span></span>
  - <span data-ttu-id="78a93-300">存在しない場合は、能力を書き込み、ロックを解除します。</span><span class="sxs-lookup"><span data-stu-id="78a93-300">If no, write the capacity and release the lock.</span></span>
  - <span data-ttu-id="78a93-301">存在する場合はロックを解除し、注文を最初から再スケジューリングします。</span><span class="sxs-lookup"><span data-stu-id="78a93-301">If yes, release the lock and reschedule the order from the beginning.</span></span>

<span data-ttu-id="78a93-302">したがって、複数のエンジン インスタンスを使用してスケジューリングする場合は、各スレッドの正確なタイミングによって異なるため、結果が完全に確定的になりません。</span><span class="sxs-lookup"><span data-stu-id="78a93-302">So, when scheduling with multiple engine instances, the result is not fully deterministic because it will depend on the exact timing of each of the threads.</span></span>

## <a name="operation-scheduling-performance"></a><span data-ttu-id="78a93-303">行程のスケジューリング パフォーマンス</span><span class="sxs-lookup"><span data-stu-id="78a93-303">Operation scheduling performance</span></span>

<span data-ttu-id="78a93-304">行程のスケジューリングは、エンジンの視点から見たおおまかな能力計画とも呼ばれますが、実現性を決定するために必要なデータが増えるにつれて、有限能力が使用された場合に困難な問題が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-304">Even though operation scheduling is also known as rough-cut capacity planning, seen from an engine standpoint, it can be a harder problem to solve if finite capacity is used, as more data is needed to determine feasibility.</span></span>

<span data-ttu-id="78a93-305">リソース グループの能力は、リソース グループのメンバーとなっているリソースとその数によって異なります。</span><span class="sxs-lookup"><span data-stu-id="78a93-305">The capacity of a resource group depends on which and how many resources are members of the resource group.</span></span> <span data-ttu-id="78a93-306">リソース グループ自体は、能力はありません &mdash; そのグループのメンバーに能力がある場合にのみ、能力を持ちます。</span><span class="sxs-lookup"><span data-stu-id="78a93-306">A resource group in itself does not have any capacity&mdash;only when resources are a member of the group will it have capacity.</span></span> <span data-ttu-id="78a93-307">リソース グループのメンバーシップは時間の経過と共に変化するため、1 日あたりの能力を評価する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-307">Because the resource group membership can vary over time, capacity must be evaluated per day.</span></span>

<span data-ttu-id="78a93-308">工程のスケジューリングでは、各工程の開始時刻と終了時刻を決定するために、リソース グループのカレンダーが使用されます。</span><span class="sxs-lookup"><span data-stu-id="78a93-308">In operations scheduling, the resource group's calendar is used to determine the start and end times for each operation.</span></span> <span data-ttu-id="78a93-309">つまり、リソース グループのカレンダーでは、1 つのリソース グループで 1 日に 1 回の行程に対してスケジュールできる行程の時間に制限があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-309">This means that the resource group's calendar places a limit on how much time can be operations scheduled for one operation on one day in one resource group.</span></span> <span data-ttu-id="78a93-310">特定のリソースのカレンダーとは異なり、カレンダーの効率データは、実際の能力ではなく単に始業時間を示しているため、リソース グループでは無視されます。</span><span class="sxs-lookup"><span data-stu-id="78a93-310">Opposite the calendar for the specific resources, the efficiency data of the calendar is ignored for the resource group as it simply denotes opening hours and not actual capacity.</span></span>

<span data-ttu-id="78a93-311">たとえば、ある特定の日付のリソース グループの作業時間が午前 8 時～午後 4 時である場合、リソース グループがその日に合計で利用できる能力に関係なく、1 つの工程で、8 時間に収まる以上の負荷をリソース グループにかけることはできません。</span><span class="sxs-lookup"><span data-stu-id="78a93-311">For example, if the working time for a resource group on one specific date is from 8:00 to 16:00, one operation can't put more load on the resource group than what can be fit into 8 hours, no matter how much capacity that the resource group has available in total on that day.</span></span> <span data-ttu-id="78a93-312">ただし、使用可能な能力は、負荷をさらに制限することができます。</span><span class="sxs-lookup"><span data-stu-id="78a93-312">The available capacity can however limit the load further.</span></span>

<span data-ttu-id="78a93-313">特定の日のリソース グループに含まれるすべてのリソースのジョブ スケジューリングからの負荷は、同じ日のリソース グループの使用可能な能力が計算されるときに考慮されます。</span><span class="sxs-lookup"><span data-stu-id="78a93-313">The load from job scheduling on all the resources included in the resource group on a given day is considered when the available capacity for the resource group on the same day is calculated.</span></span> <span data-ttu-id="78a93-314">各日付の計算方法は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="78a93-314">For each date, the calculation is:</span></span>

<span data-ttu-id="78a93-315">*使用可能なリソースグループのキャパシティ = カレンダーに基づいたグループ内のリソースのキャパシティ &ndash; グループ内でリソースにロードがスケジュールされているジョブ &ndash; グループでリソースにロードがスケジュールされている操作 &ndash; リソースグループにロードがスケジュールさされている操作*</span><span class="sxs-lookup"><span data-stu-id="78a93-315">*Available resource group capacity = Capacity for resources in the group based on their calendar &ndash; Job scheduled load on the resources in the group &ndash; Operations scheduled load on the resources in the group &ndash; Operations scheduled load on the resource group*</span></span>

<span data-ttu-id="78a93-316">工順工程の **リソース要件** タブでは、リソース要件は、特定のリソース (この場合、行程はそのリソースを使用してスケジュールされます)、リソース グループ、リソース タイプ、または、1つ以上の機能、スキル、コース、または証明書のいずれかを使用して指定できます。</span><span class="sxs-lookup"><span data-stu-id="78a93-316">On the **Resource requirements** tab on the route operation, the resource requirements can be specified using either a specific resource (in which case the operation will be scheduled using that resource), for a resource group, for a resource type, or for one or more capabilities, skill, course, or certificate.</span></span> <span data-ttu-id="78a93-317">これらのオプションをすべて使用することで、工順デザインに優れた柔軟性が得られますが、「プロパティ」 (機能やスキルなどのエンジンで使用される抽象名) ごとに能力を考慮する必要があるため、エンジンのスケジューリングが複雑になります。</span><span class="sxs-lookup"><span data-stu-id="78a93-317">While using all of these options gives a great flexibility on the route design, it also complicates the scheduling for the engine as the capacity must be accounted for per "property" (the abstract name used in the engine for capability, skills, and so on).</span></span>

<span data-ttu-id="78a93-318">機能のリソース グループの能力は、対象となる機能を持つリソース グループ内のすべてのリソースの能力の合計になります。</span><span class="sxs-lookup"><span data-stu-id="78a93-318">The resource group's capacity for a capability is the sum of the capacity for all resources in the resource group that has the capability in question.</span></span> <span data-ttu-id="78a93-319">グループ内のリソースに機能がある場合は、必要な能力のレベルにかかわらず、そのリソースは考慮されます。</span><span class="sxs-lookup"><span data-stu-id="78a93-319">If a resource in the group has a capability, it will be considered no matter what level of the capacity is required.</span></span>

<span data-ttu-id="78a93-320">工程のスケジューリングでは、リソース グループの特定の機能の使用可能な能力は、対象の機能を必要とする行程で読み込まれると低下します。</span><span class="sxs-lookup"><span data-stu-id="78a93-320">In operations scheduling, the available capacity for a certain capability for a resource group will be reduced when it is loaded with an operation that requires the capability in question.</span></span> <span data-ttu-id="78a93-321">工程に複数の機能が必要な場合は、必要なすべての機能について能力が低下します。</span><span class="sxs-lookup"><span data-stu-id="78a93-321">If the operation requires more than one capability, the capacity will be reduced for all required capabilities.</span></span>

<span data-ttu-id="78a93-322">各日付の必要な計算方法は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="78a93-322">For each date, the required calculation is:</span></span>

<span data-ttu-id="78a93-323">*キャパシティの利用可能なキャパシティ = キャパシティの利用可能なキャパシティ &ndash; 特定キャパシティでリソースにロードがスケジュールされているジョブ &ndash; リソース グループを含む、特定キャパシティを持つリソースにロードがスケジュールされている操作 &ndash; 特定キャパシティを要するリソースグループ自体にロードがスケジュールされている操作*</span><span class="sxs-lookup"><span data-stu-id="78a93-323">*Available capacity for a capability = Capacity for the capability &ndash; Job scheduled load on the resources with the specific capability, included in the resource group &ndash; Operations scheduled load on the resources with the specific capability, included in the resource group &ndash; Operations scheduled load on the resource group itself that require the specific capability*</span></span>

<span data-ttu-id="78a93-324">つまり、特定のリソースに負荷が発生した場合、特定のリソースの負荷がその特定の機能に対するものであるかどうかに関係なく、特定のリソースの負荷がその機能に対するリソース グループの能力への貢献度を減らすため、負荷は機能ごとのリソース グループの使用可能な能力の計算で考慮されます。</span><span class="sxs-lookup"><span data-stu-id="78a93-324">This means that if there is load on a specific resource, the load is considered in the calculation of the resource group's available capacity per capability, because the load on a specific resource reduces its contribution to the resource group's capacity for a capability no matter if the load on the specific resource is for that specific capability.</span></span> <span data-ttu-id="78a93-325">リソース グループ レベルに負荷がある場合は、特定の機能を必要とする工程から負荷がかかる場合にのみ、機能ごとにリソース グループの使用可能な能力の計算で考慮されます。</span><span class="sxs-lookup"><span data-stu-id="78a93-325">If there is load on the resource group level, it is considered in the calculation of the resource group's available capacity per capability only if the load is from an operation that requires the specific capability.</span></span>

<span data-ttu-id="78a93-326">上記のロジックは、「プロパティ」のタイプごとに同じであるため、有限能力を持つ工程のスケジューリングを使用すると、大量のデータをロードする必要があるので複雑になります。</span><span class="sxs-lookup"><span data-stu-id="78a93-326">The above logic is complicated, as this is the same for each type of "property" so using operations scheduling with finite capacity requires a significant amount of data to be loaded.</span></span>

## <a name="viewing-scheduling-engine-input-and-output"></a><span data-ttu-id="78a93-327">スケジューリング エンジンの入力と出力の表示</span><span class="sxs-lookup"><span data-stu-id="78a93-327">Viewing scheduling engine input and output</span></span>

<span data-ttu-id="78a93-328">スケジューリング プロセスの入出力についての特定の詳細を取得するには、**組織管理 \>設定 \>スケジューリング \>スケジューリング トレース コックピット** へ移動してログを有効にします。</span><span class="sxs-lookup"><span data-stu-id="78a93-328">To get specific details of the input and output of the scheduling process,  enable logging by going to **Organization administration \> Setup \> Scheduling \> Scheduling tracing cockpit**.</span></span>

<span data-ttu-id="78a93-329">このページでは、最初にアクション ウィンドウで **ログの有効化** を選択します。</span><span class="sxs-lookup"><span data-stu-id="78a93-329">On this page, first select **Enable logging** on the Action Pane.</span></span> <span data-ttu-id="78a93-330">その後、製造オーダーのスケジューリングを実行します。</span><span class="sxs-lookup"><span data-stu-id="78a93-330">Then run the scheduling for the production order.</span></span> <span data-ttu-id="78a93-331">完了したら、**スケジューリング トレース コックピット** ページに戻り、アクション ウィンドウで **ログの無効化** を選択します。</span><span class="sxs-lookup"><span data-stu-id="78a93-331">When complete, return to the **Scheduling tracing cockpit** page and select **Disable logging** on the Action Pane.</span></span> <span data-ttu-id="78a93-332">ページを更新すると、グリッドに新しい行が表示されます。</span><span class="sxs-lookup"><span data-stu-id="78a93-332">Refresh the page and a new line will appear in the grid.</span></span> <span data-ttu-id="78a93-333">新しい行を選択して、アクション ウィンドウで **ダウンロード** を選択します。</span><span class="sxs-lookup"><span data-stu-id="78a93-333">Select the new line and select **Download** on the Action Pane.</span></span> <span data-ttu-id="78a93-334">これにより、次のファイルを含む .zip 圧縮フォルダが得られます。</span><span class="sxs-lookup"><span data-stu-id="78a93-334">This will give you a .zip compressed folder containing the following files:</span></span>

- <span data-ttu-id="78a93-335">**Log.txt** - これは、エンジンが実行する手順を説明するログ ファイルです。</span><span class="sxs-lookup"><span data-stu-id="78a93-335">**Log.txt** - This is the log file that describes the steps that the engine goes through.</span></span> <span data-ttu-id="78a93-336">これは非常に複雑で少し混乱する可能性がありますが、パフォーマンスの問題を解決するための工順の設定の実験の一部として使用する場合、最初に探すのは最初の行と最後の行の時間差です。これにより、スケジューラが費やした正確な時間がわかります。</span><span class="sxs-lookup"><span data-stu-id="78a93-336">It is very elaborate and can be a bit overwhelming, but when used as part of experimenting with the route setup to resolve performance problems the first thing to look for is the difference in time between the first and the last line, as this will give you the exact time the scheduler has spent.</span></span>
- <span data-ttu-id="78a93-337">**XmlModel.xml** - X++ で構築され、エンジンが動作するモデルが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78a93-337">**XmlModel.xml** - This contains the model that is built in X++ and that the engine operates on.</span></span> <span data-ttu-id="78a93-338">ファイルで使用される `JobId` は、ジョブ (`ReqRouteJob` または `ProdRouteJob`) を含むソース テーブルの `RecId` と関連しています。</span><span class="sxs-lookup"><span data-stu-id="78a93-338">The `JobId` used in the file correlates to the `RecId` from the source table containing the jobs (`ReqRouteJob` or `ProdRouteJob`).</span></span> <span data-ttu-id="78a93-339">このファイルでは、`ConstraintJobStartsAt` と `ConstraintJobEndsAt` で指定された日付が予期したものであること、`JobGoal` プロパティが正確に設定されていること、および、ジョブが `JobLink` 制約により相互に関連していることを確認するのが一般的です。</span><span class="sxs-lookup"><span data-stu-id="78a93-339">The typical thing to look for in this file is that the dates given in `ConstraintJobStartsAt` and `ConstraintJobEndsAt` are as expected, that the `JobGoal` property is set correctly, and that the jobs are related to each other through the `JobLink` constraints.</span></span>
- <span data-ttu-id="78a93-340">**XmlSlots.xml** - エンジンによって要求されたすべての作業時間および確保済能力が含まれます。</span><span class="sxs-lookup"><span data-stu-id="78a93-340">**XmlSlots.xml** - This contains all the working times and capacity reservations that the engine has requested.</span></span> <span data-ttu-id="78a93-341">カレンダーの稼働時間と予約は、エンジンがジョブ (および追加のバッファ) を配置しようとする期間にのみ要求されるため、ファイルに非常に遠い将来の時間が含まれている場合は、設定に問題があることを示している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-341">The calendar working times and reservations will only be requested by the engine for the time periods where it tries to place the jobs (and an extra buffer), so if the file contains times very far in the future, it might be an indication of a problem with the setup.</span></span> <span data-ttu-id="78a93-342">`ResourceProperty` ノードは、リソースごとに、どのリソース グループと機能がどの期間に関連付けられているかを示します。</span><span class="sxs-lookup"><span data-stu-id="78a93-342">The `ResourceProperty` nodes will show for each resource which resource group and capabilities it is associated with for which periods.</span></span>
- <span data-ttu-id="78a93-343">**Result.xml** - スケジュール実行の結果が含まれます。</span><span class="sxs-lookup"><span data-stu-id="78a93-343">**Result.xml** - This contains the result of the scheduling run.</span></span>

<span data-ttu-id="78a93-344">追跡機能はパフォーマンス オーバーヘッドを大幅に増加させる可能性があるため、制御された方法で特定の注文のスケジューリングを調査する場合にのみ使用してください。</span><span class="sxs-lookup"><span data-stu-id="78a93-344">Note that the tracing functionality can add significant performance overhead, so only use it for investigating scheduling of specific orders in a controlled manner.</span></span> <span data-ttu-id="78a93-345">マスター プランの実行中にオンになっていると、すぐにサイズ制限に達して停止します。</span><span class="sxs-lookup"><span data-stu-id="78a93-345">If it is turned on during a master planning run it will quickly reach its size limit and stop.</span></span>

## <a name="troubleshooting-performance"></a><span data-ttu-id="78a93-346">パフォーマンスのトラブルシューティング</span><span class="sxs-lookup"><span data-stu-id="78a93-346">Troubleshooting performance</span></span>

<span data-ttu-id="78a93-347">前のすべてのセクションから理解できるように、スケジューリング エンジンの設定と使用に関しては、パフォーマンスの問題につながる可能性のあるいくつかの落とし穴があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-347">As can be understood from all of the previous sections, there are some pitfalls when it comes to the setup and usage of the scheduling engine, which can lead to performance problems.</span></span> <span data-ttu-id="78a93-348">このような問題のトラブルシューティングには、次のチェックリストを使用できます。</span><span class="sxs-lookup"><span data-stu-id="78a93-348">The following check list can be used for troubleshooting such issues.</span></span> <span data-ttu-id="78a93-349">多くの場合、問題を引き起こすのは複数の要因の組み合わせであるため、すべてのポイントを確認することが重要です。</span><span class="sxs-lookup"><span data-stu-id="78a93-349">It is important to look at all the points as it is most often a combination of multiple factors that leads to problems.</span></span>

### <a name="performing-scheduling-as-part-of-mrp-when-it-is-not-needed"></a><span data-ttu-id="78a93-350">不要な場合に、MRP の一部としてスケジューリングを実行する</span><span class="sxs-lookup"><span data-stu-id="78a93-350">Performing scheduling as part of MRP when it is not needed</span></span>

<span data-ttu-id="78a93-351">工順は原価やレポートなどの生産管理の目的で使用されますが、MRP の際には考慮する必要がない場合があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-351">Even though routes are used for the production control purposes such as costing and reporting, it might not be necessary to consider them during MRP.</span></span> <span data-ttu-id="78a93-352">場合によっては、品目に対して標準生産リードタイムが指定されていれば、計画には十分なことがあります。</span><span class="sxs-lookup"><span data-stu-id="78a93-352">In some cases, having a standard production lead time specified for the item will be sufficient for planning.</span></span> <span data-ttu-id="78a93-353">工順のスケジューリングを無効にするには、能力タイム フェンスをゼロに設定します。</span><span class="sxs-lookup"><span data-stu-id="78a93-353">To turn off route scheduling, set the capacity time fence to zero.</span></span> <span data-ttu-id="78a93-354">スケジュールを作成する場合は、MRP の補充タイム フェンスのすべての範囲について、工順を考慮する必要がないことがあるため、能力タイム フェンスを慎重に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-354">If scheduling should be done, then the capacity time fence must be carefully set because it might not be necessary to consider routes for the full extent of the MRP's coverage time fence.</span></span>

<span data-ttu-id="78a93-355">注文が MRP 期間中にスケジューリングされていない場合は、計画オーダーが確定されたときにスケジューリングする必要があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="78a93-355">Note that if the order is not scheduled during MRP, then it will instead need to be scheduled when the planned order is firmed.</span></span> <span data-ttu-id="78a93-356">つまり、確定プロセスに時間がかかるため、提案された計画オーダーの確定数によっては、MRP 中のパフォーマンスの向上が確定時に失われる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-356">This means that the firming process will take longer, so depending on how many of the suggested planned orders get firmed the performance gain during MRP might be lost at firming.</span></span>

### <a name="route-with-unnecessary-operations"></a><span data-ttu-id="78a93-357">不要な行程での工順</span><span class="sxs-lookup"><span data-stu-id="78a93-357">Route with unnecessary operations</span></span>

<span data-ttu-id="78a93-358">工順を設計する際には、実際の生産におけるすべてのステップを正確にモデル化したくなります。</span><span class="sxs-lookup"><span data-stu-id="78a93-358">When designing the route, it is tempting to try to model the real world exactly with all the steps the production goes through.</span></span> <span data-ttu-id="78a93-359">これは場合によっては便利ですが、エンジンが処理する必要のあるモデルが大きくなり (ジョブと制約の両方の観点から)、ジョブの挿入と更新および確保済能力のためにより多くの SQL ステートメントが実行されるため、パフォーマンスには良くありません。</span><span class="sxs-lookup"><span data-stu-id="78a93-359">While this can be useful in some cases, it is not good for the performance as the model the engine needs to work on gets larger (both in terms of jobs and constraints) and more SQL statements will be executed for insertion and update of the jobs and capacity reservations.</span></span> <span data-ttu-id="78a93-360">また、最終的にジョブの進捗状況を報告する必要があるというダウンストリームの影響があります。これは、自動転記によって軽減できます。</span><span class="sxs-lookup"><span data-stu-id="78a93-360">Also, there is the downstream effect of having to eventually report progress on the jobs, which can be mitigated with automatic postings.</span></span> <span data-ttu-id="78a93-361">データが何も使用されていない場合は、不要な負荷が生じます。</span><span class="sxs-lookup"><span data-stu-id="78a93-361">If the data is not used for anything, it creates unnecessary load.</span></span>

<span data-ttu-id="78a93-362">スケジューリング (通常はボトルネック リソース) や原価計算の目的で厳密に必要な行程のみを作成することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78a93-362">We recommend that you only create operations that are strictly needed for scheduling (which will typically be the bottleneck resources) and/or costing purposes.</span></span> <span data-ttu-id="78a93-363">または、多数の小さい別個の工程を 1 つの大きな工程にグループ化して、プロセスのより大きな部分を表すようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-363">Alternatively you should group many smaller distinct operations into one larger operation that represents a greater part of the process.</span></span>

### <a name="many-applicable-resources-for-an-operation"></a><span data-ttu-id="78a93-364">工程に適用可能な多くのリソース</span><span class="sxs-lookup"><span data-stu-id="78a93-364">Many applicable resources for an operation</span></span>

<span data-ttu-id="78a93-365">工程に適用可能なリソースの数は、関連行程に設定されているリソース要件によって決まります。</span><span class="sxs-lookup"><span data-stu-id="78a93-365">The number of applicable resources for an operation is determined by the resource requirements set on the operation relation.</span></span> <span data-ttu-id="78a93-366">要件は、特定の (個別の) リソースに対してであることも、リソース グループまたは機能のリソースのメンバーシップに基づいていることもあります。</span><span class="sxs-lookup"><span data-stu-id="78a93-366">The requirement can either be for a specific (individual) resource or it can be based on the resource's membership of a resource group or capability.</span></span>

<span data-ttu-id="78a93-367">有限能力を使用してスケジューリングを行わず、すべての適用可能なリソースとの同じカレンダーと効率が同じである場合、スケジューリング エンジンは、適用可能なリソースをすべて試して、他のリソースよりも「より良い」リソースがあるかを確認した後で、工程に対して常に同じリソースを選択します。</span><span class="sxs-lookup"><span data-stu-id="78a93-367">If scheduling is not done using finite capacity and all the applicable resources have the same calendar and efficiency, then the scheduling engine will always end up picking the same resource for an operation, but only after trying all the applicable resources to check if there is one that is "better" than the others.</span></span> <span data-ttu-id="78a93-368">この場合、工順デザイン時に、常に特定のリソースが工程に割り当てられるようにすることによって、スケジューリングの負荷を大幅に軽減できます。</span><span class="sxs-lookup"><span data-stu-id="78a93-368">In this case, the load of the scheduling can be greatly reduced simply by always assigning a specific resource to the operation at the route design time.</span></span>

### <a name="route-with-parallel-operations"></a><span data-ttu-id="78a93-369">並行行程での工順</span><span class="sxs-lookup"><span data-stu-id="78a93-369">Route with parallel operations</span></span>

<span data-ttu-id="78a93-370">並行行程 (主/副) は、特定のタスクを実行するために機械とオペレータの両方が必要である場合などのシナリオをモデル化するための強力なツールですが、多くのパフォーマンスの問題の原因でもあります。</span><span class="sxs-lookup"><span data-stu-id="78a93-370">While parallel operations (primary/secondary) are a powerful tool to model scenarios like when a machine and an operator are both needed to perform a specific task, it is also the source of many performance issues.</span></span> <span data-ttu-id="78a93-371">特定の個別リソースの要件が基本工程と二次工程の両方に割り当てられている場合、通常は問題になりません。</span><span class="sxs-lookup"><span data-stu-id="78a93-371">If a requirement for a specific individual resource is assigned to both the primary and secondary operation, it is typically not a problem.</span></span> <span data-ttu-id="78a93-372">ただし、各工程に対して多くの使用可能なリソースがある場合は、スケジューリングに非常に複雑な計算が必要になります。</span><span class="sxs-lookup"><span data-stu-id="78a93-372">But if there are many possible resources for each of the operations, then it adds significant computational complexity to the scheduling.</span></span>

<span data-ttu-id="78a93-373">並行行程を使用する代わりに、ペアを「仮想」リソースとしてモデル化することもできます (これにより、工程で常に実行されるチームを表すことができます)。または、ボトルネックを表していない場合は、いずれかの行程をモデル化しません。</span><span class="sxs-lookup"><span data-stu-id="78a93-373">An alternative to using parallel operations is either to model the pairs as "virtual" resources (which will then represent the team that always goes together for the operation) or to simply not model one of the operations if it doesn't represent a bottleneck.</span></span>

### <a name="route-with-quantity-of-resources-higher-than-1"></a><span data-ttu-id="78a93-374">リソースの数量が 1 より高い工順</span><span class="sxs-lookup"><span data-stu-id="78a93-374">Route with quantity of resources higher than 1</span></span>

<span data-ttu-id="78a93-375">行程に必要なリソースの数量を 1 より高く設定すると、複数の並列ジョブがエンジンに送信されるため、基本行程/二次行程を使用する場合と実質的に同じ結果になります。</span><span class="sxs-lookup"><span data-stu-id="78a93-375">If setting the quantity of resources needed for an operation higher than one, then it results effectively the same as using primary/secondary operations because multiple parallel jobs are sent to the engine.</span></span> <span data-ttu-id="78a93-376">ただし、この場合、数量が 1 を超えると行程に複数のリソースが適用可能である必要があるため、特定のリソース割り当てを使用するオプションはありません。</span><span class="sxs-lookup"><span data-stu-id="78a93-376">However, for this case there is not an option of using specific resource assignments, because a quantity higher than one requires that more than one resource is applicable for the operation.</span></span>

### <a name="excessive-use-of-finite-capacity"></a><span data-ttu-id="78a93-377">有限能力の過度な使用</span><span class="sxs-lookup"><span data-stu-id="78a93-377">Excessive use of finite capacity</span></span>

<span data-ttu-id="78a93-378">有限能力を使用するには、エンジンがデータベースから能力情報を読み込む必要があり、特にリソースが最大能力近くまで予約されている環境ではソリューションを見つけるのが難しいため、計算のオーバーヘッドが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-378">Use of finite capacity requires the engine to load the capacity information from a database and can have a computational overhead because it will be harder to find a solution especially in environments where the resources are booked close to their maximum capacity.</span></span> <span data-ttu-id="78a93-379">そのため、リソースが有限能力を使用する必要があるかどうか、または予約超過になる可能性があるかを慎重に評価することが重要です。</span><span class="sxs-lookup"><span data-stu-id="78a93-379">As a result, it is important to carefully evaluate if a resource really needs to use finite capacity or they can be overbooked.</span></span> <span data-ttu-id="78a93-380">有限能力のリソース間では、予約超過しないことの重要性に違いがある可能性があるため、「ボトルネック リソースの能力タイム フェンス」のプランの個別の値と組み合わせて、リソースのボトルネック オプションを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78a93-380">Because there might be a difference among finite capacity resources in how important they are not to overbook, we recommend using the bottleneck option on a resource in combination with a separate value on the plan in "Capacity time fence for bottleneck resources".</span></span> <span data-ttu-id="78a93-381">ボトルネックの概念を使用することにより、一般的な有限能力タイム フェンスを低くすることができます。</span><span class="sxs-lookup"><span data-stu-id="78a93-381">Using the bottleneck concept can enable that the general finite capacity time fence can be lowered.</span></span>

### <a name="setting-hard-links"></a><span data-ttu-id="78a93-382">ハード リンクの設定</span><span class="sxs-lookup"><span data-stu-id="78a93-382">Setting hard links</span></span>

<span data-ttu-id="78a93-383">工順の標準リンク タイプは *ソフト* です。これは、1 つの工程の終了時刻と次の工程の開始時刻の間に期間のギャップを許可されることを意味します。</span><span class="sxs-lookup"><span data-stu-id="78a93-383">The standard link type of the route is *soft*, which means that a time gap is allowed between the finishing time of one operation and the start of the next.</span></span> <span data-ttu-id="78a93-384">このようにした場合、いずれかの行程で材料または能力が非常に長い間利用できない場合、生産がかなり長い間アイドル状態になり、進行中の作業が増えるという残念な結果が生じる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-384">Allowing this can have the unfortunate effect that, if materials or capacity are not available for one of the operations for a very long time, the production could be idle for quite a while, meaning a possible increase of work in progress.</span></span> <span data-ttu-id="78a93-385">完了と開始が完全に揃う必要があるため、これはハード リンクでは発生しません。</span><span class="sxs-lookup"><span data-stu-id="78a93-385">This will not happen with hard links because the finish and start must align perfectly.</span></span> <span data-ttu-id="78a93-386">ただし、ハード リンクを設定すると、2 つの工程リソースに対して作業時間と能力の交差を計算する必要があるため、スケジューリングの問題がより困難になります。</span><span class="sxs-lookup"><span data-stu-id="78a93-386">But setting hard links makes the scheduling problem more difficult because working time and capacity intersections must be calculated for the two resources of the operations.</span></span> <span data-ttu-id="78a93-387">さらに並行行程が関係している場合は、計算にかなり時間がかかることになります。</span><span class="sxs-lookup"><span data-stu-id="78a93-387">If there are also parallel operations involved, this adds significant computational time.</span></span> <span data-ttu-id="78a93-388">2 つの工程のリソースにまったく重複しないカレンダーがある場合、問題は解決しません。</span><span class="sxs-lookup"><span data-stu-id="78a93-388">If the resources of the two operations have different calendars that don't overlap at all, the problem is unsolvable.</span></span>

<span data-ttu-id="78a93-389">絶対に必要な場合にのみハード リンクを使用し、工順の各工程に必要かどうかを慎重に検討することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78a93-389">We recommend using hard links only when strictly necessary, and carefully consider if it is necessary for each operation of the route.</span></span>

<span data-ttu-id="78a93-390">ハード リンクを適用せずに進行中の作業を減らすための秘訣は、2 回目のパスで逆方向に変更して注文を 2 回スケジュールすることです。</span><span class="sxs-lookup"><span data-stu-id="78a93-390">To reduce the work in progress without applying hard links, a trick is to schedule the order twice with changing to the opposite direction for the second pass.</span></span> <span data-ttu-id="78a93-391">最初のスケジュールが配送日から逆方向に実行された場合、2 番目のスケジュールは開始予定日から前方向に実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-391">If the first schedule was done backwards from delivery date, then the second should be done forward from the scheduled start date.</span></span> <span data-ttu-id="78a93-392">これにより、ジョブが可能な限り圧縮され、進行中の作業が最小化されます。</span><span class="sxs-lookup"><span data-stu-id="78a93-392">This will result in the jobs being compressed as much as possible so that the work in progress is minimized.</span></span>

### <a name="separate-calendar-for-each-resource"></a><span data-ttu-id="78a93-393">リソースごとの個別のカレンダー</span><span class="sxs-lookup"><span data-stu-id="78a93-393">Separate calendar for each resource</span></span>

<span data-ttu-id="78a93-394">スケジューリング エンジンのデータの主要なソースの 1 つにカレンダー情報があります。これは、データベースからの読み込みにコストがかかる場合があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-394">One of the main sources of data for the scheduling engine is calendar information, which can be expensive to load from the database.</span></span> <span data-ttu-id="78a93-395">カレンダーはテンプレートに基づいて生成されるため、リソースごとにカレンダーを生成し、リソースにダウンタイムやその他の問題がある場合に、このカレンダーの情報を調整したくなります。</span><span class="sxs-lookup"><span data-stu-id="78a93-395">Because calendars are generated based on templates, it would be tempting to generate a calendar for each resource and then adjust the information in this calendar when the resource has downtime and other issues.</span></span> <span data-ttu-id="78a93-396">しかし、これを行うと、リソースごとに新しいデータを要求する必要があり、パフォーマンスの問題の大きな原因となる可能性があるため、カレンダー データをキャッシュするエンジンの機能が大幅に制限されます。</span><span class="sxs-lookup"><span data-stu-id="78a93-396">However, doing this will severely limit the engines ability to cache the calendar data as it would need to request new data for each resource and can be a large source of performance problems.</span></span> <span data-ttu-id="78a93-397">代わりに、リソース間で可能な限りカレンダーを再利用し、一定期間に異なるカレンダー ID を割り当てることでダウンタイムの変更を制御することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78a93-397">Instead, we recommend that you reuse the calendars as much as possible between the resources, and then control downtime changes by assigning a different calendar ID for a period.</span></span>

### <a name="high-number-of-working-time-slots-per-calendar-day"></a><span data-ttu-id="78a93-398">1 カレンダー日あたりの最大作業タイム スロット数</span><span class="sxs-lookup"><span data-stu-id="78a93-398">High number of working time slots per calendar day</span></span>

<span data-ttu-id="78a93-399">エンジンはタイム スロットを 1 つずつ調べて能力を確認することで動作するため、1 カレンダー日あたりのタイム スロットの数を最小限に抑えることが有益です。</span><span class="sxs-lookup"><span data-stu-id="78a93-399">Because the engine works by examining time slots one-by-one for capacity, it is beneficial to minimize the number of time slots per calendar day.</span></span> <span data-ttu-id="78a93-400">たとえば、労働者が 1 時間ごとに 5 分の休憩をとることを結果のスケジュールに反映することが重要かどうかを検討することによって行うことができます。</span><span class="sxs-lookup"><span data-stu-id="78a93-400">This could be done, for example, by considering whether it's important for the resulting schedule to reflect that workers have a 5-minute break every hour.</span></span>

### <a name="large-or-none-scheduling-timeouts"></a><span data-ttu-id="78a93-401">大規模スケジューリング タイムアウト (または、なし)</span><span class="sxs-lookup"><span data-stu-id="78a93-401">Large (or none) scheduling timeouts</span></span>

<span data-ttu-id="78a93-402">スケジューリング エンジンのパフォーマンスは、**スケジューリング パラメータ** ページのパラメータを使用して最適化できます。</span><span class="sxs-lookup"><span data-stu-id="78a93-402">Scheduling engine performance can be optimized using parameters found on the **Scheduling parameters** page.</span></span> <span data-ttu-id="78a93-403">**スケジューリング タイムアウトの有効化** および **スケジューリングの最適化タイムアウトの有効化** 設定は、常に **はい** に設定されている必要があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-403">The **Scheduling timeout enabled** and **Scheduling optimization timeout enabled** settings should always be set to **Yes**.</span></span> <span data-ttu-id="78a93-404">**いいえ** に設定すると、多数のオプションを含む実行不可能な工順が作成された場合、スケジューリングが無限に実行される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-404">If set to **No**, the scheduling can potentially run infinitely if an unfeasible route with many options has been created.</span></span>

<span data-ttu-id="78a93-405">**1 シーケンスあたりの最大スケジューリング タイム** の値は、単一のシーケンスに対するソリューションを検索するために費やす最大秒数を制御します (ほとんどの場合、1 シーケンスは単一の注文に対応します)。</span><span class="sxs-lookup"><span data-stu-id="78a93-405">The value for **Maximum scheduling time per sequence** controls how many seconds can, at most, be spent trying to find a solution for a single sequence (in most cases a sequence corresponds to a single order).</span></span> <span data-ttu-id="78a93-406">ここで使用する値は、工順の複雑さや有限能力などの設定に大きく異なりますが、最大約 30 秒が適切な出発点になります。</span><span class="sxs-lookup"><span data-stu-id="78a93-406">The value to use here highly depends on the complexity of the route and settings like finite capacity, ut a maximum of about 30 seconds is a good starting point.</span></span>

<span data-ttu-id="78a93-407">**最適化の試行タイムアウト** の値は、最初に検出されたものよりも優れたソリューションを見つけるために使用できる最大秒数を制御します。</span><span class="sxs-lookup"><span data-stu-id="78a93-407">The value for **Optimization attempts timeout** controls how many seconds can at most be used to find a better solution than the one originally found.</span></span> <span data-ttu-id="78a93-408">これは、さまざまな組み合わせをテストする必要がある並行行程を使用している工順にのみ影響します。</span><span class="sxs-lookup"><span data-stu-id="78a93-408">This will only influence routes that are using parallel operations as these make it necessary to test different combinations.</span></span>

> [!NOTE]
> <span data-ttu-id="78a93-409">タイムアウトに設定された値は、リリースされた製造オーダーと MRP の一部としての計画オーダーのスケジューリングの両方に適用されます。</span><span class="sxs-lookup"><span data-stu-id="78a93-409">The values set for the timeouts will be applied both for scheduling of released production orders and of planned orders as part of MRP.</span></span> <span data-ttu-id="78a93-410">その結果、非常に高い値を設定すると、計画製造オーダーが多数ある計画を実行するときに、MRP の実行時間が大幅に増加する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78a93-410">As a result, setting very high values could significantly add to the run time of MRP when running for a plan with many planned production orders.</span></span>
