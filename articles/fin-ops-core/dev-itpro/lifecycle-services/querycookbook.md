---
title: クックブックの照会
description: このトピックでは、LCS の [環境の監視] ページにある [SQL インサイト] タブの下の各クエリの詳細と、パフォーマンスの問題のトラブルシューティングを行うときにそれらを使う方法を示します。
author: manalidongre
manager: AnnBe
ms.date: 10/02/2018
ms.topic: article
ms.prod: ''
ms.service: dynamics-ax-platform
ms.technology: ''
audience: Developer, IT Pro
ms.reviewer: sericks
ms.search.scope: Operations
ms.custom: 267184
ms.assetid: eb056816-ccf4-43a5-aed3-cf72543353de
ms.search.region: Global
ms.author: manado
ms.search.validFrom: 2016-11-30
ms.dyn365.ops.version: Version 1611
ms.openlocfilehash: b51496b19e2decc47503415c5fa9464f63229108
ms.sourcegitcommit: 3ba95d50b8262fa0f43d4faad76adac4d05eb3ea
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/27/2019
ms.locfileid: "2183192"
---
# <a name="query-cookbook"></a>クックブックの照会 

[!include [banner](../includes/banner.md)]

このトピックでは、Lifecycle Services (LCS) の **環境の監視** ページにある **SQL インサイト** タブの下の各クエリの詳細と、パフォーマンスの問題のトラブルシューティングを行うときにそれらを使う方法を示します。 この機能の詳細については、[Lifecycle Services (LCS) でツールを使用したパフォーマンスのトラブルシューティング](performancetroubleshooting.md)を参照してください。

## <a name="current-blocking"></a>現在のブロック

### <a name="description"></a>説明
現在ブロックされているクエリ、それらをブロックしている SPID、ブロックされている期間、待機しているリソースをリストします。 これは、同じ情報の一部のグラフィカルな概要を表示するブロック ツリーを表示するためのクエリと組み合わせて使用できます。 正常なシステムでは単独でブロックするのが通常であり、過剰になったり、営業活動に悪影響を及ぼし始めたときのみ問題となります。

### <a name="next-steps"></a>次のステップ
- どのプロセスがブロックされているかを決定し、どのプロセスがブロックしているかとその理由を判別します。
- ブロックを解決するには、実行させて自然にクリアさせるか、リード ブロッカー プロセスを終了して作業をロールバックするかの 2 つのオプションのみです。 一般に、リード ブロッカーは、自然にクリアすると思われない状況 (不適切なクエリ プランの場合など) や、重要なプロセスを実行できないためにすぐに完了する必要があるような状況でのみ終了する必要があります。
- 将来同じブロックを避けるため、インデックスまたはプラン ガイドを使用したり、各種レコードでの操作中にプロセスが互いにブロックしている場合はロック エスカレーションおよびページ ロックを無効にできます。 プロセスが同じレコードで動作している場合、ブロックを回避するには、同時に同じレコード上で動作しないように、プロセスをリファクタリングまたは再スケジューリングする必要があります。

## <a name="current-blocking-tree"></a>現在のブロック ツリー

### <a name="description"></a>説明
現在ブロックしているかブロックされている SPID およびステートメントのグラフィカル表示を提供します。 これは、詳細な情報を表示するために現在のブロック クエリと組み合わせて使用できます。 正常なシステムでは単独でブロックするのが通常であり、過剰になったり、営業活動に悪影響を及ぼし始めたときのみ問題となります。

### <a name="next-steps"></a>次のステップ
- どのプロセスがブロックされているかを決定し、どのプロセスがブロックしているかとその理由を判別します。
- ブロックを解決するには、実行させて自然にクリアさせるか、リード ブロッカー プロセスを終了して作業をロールバックするかの 2 つのオプションのみです。 一般に、リード ブロッカーは、自然にクリアしないと思われる状況 (不適切なクエリ プランの場合など) や、重要なプロセスを実行できないためにすぐに完了する必要があるような状況でのみ終了する必要があります。
- 将来同じブロックを避けるため、インデックスまたはプラン ガイドを使用したり、各種レコードでの操作中にプロセスが互いにブロックしている場合はロック エスカレーションおよびページ ロックを無効にできます。 プロセスが同じレコードで動作している場合、ブロックを回避するには、同時に同じレコード上で動作しないように、プロセスをリファクタリングまたは再スケジューリングする必要があります。

## <a name="current-dtu"></a>現在の DTU

### <a name="description"></a>説明
コンポーネントごとの現在の DTU の詳細を提供します。 DTU は、合計 SQL 負荷のパーセンテージ測定であり、いずれかのサブコンポーネントの最大値として報告されます。 このクエリを使用して、高 DTU の原因となっているサブコンポーネントを決定します。 高い CPU は、多くの場合不適切なクエリ プランに関連しています。 高いデータ入出力は、多くの場合、大規模なにインポートまたはエクスポートに関連しています。 高いログ書き込み率は、多くの場合、大量の中間レコードを変更するレポートなどのバルク プロセスに関連しています。

### <a name="next-steps"></a>次のステップ
- 高い CPU の原因が高い DTU の場合、現在実行中のクエリまたは最後の 1 時間の最も高価なクエリを表示します。 問題に対処するには、インデックスの追加、クエリの変更、または最後の手段としてクエリ プランの追加により、クエリ プランを改善します。
- 多数のデータ入出力の原因が高い DTU の場合、現在実行中のクエリと現在のバッチ ジョブを調べ、何が大量のデータを書き込んでいる可能性があるかを判別してみます。 営業時間外部に実行するようそれらのプロセスのスケジュール設定を検討してください。
- 高いログ入出力の原因が高い DTU の場合、現在実行中のクエリと現在のバッチ ジョブを調べ、何が大量の即時処理を行っている可能性があるかを判別します。 多くの場合、多数のログ入出力は、レポートなど、処理中に疑似一時テーブルとして実際に完全にログ記録されるテーブルを使用することで発生します。 これらのプロセスを営業時間外に実行するか、プロセスを変更することによりこの問題を解決します。

## <a name="currently-running-queries"></a>現在実行中のクエリ

### <a name="description"></a>説明
このデータベースで現在実行状態またはブロック状態のすべてのクエリのリストと、各クエリの合計実行および待機時間も提供します。 実行時間が長く待機時間が短いクエリは多くの場合不適切なクエリ プランであることを示します。 待機時間が長くクエリと実行時間が短いクエリはブロックを示しています。 比較的高速な操作が何回も実行されている場合、行でこのクエリを複数回実行し、実行時間が短い頻繁に発生するクエリを探すことで見つけることができます。

### <a name="next-steps"></a>次のステップ
- 高い CPU 時間が見られる場合、クエリのクエリ プランを取得し、このクエリに使用されている他のクエリ プランの方が効率的かどうかも確認します。 新しいクエリ、クエリの変更、または最後の手段としてプラン ガイドを追加することにより、この問題に対処することを検討してください。
- 高い待機時間が見られる場合、現在のブロックおよび現在のブロック ツリーを表示してクエリがブロックされている理由を判断します。 これは、場合によっては、ロック エスカレーションまたはページ ロックを無効にすることで (これがブロックの原因の場合) 対処できます。 通常は、2 つのクエリにより同じレコードが同時に処理されないように、実行される作業を分割することにより対処されます。

## <a name="get-fragmentation-details"></a>断片化の詳細の取得

### <a name="description"></a>説明
断片化は、レコードがページの内部に連続して格納されない場合に発生します。 テーブルに対して行われたデータ変更や、テーブルで定義されたインデックスにおこなわれたデータ変更を通じて発生した未使用のスペースがページ上のレコード間にある場合、これが SQL インデックスの断片化となります。 Dynamics 365 Finance and Operations アプリでは、SSD によってサポートされている SQL Azure DB プレミアム SKU を使用します。 これは、断片化により、SCSI ドライブを装備したデータベースと同じ問題は発生しませんが、パフォーマンスは低下する可能性があることを意味します。 断片化が増えると、この断片化したテーブルやインデックスを使用するクエリのパフォーマンスに影響を与える可能性が高くなります。

### <a name="next-steps"></a>次のステップ
- このクエリは、テーブルのリスト、断片化率を含むインデックス、インデックスの再構築またはインデックスの再編成の推奨事項を表示します。 インデックスを再構築または再編成すると、レコードが互いに並べてパッキングされ、その間にすきまが生じないようにされるため、断片化が軽減されます。

## <a name="get-index-details"></a>インデックスの詳細の取得

### <a name="description"></a>説明
特定のテーブルのすべてのインデックスに関する詳細を提供します。 通常、このクエリは、代わりに変更する必要がある既存のインデックスがないようにするため、新しいインデックスを追加する前に使用されます。

### <a name="next-steps"></a>次のステップ
- 新しいインデックスを追加する場合は、代わりに調整する必要がある既存のインデックスがないことを確認します。 新しい各インデックスは、すべての書き込み操作でオーバーヘッドを追加します。 したがって、新しいインデックスはあまり追加しないでください。
- ページ ロックがサポートされている場合、既存のインデックスによりブロックが発生することがときどきあり、同時に実行されている大規模なプロセスは、プロセスごとのレコードを含むページをロックしています。 ページ ロックの無効化はあまり行わないでください。ページ ロックを活用している書き込み操作のパフォーマンスが低下する可能性があるためです。

## <a name="get-lock-details"></a>ロックの詳細の取得

### <a name="description"></a>説明
特定の SPID によって保持されているすべてのロックの一覧を示します。 これは、SPID がブロック チェーンの一部であることをブロック ツリーが示している場合に便利です。 場合によっては、このクエリによって、ページ ロックまたはロック エスカレーションがブロックの原因であることがわかります。 それ以外の場合、このクエリは、保持されている特定のテーブル内のキーロックの数を調べるために便利です。

### <a name="next-steps"></a>次のステップ
- ページ ロックまたはロック エスカレーションが問題の原因となっている場合、それらを無効にできます。 ただし、これは慎重に行う必要があります。高いパフォーマンスのためのロック エスカレーションおよびページ ロックが必要なことがあるためです。
- SPID のロックの数が多い場合、1 つのトランザクション範囲内で処理されるデータの量を減らすことで、ロックの数が減るため、ブロックやデッドロックの可能性を減らすことができます。

### <a name="parameters"></a>パラメーター
SPID は、現在実行中のクエリのリストまたは現在ブロック中のクエリのリストから取得できます。 SPID に関する履歴情報はありません。SPID ID は、SPID が現在実行中のときのみ有効なためです。

## <a name="list-of-current-plan-guides"></a>現在のプラン ガイドの一覧

### <a name="description"></a>説明
データベースにインストールされているすべてのプラン ガイドの一覧を提供します。

### <a name="next-steps"></a>次のステップ
- クエリ プラン XML で参照することで、クエリ プランがプラン ガイドに基づいて作成されたかどうかを判断することができます。 プラン ガイドに基づいてプランが生成された場合、プラン ガイド名は XML ファイルで指定されます。
- プラン ガイドがインストールされているが使用されていない場合、プラン ガイドの SQL ステートメントのテキスト パラメーター リストが実際のクエリと同じであることを確認します。 違いがある場合 (空白だけでも)、プラン ガイドの使用が停止されます。

## <a name="get-list-of-query-id39s"></a>クエリ ID のリストの取得

### <a name="description"></a>説明
クエリ テキストが問題の原因となっているがわかっている場合、そのクエリのクエリ ID を検索するためにこのクエリを使用できます。 これは、SQL ステートメントがエラー メッセージ、トレース、またはテレメトリに表示されている場合に発生することがあります。 明細書のクエリ ID が見つかったら、クエリ プランの検索やプラン ガイドの適用などの他の操作で使用できます。

### <a name="next-steps"></a>次のステップ
- 指定したステートメントのクエリ ID が検出されら、最適化できるようにそのクエリの以前のプランを探すために使用できます。

### <a name="parameters"></a>パラメーター
- &quot;%FROM GENERALJOURNALENTRY T1%&quot; など、クエリ ステートメントの部分文字列を指定します。

## <a name="get-xml-for-a-given-plan-id"></a>特定のプラン ID の XML の取得

### <a name="description"></a>説明
これにより、特定のプラン ID の SQL プランが XML 形式で提供されます。

### <a name="next-steps"></a>次のステップ
- XML を .sqlplan ファイルとして保存し、SQL Server Management Studio または他のプラン閲覧ツールで開きます。 クエリ プランからは、インデックスの追加など、多くの場合に有益な最適化を見つけることができます。
- プランによりインデックスの推奨がリストされることがありますが、それらのインデックスを適用する場合に注意が必要になります。 SQL は、多くの場合、1 つのクエリを最適化するための過剰な数の列を持つインデックスを作成することを推奨します。これは、他のクエリまたはシステム全体に影響を及ぼすことがあります。 これらの推奨インデックスは、直接適用されるものとしてではなく、分析を開始するヒントとして表示します。

### <a name="parameters"></a>パラメーター
- プラン ID は、現在実行中のクエリなど、さまざまなソースから入手できます。 クエリ ID のみ持つ場合、&quot;クエリのクエリ プランの一覧の取得&quot; を使って、クエリの使用されているプラン ID を調べます。

## <a name="get-query-plan-and-execution-stats"></a>クエリ プランと実行統計の取得

### <a name="description"></a>説明
特定のクエリのプランおよび実行統計の一覧を提供します。 これは、クエリが、時間の経過と共にさまざまなパフォーマンスの特性を持つ複数のクエリ プランを取得しているかどうかを判断するのに役立ちます。

### <a name="next-steps"></a>次のステップ
- クエリがパフォーマンス特性が大幅に異なる複数のクエリ プランを取得している場合は、何が異なっていて、他のものよりずっとよい理由を調べるために、まずプランを取得して分析します。
- SQL で優れたクエリ プランを使用するには、最適なソリューションとして、インデックスの変更を行うかコードに直接クエリ ヒントを追加します。
- インデックスとクエリ ヒントが十分でない場合、最後の手段として、優れたプランが強制的に使用されるようにプラン ガイドを追加できます。 クエリ プランを使用するときは注意してください。クエリ プランは、パラメーター値によって高速であったり非常に低速であったりすることがあるためです。

### <a name="parameters"></a>パラメーター
- **クエリ ID** は、現在実行中のクエリ、現在ブロック中のクエリ、最も高価なクエリ、およびステートメント テキストによるクエリなど、他の複数の工程から取得できます。
- 時間数単位の**時間間隔**は、多くの場合、前週のすべてのプランを示すために &quot;168&quot; として、前日のすべてのプランを示すために &quot;24&quot; として指定されます。 多くの場合、プランは 1 週間に複数回変更されますが、数日安定する可能性があります。 そのため、ここでそれ以上の間隔を選択と多くの場合有利です。

## <a name="get-wait-stats"></a>待機統計の取得

### <a name="description"></a>説明
指定された時間範囲で待機した特定のクエリ プランについて説明します。 これは、定期的にクエリに予想より時間がかかり、CPU 時間であるかブロックであるかを判断できない場合に役立ちます。 同様に、ブロックが見られるが、その種類がわからない場合、これはその情報を提供します。

### <a name="next-steps"></a>次のステップ
- プランが主に CPU を待機している場合、プランは非効率的なだけではなく、インデックスまたはヒントを追加するか、クエリを再構築することで修正する必要があります。
- ロックを待機している場合、クエリでブロックが発生しています。 これは、ブロック ツリー クエリを通じてブロックがアクティブに発生していることを確認できるのでなければ、判断するのが困難です。 この場合は、次の手順で、編集されるレコードを評価し、同時に同じレコードを編集する他のプロセスを判断することを試みます。 多くの場合、同時に複数のスレッドで実行されている同じクエリが自分自身をブロックします。
- 入出力またはラッチを待機している場合、大量のデータが転送されているか、多数の小規模トランザクションが発生していると考えられます。 可能であれば、トランザクションごとに 1 つのレコードではなく小規模なバッチでの書き込みを実行します。

### <a name="parameters"></a>パラメーター
- プラン ID は、さまざまなソース (現在実行中のクエリと最も高価なクエリを含む) から入手できます。 クエリ ID がある場合、クエリを使ってそのクエリのプランのリストを取得することで、プラン ID を取得できます。
- 原則的には、時間の範囲は問題が発生していた特定の時間を対象とする必要があります。 たとえば、DTU が 1 時間高かった場合、その実行時間だけを対象にする必要があります。

## <a name="list-most-expensive-queries"></a>最も高価なクエリのリスト

### <a name="description"></a>説明
指定された期間内の最も高価なクエリの一覧を提供します。 最も高価なクエリを計算するときに考慮する必要がある属性の決定を提供することもできます。 これは、ある期間に高い DTU が見られる場合に、どのクエリが高い DTU の原因となっているかを調べるためによく使用されます。 このクエリを効果的に使用するため、処理されている DTU コンポーネントを決定するために重要です。

### <a name="next-steps"></a>次のステップ
- DTU 使用率が高い原因となっているクエリを見つけるため、合計 CPU により最も高価なクエリを表示します。 通常、これらのクエリは、インデックス、クエリの変更、または、最後の手段としてプラン ガイドを通じて修正されます。
- ユーザー エクスペリエンスを遅くする可能性があるクエリを見つけるには、合計期間により最も高価なクエリを表示します。 これらのクエリの合計 CPU も高い場合、クエリ プランを修正します。 CPU が低い場合、ブロックの結果の可能性があります。

### <a name="parameters"></a>パラメーター
- 現在 DTU が高いなど、現在発生している問題を調べている場合、時間数として &quot;0&quot; を指定します。 これは、現在の時間の結果を提供します。 時間の経過と共に全体的に高い DTU を探している場合、最後の日として &quot;24&quot; を指定するか、最後の週として &quot;168&quot; を指定します。
- 定期的なクエリの高い DTU の影響を見つけるには、順序として &quot;合計 CPU&quot; を選択します。 頻繁に実行されるわけではないが低速な可能性があるクエリを見つけるには、&quot;平均期間&quot; を選択します。 ユーザーを遅くしている可能性がある定期的なクエリを検索するには、&quot;合計期間&quot; を選択します。

## <a name="create-non-unique-index-on-table"></a>テーブルでの一意ではないインデックスの作成

### <a name="background"></a>バックグラウンド
通常、標準メタデータ パッケージとデータベースの同期によって、インデックスを作成する必要があります。 これにより、サンドボックスと PROD、およびその他の環境では、常に共通の定義が共有されます。 場合によっては、定期的な展開に時間がかかりすぎる継続的な停止や問題を軽減するために、実行時に新しい非固有のインデックスをインストールする必要があります。 このアクションは、その非固有インデックスのインストールに使用できます。

### <a name="next-steps"></a>次のステップ
- 作成するインデックスを指定したら、次のステップとして、その同じインデックス定義を次の利用可能な正式メタデータ リリースに移行する必要があります。
- 一般に、重複するインデックスによって大きな問題が発生することはありません。 したがって、正式インデックスが完全に展開されるまでは、手動で作成したインデックスをシステムに置いたままにします。

### <a name="parameters"></a>パラメーター
- インデックス名は、次の表の既存のインデックスにより現在使用されていない任意の一意の文字列です。 識別しやすいように、インデックス名が形式 PERF\_IDX\_\&lt;tablename\&gt;\_\&lt;number\&gt; に従うことが推奨されますが、必須ではありません。 たとえば、インデックスの名前は PERF\_IDX\_LEDGERJOURNALTRANS\_1 にしてください。
- 列パラメーターは、表示される順序で記載された物理的な列名のコンマ区切り一覧です。
- 含まれる列パラメーターは、表示される順序で記載された物理的な列名のコンマ区切り一覧です。 含まれている列を指定する必要がない場合、このパラメーターを空白のままにします。

## <a name="create-a-plan-guide-to-force-plan-id"></a>プラン ID を強制するプラン ガイドの作成

### <a name="description"></a>説明
SQL では、統計の更新が実行されたときなど、プラン キャッシュがフラッシュされるたびに、新しいプランを再計算します。 選択されているプランは、そのクエリの最初の実行のパラメーターの &quot;スニッフィング&quot; に基づきます。 その後、パラメータに関係なく同じプランが使用されます。 このため、同じクエリが複数のプランを取得する場合があります。その一部は、特定のデータ配分のプランよりかなり悪くなります。 このアクションは、スニッフィングされるパラメーターに関係なく、特定のプランを使用するよう SQL を強制するために使用できます。 このアクションは、実行されるデータベースにのみ適用されることに注意してください。 したがって、開発環境と製造環境間を流れるインデックス、ヒント、またはコード変更の追加後に、最後の手段として使用する必要があります。

### <a name="next-steps"></a>次のステップ
- 特定のクエリ ID のプラン ID と実行統計のリストが見つかったら、各 ID の SQL プランをダウンロードして分析する必要があります。 最適なプランが決定されたら、パラメーターに関係なく、そのプランの使用を強制するためにこのスクリプトを使用できます。

### <a name="parameters"></a>パラメーター
- force\_plan\_id パラメーターは、今後使用するプランの ID です。 これは、特定のクエリのすべてのプラン ID を取得するクエリから見つかります。 強制するために、プランの XML が適切なプランであることを検証してください。不適切なプランを強制すると負の効果があるためです。
- 名前パラメーターは、既存のプラン ガイドによって現在使用されていない一意の文字列です。
- ステートメント パラメーターは、強制する SQL ステートメントです。 これは、他の多くのクエリ (現在実行中のクエリと最も高価なクエリを含む) から入手できます。 これが正確にコピーされるようにしてください (空白など)。空白に違いが発生すると、プラン ガイドが機能しないためです。 さらに、このテキストにクエリのパラメーターを含めないでください。別個に指定されるためです。 たとえば、選択クエリでは、ステートメントの最初の文字は必ず &quot;SELECT&quot; にしてください。
- params パラメーターは、一連の @P1、@P2 などのようなクエリのパラメーターです。 これらは、他のクエリ (現在実行中のクエリと最も高価なクエリを含む) から入手できます。 パラメーターに貼り付ける場合、外部かっこを削除します。 たとえば、&quot;@P1 int、@P2 nvarchar(21)&quot; に貼り付けます。 クエリのパラメーターがない場合、この値を空白のままにします。

## <a name="create-a-plan-guide-to-add-table-hints"></a>テーブル ヒントを追加するプラン ガイドの作成

### <a name="description"></a>説明
SQL では、統計の更新が実行されたときなど、プラン キャッシュがフラッシュされるたびに、新しいプランを再計算します。 選択されているプランは、そのクエリの最初の実行のパラメーターの &quot;スニッフィング&quot; に基づきます。 その後、パラメータに関係なく同じプランが使用されます。 このため、同じクエリが複数のプランを取得する場合があります。その一部は、特定のデータ配分のプランよりかなり悪くなります。 このアクションは、特定のヒントをクエリに追加するために使用できます。 これは、プラン ガイドの強制とは異なります。SQL は引き続きパラメーター スニッフィングを実行し、場合によってはさまざまなプランを選択するためです。 ただし、クエリ ヒントはそのプランの計算に適用されます。 このアクションは、実行されるデータベースにのみ適用されることに注意してください。 したがって、開発環境と製造環境間を流れるインデックス、ヒント、またはコード変更の追加後に、最後の手段として使用する必要があります。

### <a name="next-steps"></a>次のステップ
- 通常、特定のクエリの複数の異なるクエリ プランを検索した後クエリ ヒントが決まります。 たとえば、テーブル上のインデックス シークのパフォーマンスが常にスキャンより高い場合、FORCESEEK ヒントを追加すると便利な場合があります。
- ヒントが決定され、ローカルでテストされたら、それらのクエリ ヒントをクエリの将来の実行に追加するプラン ガイドをインストールするためにこのアクションを使用します。

### <a name="parameters"></a>パラメーター
- 名前パラメーターは、既存のプラン ガイドによって現在使用されていない一意の文字列です。
- ステートメント パラメーターは、強制する SQL ステートメントです。 これは、他の多くのクエリ (現在実行中のクエリと最も高価なクエリを含む) から入手できます。 これが正確にコピーされるようにしてください (空白など)。空白に違いが発生すると、プラン ガイドが機能しないためです。 さらに、このテキストにクエリのパラメーターを含めないでください。別個に指定されるためです。 たとえば、選択クエリでは、ステートメントの最初の文字は必ず &quot;SELECT&quot; にしてください。
- params パラメーターは、一連の @P1、@P2 などのようなクエリのパラメーターです。 これらは、他のクエリ (現在実行中のクエリと最も高価なクエリを含む) から入手できます。 パラメーターに貼り付ける場合、外部かっこを削除します。 たとえば、&quot;@P1 int、@P2 nvarchar(21)&quot; に貼り付けます。 クエリのパラメーターがない場合、この値を空白のままにします。
- 適用するヒントは、クエリの末尾に手動で追加することでローカルでテストできます。 テーブル エイリアスを使用している場合、ステートメント テキストのテーブル エイリアスと一致する必要があります。

## <a name="drop-index"></a>インデックスの削除

### <a name="background"></a>バックグラウンド
通常、テーブルに余分なインデックスがあっても、コストが少し増加するだけです。 しかし、場合によっては (高スループット テーブルなど)、余分なインデックスの存在により大規模なパフォーマンス低下が生じることがあります。 インデックスを削除する適切な方法は、メタデータから削除する方法です。 しかし、継続的な問題を軽減するために積極的に削除する必要がある場合、このアクションを使用できます。

### <a name="next-steps"></a>次のステップ
- テーブルのすべてのインデックスを一覧表示するクエリから、削除するインデックス名を決定します。
- このインデックスの削除により悪影響を受ける他のワークロードがないことを確認します。 この操作を実行するのは危険であり、他のワークロードが回帰する可能性があります。
- 削除するテーブルとインデックスの名前を提供します。
- 原則的には、すべての環境を同期するメタデータのインデックスを削除することで、開発およびサンドボックスなどの他の環境で同じ変更を適用します。

## <a name="end-sql-process"></a>SQL プロセスの終了

### <a name="background"></a>バックグラウンド
SPID が非常に多くのリソースを消費して、他のプロセスの工程が低下している場合、は、SPID プロセスを終了すると便利な場合があります。 これにより、未処理トランザクションがロールバックします。つまり、データは失われませんが、プロセスの手動での再起動が必要になることがあります。 トランザクションが既に多くの作業を実行している場合、ロールバックに時間がかかり、多くのリソースを消費する可能性があることに注意してください。 したがって、このアクションは注意して使用する必要があります。

### <a name="next-steps"></a>次のステップ
- ブロック ツリーやその他のクエリから、SPID が終了するかどうかを判断する必要があります。
- 継続的な事業運営に悪影響を与えずに、SPID により実行されている処理が終了できることを確認します。
- 終了する SPID 番号を指定し、その操作をロールバックします。

## <a name="disableenable-page-locks-and-lock-escalation"></a>ページ ロックおよびロック エスカレーションの無効化/有効化

### <a name="background"></a>バックグラウンド
多くの場合、SQL はページ ロック (ページ全体を一度にロック) を取得するか、テーブル ロック全体 (テーブル全体のロック) にエスカレートします。 これにより、SQL は大量の行を効率的に編集するアクションを実行できます。 ただし、これにより、特定のワークロードで問題および不要な競合が発生することがあります。 2 つの大きな転記ジョブ (それぞれ 10 分を実行されており、偶然同じ物理データ ページに配置されているにさまざまなデータ行を編集している) について考えます。 これにより、2 つの転記がシリアル化され、競合が原因で 20 分かかる可能性があります。 このクエリは、特定のテーブルのロック エスカレーションやページ ロックの無効化に使用できます。 ただし、SQL がページ ロックとロック エスカレーションを使用する有効な理由があるため、慎重に使用してください。

### <a name="next-steps"></a>次のステップ
- ロック エスカレーションまたはページ ロックが原因で不要な競合が特定のテーブルで発生していることを確認したら、これらのオプションを無効にするためにこのクエリを使用します。

### <a name="parameters"></a>パラメーター
- テーブル名は、テーブルの物理名です。
- ロック エスカレーションおよびページ ロックの値は、&quot;ON&quot; または &quot;OFF&quot; です。

## <a name="rebuild-index"></a>インデックスの再構築

### <a name="background"></a>バックグラウンド
時間の経過と共に、プロセスは既存のレコードを編集し、テーブルに新しいレコードを作成するため、インデックスが断片化する可能性があります。 これにより、同じ数のレコードの処理に必要な入出力の数が増え、パフォーマンスが低下が発生する可能性があります。 この操作は、ページの断片化を減らすためにインデックスを再構築します。 これはコストの高い操作であり、実行中に競合が発生させることがわかっています。 したがって、この操作の実行中は、環境を監視してください。

### <a name="next-steps"></a>次のステップ
- この操作の実行中、システムでブロックと DTU を監視します。 システムのパフォーマンスが許容できないほど低下する場合、この操作を終了することを検討します。

## <a name="remove-plan-guide"></a>プラン ガイドの削除

### <a name="background"></a>バックグラウンド
プラン ガイドがインストールされていて、悪影響を与えている、または単に動作していない場合、場合によってはプラン ガイドを削除する必要があります。 このクエリにより、既存のプラン ガイドの削除が可能になります。 プラン ガイドの削除が、現在実行中のクエリが次に実行されるまでそのクエリに影響を与えないことを確認します。

### <a name="next-steps"></a>次のステップ
- どのプラン ガイドを削除するかを決定したら、プランの名前を指定します。

### <a name="parameters"></a>パラメーター
- 既存のプラン ガイドおよび関連付けられている名前のリストは、現在のプラン ガイド クエリの一覧から見つけることができます。

## <a name="update-statistics-on-table"></a>テーブルでの統計の更新

### <a name="background"></a>バックグラウンド
指定されたテーブルでの統計の更新 インポート プロセスによってテーブルの統計が改変された後など、場合によっては、統計が古く、クエリ プランの問題の原因となっていることがわかります。 このアクションは実行中に大きなパフォーマンス オーバーヘッドを与え、同じテーブルを使用するクエリでブロックの原因となることも知られていることに注意してください。 したがって、システムのパフォーマンスが低下しないようにするため、控えめに使用し、実行中は監視してください。

### <a name="next-steps"></a>次のステップ
- このクエリの実行中、システムのパフォーマンスが許容できないほど低下しないように、現在のブロックと現在の DTU の両方を監視します。 低下した場合、更新統計コマンドの終了を検討してください。

### <a name="parameters"></a>パラメーター
- テーブル名パラメーターは、統計情報を更新するテーブルの物理的な名前です。
