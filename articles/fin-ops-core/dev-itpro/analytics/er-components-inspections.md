---
title: 構成済み ER コンポーネントを検査して、ランタイムの問題を回避する
description: このトピックでは、構成済み電子レポート (ER) コンポーネントを検査して、発生する可能性のあるランタイムの問題を回避する方法について説明します。
author: NickSelin
manager: AnnBe
ms.date: 12/04/2020
ms.topic: article
ms.prod: ''
ms.service: dynamics-ax-platform
ms.technology: ''
ms.search.form: ERSolutionTable, ERDataModelDesigner, ERModelMappingTable, ERModelMappingDesigner, EROperationDesigner
audience: Application User, Developer, IT Pro
ms.reviewer: kfend
ms.custom: 220314
ms.assetid: ''
ms.search.region: Global
ms.author: nselin
ms.search.validFrom: 2016-06-30
ms.dyn365.ops.version: Version 7.0.0
ms.openlocfilehash: 4ba696fb7a8d9083d11cc29953cf1340a581afcf
ms.sourcegitcommit: b112925c389a460a98c3401cc2c67df7091b066f
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/19/2020
ms.locfileid: "4797344"
---
# <a name="inspect-the-configured-er-component-to-prevent-runtime-issues"></a>構成済み ER コンポーネントを検査して、ランタイムの問題を回避する

[!include[banner](../includes/banner.md)]

すべての構成済み [電子レポート (ER)](general-electronic-reporting.md) [形式](general-electronic-reporting.md#FormatComponentOutbound) と [モデル マッピング](general-electronic-reporting.md#data-model-and-model-mapping-components) コンポーネントは、設計時に [検証](er-fillable-excel.md#validate-an-er-format) できます。 この検証では、実行エラーやパフォーマンスの低下など、発生する可能性のあるランタイムの問題を防ぐために、整合性チェックが実行されます。 このチェックでは、検出された問題ごとに、問題のある要素のパスを提供します。 一部の問題については、自動修正が利用できます。

既定では、前述の ER コンポーネントを含む ER 構成について、次の場合に検証が自動的に適用されます:

- ER 構成の新しい [バージョン](general-electronic-reporting.md#component-versioning) を Microsoft Dynamics 365 Finance のインスタンスに [インポート](general-electronic-reporting.md#importing-an-er-component-from-lcs-to-use-it-internally) します。
- 編集可能な ER 構成の [状態](general-electronic-reporting.md#component-versioning) を **ドラフト** から **完了** に変更します。
- 新しい基本バージョンを適用することにより、編集可能な ER 構成を [リベース](general-electronic-reporting.md#upgrading-a-format-selecting-a-new-version-of-base-format-rebase) します。

この検証を明示的に実行することもできます。 次の 3 つのオプションのいずれかを選択し、指定されている手順に従います:

- オプション 1:

    1. **組織管理 \> 電子申告 \> コンフィギュレーション** の順に移動します。
    2. 左側のペインにある構成ツリーで、ER 形式または ER モデル マッピング コンポーネントを含む目的の ER 構成を選択します。
    3. **バージョン** クイック タブで、選択した ER 構成の目的のバージョンを選択します。
    4. アクション ペインで、**検証** を選択します。

- オプション 2、ER 形式の場合:

    1. **組織管理 \> 電子申告 \> コンフィギュレーション** の順に移動します。
    2. 左側のペインにある構成ツリーで、ER 形式のコンポーネントを含む目的の ER 構成を選択します。
    3. **バージョン** クイック タブで、選択した ER 構成の目的のバージョンを選択します。
    4. アクション ウィンドウで、**デザイナー** を選択します。
    5. **形式デザイナー** ページのアクション ペインで、**検証** を選択します。

- オプション 3、ER モデル マッピングの場合:

    1. **組織管理 \> 電子申告 \> コンフィギュレーション** の順に移動します。
    2. 左側のペインにある構成ツリーで、ER モデル マッピング コンポーネントを含む目的の ER 構成を選択します。
    3. **バージョン** クイック タブで、選択した ER 構成の目的のバージョンを選択します。
    4. アクション ウィンドウで、**デザイナー** を選択します。
    5. **モデルからデータ ソースへのマッピング** ページのアクション ペインで、**デザイナー** を選択します。
    6. **モデル マッピング デザイナー** ページのアクション ペインで、**検証** を選択します。

構成のインポート時に、検証をスキップするには、次の手順に従います。

1. **組織管理 \> 電子申告 \> コンフィギュレーション** の順に移動します。
2. **構成** ページ、アクション ウィンドウ、**構成** タブ、**詳細設定** グループで、**ユーザー パラメーター** を選択します。
3. **インポート後に構成を検証** オプションを **いいえ** に設定します。

バージョンの状態を変更またはリベースするときに検証をスキップするには、次の手順を実行します。

1. **組織管理 \> 電子申告 \> コンフィギュレーション** の順に移動します。
2. **構成** ページ、アクション ウィンドウ、**構成** タブ、**詳細設定** グループで、**ユーザー パラメーター** を選択します。
3. **構成状態の変更時およびリベース時に検証をスキップ** オプションを **はい** に設定します。

ER では、次のカテゴリを使用して、整合性チェック検査をグループ化します:

- **実行可能性** – 実行時に発生する可能性がある重大な問題を検出する検査。 これらの問題は、ほとんどが **エラー** レベルです。 
- **パフォーマンス** – 構成済み ER コンポーネントの非効率な実行を引き起こす可能性のある問題を検出する検査。 これらの問題は、ほとんどが **警告** レベルです。
- **データの整合性** – データ損失または実行時の問題を引き起こす可能性のある問題を検出する検査。 これらの問題は、ほとんどが **警告** レベルです。

## <a name="list-of-inspections"></a>検査の一覧

次の表は、ER が提供する検査の概要を示します。 これらの検査の詳細については、最初の列のリンクを使用して、このトピックの関連するセクションを参照してください。 これらのセクションでは、ER が検査を提供するコンポーネントのタイプと、問題を防ぐために ER コンポーネントを再構成する方法について説明します。

<table>
<thead>
<tr>
<th>氏名</th>
<th>カテゴリ</th>
<th>レベル</th>
<th>メッセージ</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href='#i1'>型変換</a></td>
<td>実行可能性</td>
<td>エラー</td>
<td>
<p>タイプ &lt;type&gt; の式をタイプ &lt;type&gt; のフィールドに変換できません。</p>
<p><b>ランタイム エラー:</b> タイプの例外</p>
</td>
</tr>
<tr>
<td><a href='#i2'>タイプの互換性</a></td>
<td>実行可能性</td>
<td>エラー</td>
<td>
<p>構成済みの式は、現在の形式要素をデータ ソースにバインドするために使用できません。この式が、現在の形式要素のタイプ &lt;type&gt; でサポートされているデータ型の範囲を超えたデータ型 &lt;type&gt; の値を返すためです。</p>
<p><b>ランタイム エラー:</b> タイプの例外</p>
</td>
</tr>
<tr>
<td><a href='#i3'>構成要素の欠落</a></td>
<td>実行可能性</td>
<td>エラー</td>
<td>
<p>パスが見つかりません &lt;path&gt;。</p>
<p><b>ランタイム エラー:</b> 構成要素 &lt;path&gt; が見つかりません</p>
</td>
</tr>
<tr>
<td><a href='#i4'>FILTER 関数による式の実行可能性</a></td>
<td>実行可能性</td>
<td>エラー</td>
<td>
<p>FILTER 関数のリスト式がクエリ可能ではありません。</p>
<p><b>ランタイム エラー:</b> フィルター処理はサポートされていません。 構成を検証して、詳細を取得します。</p>
</td>
</tr>
<tr>
<td rowspan='2'><a href='#i5'>GROUPBY データ ソースの実行可能性</a></td>
<td>実行可能性</td>
<td>エラー</td>
<td>パス &lt;path&gt; は、クエリをサポートしていません。</td>
</tr>
<tr>
<td>実行可能性</td>
<td>エラー</td>
<td>
<p>Group by 関数はクエリで実行できません。</p>
<p><b>ランタイム エラー:</b> Group by 関数はクエリで実行できません。</p>
</td>
</tr>
<tr>
<td><a href='#i6'>JOIN データ ソースの実行可能性</a></td>
<td>実行可能性</td>
<td>エラー</td>
<td>
<p>クエリのフィルターではないリスト &lt;path&gt; を結合できません。</p>
<p><b>ランタイム エラー:</b> 関数結合された datasource は、計算済フィールドが正しく呼び出されていないフィルター式である必要があります。</p>
</td>
</tr>
<tr>
<td><a href='#i7'>FILTER 関数 対 WHERE 関数の優先度</a></td>
<td>パフォーマンス</td>
<td>警告</td>
<td>パフォーマンスの観点から、式には WHERE 関数よりも FILTER 関数を使用することをお勧めします。 [修正] を選択すると、自動的に置換します。</td>
</tr>
<tr>
<td><a href='#i8'>ALLITEMSQUERY 関数 対 ALLITEMS 関数の優先度</a></td>
<td>パフォーマンス</td>
<td>警告</td>
<td>パフォーマンスの観点から、式には ALLITEMS 関数よりも ALLITEMSQUERY 関数を使用することをお勧めします。 [修正] を選択すると、自動的に置換します。</td>
</tr>
<tr>
<td><a href='#i9'>空リストの場合の考慮</a></td>
<td>実行可能性</td>
<td>警告</td>
<td>
<p>リスト &lt;パス&gt; に空リストの場合のチェックがなく、実行時にエラーが発生する可能性があります。 空リストの場合のチェックを追加します。</p>
<p><b>ランタイム エラー:</b> リストは &lt;path&gt; で空です</p>
<p><b><a href='#i9a'>潜在的な問題</a>:</b> 入力元のデータ ソースに複数のレコードが含まれているときに、行が 1 回入力されます</p>
</td>
</tr>
<tr>
<td><a href='#i10'>FILTER 関数による式の実行可能性 (キャッシュ)</a></td>
<td>実行可能性</td>
<td>エラー</td>
<td>
<p>FILTER 関数を、選択したデータ ソースのタイプに適用することはできません。 テーブル レコード タイプのデータ ソースは、キャッシュされておらず、入れ子にされたデータ ソースが手動で追加されていない場合にのみ適用できます。</p>
<p><b>ランタイム エラー:</b> フィルター処理はサポートされていません。 構成を検証して、詳細を取得します。</p>
</td>
</tr>
<tr>
<td><a href='#i11'>バインドの欠落</a></td>
<td>実行可能性</td>
<td>警告</td>
<td>
<p>パス &lt;path&gt; は、モデルのマッピングを使用しているどの datasource にもバインドされません。</p>
<p><b>ランタイム エラー:</b> パス &lt;path&gt; がバインドされていません</p>
</td>
</tr>
<tr>
<td><a href='#i12'>リンクされていないテンプレート</a></td>
<td>データの整合性</td>
<td>警告</td>
<td>ファイル &lt;name&gt; はファイル コンポーネントにリンクされておらず、構成バージョンの状態の変更後に削除されます。</td>
</tr>
<tr>
<td><a href='#i13'>未同期形式</a></td>
<td>データの整合性</td>
<td>警告</td>
<td>定義名 &lt;component name&gt; は Excel シート &lt;sheet name&gt; には存在しません</td>
</tr>
</tbody>
</table>

## <a name="type-conversion"></a><a id="i1"></a>型変換

ER では、データ モデル フィールドのデータ型が、そのフィールドのバインドとして構成されている式のデータ型と互換性があるかどうかを確認します。 データ型に互換性がない場合は、ER モデル マッピング デザイナーで検証エラーが発生します。 受信するメッセージは、ER がタイプ A の式をタイプ B のフィールドに変換できないことを示しています。

次の手順は、この問題がどのように発生するかを示しています。

1. ER データ モデルと ER モデル マッピング コンポーネントの構成を同時に開始します。
2. データ モデル ツリーで、**X** という名前のフィールドを追加 し、データ型として **整数** を選択します。

    ![データ モデル ページのデータ モード ツリーに追加された X フィールドおよび整数データ型](./media/er-components-inspections-01.png)

3. モデル マッピング データ ソース ペインで、**計算済フィールド** タイプのデータ ソースを追加します。
4. 新しいデータソースに **Y** と名前を付けて、式 `INTVALUE(100)` を含むように構成します。
5. **X** を **Y** にバインドします。
6. データ モデル デザイナーで、**X** フィールドのデータ型を **整数** から **Int64** に変更します。
7. **検証** を選択して、**モデル マッピング デザイナー** ページで編集可能なモデル マッピング コンポーネントを検査します。

    ![モデル マッピング デザイナー ページで編集可能なモデル マッピング コンポーネントを検証する](./media/er-components-inspections-01.gif)

8. **検証** を選択して、**構成** ページで選択した ER 構成のモデル マッピング コンポーネントを検査します。

    ![検証して、構成ページでモデル マッピング コンポーネントを検査します](./media/er-components-inspections-01a.png)

9. 検証エラーが発生することに注意してください。 このメッセージは、**Y** データ ソースの `INTVALUE(100)` 式が返す **整数** タイプの値を、**Int64** タイプの **X** データ モデル フィールドに格納できないことを示しています。

次の図は、警告を無視し、**実行** を選択して、モデル マッピングを使用するように構成された形式を実行した場合に発生するランタイム エラーを示しています。

![フォーマット デザイナー ページのランタイム エラー](./media/er-components-inspections-01b.png)

### <a name="automatic-resolution"></a>自動解決

この問題を自動的に修正するオプションはありません。

### <a name="manual-resolution"></a>手動解決

#### <a name="option-1"></a>オプション 1

データ モデル フィールドのデータ型を変更して、そのフィールドのバインドに対して構成された式のデータ型と一致するように、データ モデルの構造を更新します。 前の例では、**X** フィールドのデータ型を **整数** に戻す必要があります。

#### <a name="option-2"></a>オプション 2

データ モデル フィールドに関連付けられたデータ ソースの式を変更することにより、モデル マッピングを更新します。 前の例では、**Y** データ ソースの式を `INT64VALUE(100)` に変更する必要があります。

## <a name="type-compatibility"></a><a id="i2"></a>タイプの互換性

ER では、形式要素のデータ型が、その形式要素のバインドとして構成されている式のデータ型と互換性があるかどうかを確認します。 データ型に互換性がない場合は、ER 操作デザイナーで検証エラーが発生します。 受信するメッセージは、構成済みの式が現在の形式要素をデータ ソースにバインドするために使用できないことを示しています。これは、式が、現在の形式要素のタイプ Bでサポートされているデータ型の範囲を超えるデータ型 A の値を返すためです。

次の手順は、この問題がどのように発生するかを示しています。

1. ER データ モデルと ER 形式コンポーネントの構成を同時に開始します。
2. データ モデル ツリーで、**X** という名前のフィールドを追加 し、データ型として **整数** を選択します。
3. 形式構造ツリーで、**数値** タイプの形式要素を追加します。
4. 新しい形式要素 **Y** に名前を付けます。**数値タイプ** フィールドで、データ型として **整数** を選択します。
5. **X** を **Y** にバインドします。
6. 形式構造ツリーで、**Y** 形式要素のデータ型を **整数** から **Int64** に変更します。
7. **検証** を選択して、**形式デザイナー** ページで編集可能な形式コンポーネントを検査します。

    ![形式デザイナー ページでタイプの互換性を検証する](./media/er-components-inspections-02.gif)

8. 検証エラーが発生することに注意してください。 メッセージは、構成済みの式が **Int64** 値のみを受け入れることができることを示しています。 したがって、**整数** タイプの **X** データ モデル フィールドの値を **Y** 形式要素に入力することはできません。

### <a name="automatic-resolution"></a>自動解決

この問題を自動的に修正するオプションはありません。

### <a name="manual-resolution"></a>手動解決

#### <a name="option-1"></a>オプション 1

**数値** 形式要素のデータ型を変更して、その要素のバインドに対して構成された式のデータ型と一致するように、形式構造を更新します。 前の例では、**X** 形式要素の **数値タイプ** の値を **整数** に戻す必要があります。

#### <a name="option-2"></a>オプション 2

`model.X` から `INT64VALUE(model.X)` に式をに変更して、**X** 形式要素の形式マッピングを更新します。

## <a name="missing-configuration-element"></a><a id="i3"></a>構成要素の欠落

ER は、編集可能な ER コンポーネントで構成されているデータソースだけがバインド式に含まれているかどうかをを確認します。 編集可能な ER コンポーネントに存在しないデータ ソースを含むすべてのバインドで、ER 操作デザイナーまたは ER モデル マッピング デザイナーで検証エラーが発生します。

次の手順は、この問題がどのように発生するかを示しています。

1. ER データ モデルと ER モデル マッピング コンポーネントの構成を同時に開始します。
2. データ モデル ツリーで、**X** という名前のフィールドを追加 し、データ型として **整数** を選択します。

    ![データ モデル ページに X フィールドと整数データ型があるデータ モード ツリー](./media/er-components-inspections-01.png)

3. モデル マッピング データ ソース ペインで、**計算済フィールド** タイプのデータ ソースを追加します。
4. 新しいデータソースに **Y** と名前を付けて、式 `INTVALUE(100)` を含むように構成します。
5. **X** を **Y** にバインドします。
6. モデル マッピング デザイナーのデータ ソース ペインで、**Y** データ ソースを削除します。
7. **検証** を選択して、**モデル マッピング デザイナー** ページで編集可能なモデル マッピング コンポーネントを検査します。

    ![モデル マッピング デザイナー ページで編集可能な ER モデル マッピング コンポーネントを検査する](./media/er-components-inspections-03.gif)

8. 検証エラーが発生することに注意してください。 メッセージは、**X** データ モデル フィールドのバインドに **Y** データソースを参照するパスが含まれているが、このデータ ソースは見つからないことを示しています。

### <a name="automatic-resolution"></a>自動解決

**バインドの解除** を選択して、欠落したデータ ソース バインドを削除することで、この問題を自動的に修正します。

### <a name="manual-resolution"></a>手動解決

#### <a name="option-1"></a>オプション 1

**X** データ モデル フィールドのバインドを解除して、存在しない **Y** データ ソースを参照しないようにします。

#### <a name="option-2"></a>オプション 2

ER モデル マッピング デザイナーのデータ ソース ペインで、**Y** データ ソースを再度追加します。

## <a name="executability-of-an-expression-with-filter-function"></a><a id="i4"></a>FILTER 関数による式の実行可能性

組み込み [FILTER](er-functions-list-filter.md) ER 関数は、アプリケーション テーブル、ビュー、またはデータ エンティティにアクセスするために使用され、1 回の SQL 呼び出しを行うことで、必要なデータをレコードの一覧として取得します。 **レコード リスト** タイプのデータソース は、この関数の引数として使用され、呼び出しのアプリケーション ソースを指定します。 ERは、`FILTER` 関数で参照されるデータ ソースに対して直接 SQL クエリを確立できるかどうかを確認します。 直接クエリを確立できない場合、ER モデル マッピング デザイナーで検証エラーが発生します。 受信するメッセージは、`FILTER` 関数を含む ER 式を実行時に実行できないことを示しています。 

次の手順は、この問題がどのように発生するかを示しています。

1. ER モデル マッピング コンポーネントの構成を開始します。
2. **Dynamics 365 for Operations \\ テーブル レコード** タイプのデータ ソースを追加します。
3. 新しいデータ ソースに **Vendor** と名前を付けます。 **テーブル** フィールドで、**VendTable** を選択して、このデータ ソースが VendTable テーブルを要求するように指定します。
4. **計算済フィールド** タイプのデータ ソースを追加します。
5. 新しいデータ ソースに **FilteredVendor** と名前を付けて、式 `FILTER(Vendor, Vendor.AccountNum="US-101")` を含むように構成します。
6. **検証** を選択して、**モデル マッピング デザイナー** ページで編集可能なモデル マッピング コンポーネントを検査し、**Vendor** データ ソースの `FILTER(Vendor, Vendor.AccountNum="US-101")` 式を照会できることを確認します。
7. **計算済フィールド** タイプの入れ子になったフィールドを追加して、**Vendor** データ ソースを変更し、トリムされた仕入先番号を取得します。
8. 新しい入れ子になったフィールドに **$AccNumber** と名前を付けて、式 `TRIM(Vendor.AccountNum)` を含むように構成します。
9. **検証** を選択して、**モデル マッピング デザイナー** ページで編集可能なモデル マッピング コンポーネントを検査し、**Vendor** データ ソースの `FILTER(Vendor, Vendor.AccountNum="US-101")` 式を照会できることを確認します。

    ![モデル マッピング デザイナー ページで式を照会できることを確認する](./media/er-components-inspections-04.gif)

10. **Vendor** データ ソースには、**FilteredVendor** データソースの式を直接 SQL ステートメントに変換できない **計算済フィールド** タイプの入れ子になったフィールドが含まれているため、検証エラーが発生することに注意してください。

次の図は、警告を無視し、**実行** を選択して、モデル マッピングを使用するように構成された形式を実行した場合に発生するランタイム エラーを示しています。

![形式デザイナー ページで編集可能な形式を実行したときに発生するランタイム エラー](./media/er-components-inspections-04a.png)

### <a name="automatic-resolution"></a>自動解決

この問題を自動的に修正するオプションはありません。

### <a name="manual-resolution"></a>手動解決

#### <a name="option-1"></a>オプション 1

**計算済フィールド** タイプの入れ子になったフィールドを **Vendor** データ ソースに追加するのではなく、**$AccNumber** の入れ子になったフィールドを **FilteredVendor** データ ソースに追加し、式 `TRIM(FilteredVendor.AccountNum)` を含むように構成します。 このようにして、`FILTER(Vendor, Vendor.AccountNum="US-101")` 式を SQL レベルで実行し、**$AccNumber** の入れ子になったフィールドを後で計算することができます。

#### <a name="option-2"></a>オプション 2

**FilteredVendor** データ ソースの式を `FILTER(Vendor, Vendor.AccountNum="US-101")` から `WHERE(Vendor, Vendor.AccountNum="US-101")` に変更します。 すべてのレコードがフェッチされ、必要なレコードの選択がメモリ内で行われるため、大量のデータ (トランザクション テーブル) があるテーブルの式を変更することはお勧めしません。 したがって、この方法ではパフォーマンスが低下する可能性があります。 詳細については、[WHERE ER 関数](er-functions-list-where.md) を参照してください。

## <a name="executability-of-a-groupby-data-source"></a><a id="i5"></a>GROUPBY データ ソースの実行可能性

**GROUPBY** データ ソースは、通常は各グループで 1 つ以上の集計を実行する目的で、クエリ結果をレコードのグループに分割します。 すべての **GROUPBY** データ ソースは、データベース レベルまたはメモリ内のいずれかで実行されるように構成できます。 **GROUPBY** データ ソースが、データベース レベルで実行されるように構成されている場合、ER はそのデータ ソースで参照されているデータ ソースに対して直接 SQL クエリを確立できるかどうかを確認します。 直接クエリを確立できない場合、ER モデル マッピング デザイナーで検証エラーが発生します。 受信するメッセージは、構成された **GROUPBY** データ ソースを実行時に実行できないことを示しています。

次の手順は、この問題がどのように発生するかを示しています。

1. ER モデル マッピング コンポーネントの構成を開始します。
2. **Dynamics 365 for Operations \\ テーブル レコード** タイプのデータ ソースを追加します。
3. 新しいデータ ソースに **Trans** と名前を付けます。**テーブル** フィールドで、**VendTrans** を選択して、このデータ ソースが VendTrans テーブルを要求するように指定します。
4. **Group by** タイプのデータ ソースを追加します。
5. 新しいデータ ソースに **GroupedTrans** と名前を付けて、次のように構成します:

    - グループ化するレコードのソースとして **Trans** データ ソースを選択します。
    - **実行場所** フィールドで **クエリ** を選択し、このデータ ソースをデータベース レベルで実行することを指定します。

    !['Group By' パラメーターの編集ページでデータ ソースの構成](./media/er-components-inspections-05a.gif)

6. **検証** を選択して、**モデル マッピング デザイナー** ページで編集可能なモデル マッピング コンポーネントを検査し、構成済み **GroupedTrans** データ ソースを照会できることを確認します。
7. **計算済フィールド** タイプの入れ子になったフィールドを追加して、**Trans** データ ソースを変更し、トリムされた仕入先番号を取得します。
8. 新しいデータ ソースに **$AccNumber** と名前を付けて、式 `TRIM(Trans.AccountNum)` を含むように構成します。

    ![モデル マッピング デザイナー ページでのデータ ソースの構成](./media/er-components-inspections-05a.png)

9. **検証** を選択して、**モデル マッピング デザイナー** ページで編集可能なモデル マッピング コンポーネントを検査し、構成済み **GroupedTrans** データ ソースを照会できることを確認します。

    ![ER モデル マッピング コンポーネントを検証し、構成済みデータ ソース GroupedTrans をモデル マッピング デザイナ ページで照会できることを確認する](./media/er-components-inspections-05b.png)

10. **Trans** データ ソースには、**GroupedTrans** データソースの呼び出しを直接 SQL ステートメントに変換できない **計算済フィールド** タイプの入れ子になったフィールドが含まれているため、検証エラーが発生することに注意してください。

次の図は、警告を無視し、**実行** を選択して、モデル マッピングを使用するように構成された形式を実行した場合に発生するランタイム エラーを示しています。

![形式デザイナー ページで警告を無視したときに発生するランタイム エラー](./media/er-components-inspections-05c.png)

### <a name="automatic-resolution"></a>自動解決

この問題を自動的に修正するオプションはありません。

### <a name="manual-resolution"></a>手動解決

#### <a name="option-1"></a>オプション 1

**計算済フィールド** タイプの入れ子になったフィールドを **Trans** データ ソースに追加するのではなく、**GroupedTrans** データ ソースの **GroupedTrans.lines** 項目に、**$AccNumber** の入れ子になったフィールドを追加し、式 `TRIM(GroupedTrans.lines.AccountNum)` を含むように構成します。 このようにして、**GroupedTrans** データ ソースを SQL レベルで実行し、**$AccNumber** の入れ子になったフィールドを後で計算することができます。

#### <a name="option-2"></a>オプション 2

**GroupedTrans** データ ソースの **実行場所** フィールドの値を **クエリ** から **メモリ内** に変更します。 すべてのレコードがフェッチされ、グループと集計がメモリ内で行われるため、大量のデータ (トランザクション テーブル) があるテーブルの値を変更することはお勧めしません。 したがって、この方法ではパフォーマンスが低下する可能性があります。

## <a name="executability-of-a-join-data-source"></a><a id="i6"></a>JOIN データ ソースの実行可能性

[JOIN](er-join-data-sources.md) データ ソースは、関連するフィールドに基づいて 2 つ以上のデータベース テーブルのレコードを組み合わせたものです。 すべての **JOIN** データ ソースは、データベース レベルまたはメモリ内のいずれかで実行されるように構成できます。 **JOIN** データ ソースが、データベース レベルで実行されるように構成されている場合、ER はそのデータ ソースで参照されているデータ ソースに対して直接 SQL クエリを確立できるかどうかを確認します。 1 つ以上の参照データ ソースで直接 SQL クエリを確立できない場合、ER モデル マッピング デザイナーで検証エラーが発生します。 受信するメッセージは、構成された **JOIN** データ ソースを実行時に実行できないことを示しています。

次の手順は、この問題がどのように発生するかを示しています。

1. ER モデル マッピング コンポーネントの構成を開始します。
2. **Dynamics 365 for Operations \\ テーブル レコード** タイプのデータ ソースを追加します。
3. 新しいデータ ソースに **Vendor** と名前を付けます。 **テーブル** フィールドで、**VendTable** を選択して、このデータ ソースが VendTable テーブルを要求するように指定します。
4. **Dynamics 365 for Operations \\ テーブル レコード** タイプのデータ ソースを追加します。
5. 新しいデータ ソースに **Trans** と名前を付けます。**テーブル** フィールドで、**VendTrans** を選択して、このデータ ソースが VendTrans テーブルを要求するように指定します。
6. **計算済フィールド** タイプのデータソースを **Vendor** データソースの入れ子になったフィールドとして追加します。
7. 新しいデータ ソースに **FilteredTrans** と名前を付けて、式 `FILTER(Trans, Trans.AccountNum=Vendor.AccountNum)` を含むように構成します。
8. **Join** タイプのデータ ソースを追加します。
9. 新しいデータ ソースに **JoinedList** と名前を付けて、次のように構成します:

    1. **Vendor** データ ソースを、結合するレコードの最初のセットとして追加します。
    2. **Vendor.FilteredTrans** データ ソースを、結合するレコードの 2 番目のセットとして追加します。 タイプとして **INNER** を選択します。
    3. **実行** フィールドで **クエリ** を選択し、このデータ ソースをデータベース レベルで実行することを指定します。

    ![Join デザイナー ページでのデータ ソースの構成](./media/er-components-inspections-06a.gif)

10. **検証** を選択して、**モデル マッピング デザイナー** ページで編集可能なモデル マッピング コンポーネントを検査し、構成済み **JoinedList** データ ソースを照会できることを確認します。
11. **Vendor.FilteredTrans** データ ソースの式を `FILTER(Trans, Trans.AccountNum=Vendor.AccountNum)` から `WHERE(Trans, Trans.AccountNum=Vendor.AccountNum)` に変更します。
12. **検証** を選択して、**モデル マッピング デザイナー** ページで編集可能なモデル マッピング コンポーネントを検査し、構成済み **JoinedList** データ ソースを照会できることを確認します。

    ![編集可能なモデル マッピング コンポーネントを検証し、モデル マッピング デザイナー ページで JoinedList データ ソースを照会できることを確認します](./media/er-components-inspections-06b.png)

13. **Vendor.FilteredTrans** データ ソースの式を直接 SQL 呼び出しに変換できないため、検証エラーが発生することに注意してください。 さらに、直接 SQL 呼び出しでは、**JoinedList** データソースに対する呼び出しを、直接 SQL ステートメントに変換することはできません。

    ![モデル マッピング デザイナー ページで JoinedList データ ソースの検証に失敗したため発生したランタイム エラー](./media/er-components-inspections-06c.png)

次の図は、警告を無視し、**実行** を選択して、モデル マッピングを使用するように構成された形式を実行した場合に発生するランタイム エラーを示しています。

![形式デザイナー ページでの編集可能な形式の実行](./media/er-components-inspections-06e.png)

### <a name="automatic-resolution"></a>自動解決

この問題を自動的に修正するオプションはありません。

### <a name="manual-resolution"></a>手動解決

#### <a name="option-1"></a>オプション 1

警告に従って、**Vendor.FilteredTrans** データ ソースの式を `WHERE(Trans, Trans.AccountNum=Vendor.AccountNum)` から `FILTER(Trans, Trans.AccountNum=Vendor.AccountNum)` に戻します。

![モデル マッピング デザイナー ページでデータ ソースの式を更新](./media/er-components-inspections-06d.png)

#### <a name="option-2"></a>オプション 2

**JoinedList** データ ソースの **実行** フィールドの値を **クエリ** から **メモリ内** に変更します。 すべてのレコードがフェッチされ、結合がメモリ内で行われるため、大量のデータ (トランザクション テーブル) があるテーブルの値を変更することはお勧めしません。 したがって、この方法ではパフォーマンスが低下する可能性があります。 このリスクを通知する検証警告が表示されます。

## <a name="preferability-of-filter-vs-where-function"></a><a id="i7"></a>FILTER 関数 対 WHERE 関数の優先度

組み込み [FILTER](er-functions-list-filter.md) ER 関数は、アプリケーション テーブル、ビュー、またはデータ エンティティにアクセスするために使用され、1 回の SQL 呼び出しを行うことで、必要なデータをレコードの一覧として取得します。 [WHERE](er-functions-list-where.md) 関数は、指定されたソースからすべてのレコードをフェッチし、メモリ内でレコード選択を行います。 **レコード リスト** タイプのデータ ソースは、両方の関数の引数として使用され、レコードを取得するためのソースを指定します。 ERは、**WHERE** 関数で参照されるデータ ソースに対して直接 SQL 呼び出しを確立できるかどうかを確認します。 直接呼び出しを確立できる場合、ER モデル マッピング デザイナーで検証警告が発生します。 受信するメッセージは、効率を向上させるために、**WHERE** 関数の代わりに **FILTER** 関数を使用することを推奨しています。

次の手順は、この問題がどのように発生するかを示しています。

1. ER モデル マッピング コンポーネントの構成を開始します。
2. **Dynamics 365 for Operations \\ テーブル レコード** タイプのデータ ソースを追加します。
3. 新しいデータ ソースに **Trans** と名前を付けます。**テーブル** フィールドで、**VendTrans** を選択して、このデータ ソースが VendTrans テーブルを要求するように指定します。
4. **計算済フィールド** タイプのデータソースを **Vendor** データソースの入れ子になったフィールドとして追加します。
5. 新しいデータ ソースに **FilteredTrans** と名前を付けて、式 `WHERE(Trans, Trans.AccountNum="US-101")` を含むように構成します。
6. **Dynamics 365 for Operations \\ テーブル レコード** タイプのデータ ソースを追加します。
7. 新しいデータ ソースに **Vendor** と名前を付けます。 **テーブル** フィールドで、**VendTable** を選択して、このデータ ソースが VendTable テーブルを要求するように指定します。
8. **計算済フィールド** タイプのデータ ソースを追加します。
9. 新しいデータ ソースに **FilteredVendor** と名前を付けて、式 `WHERE(Vendor, Vendor.AccountNum="US-101")` を含むように構成します。
10. **検証** を選択して、**モデル マッピング デザイナー** ページで編集可能なモデル マッピング コンポーネントを検査します。

    ![検証して、モデル マッピング デザイナー ページで編集可能なモデル マッピング コンポーネントを検査する](./media/er-components-inspections-07a.png)

11. 検証の警告は、**FilteredVendor** および **FilteredTrans** データソースに対して **WHERE** 関数ではなく **FILTER** 機能を使用することを推奨しています。

    ![モデル マッピング デザイナー ページで、WHERE 関数の代わりに FILTER 関数を推奨する検証警告](./media/er-components-inspections-07b.png)

### <a name="automatic-resolution"></a>自動解決

**修正** を選択して、このタイプの検査の **警告** タブにあるグリッドに表示されるすべてのデータ ソースの式で、**WHERE** 関数を **FILTER** 関数に自動的に置き換えます。

または、グリッドで 1 つの警告の行を選択し、**選択した修正** を選択することもできます。 この場合、式は、選択された警告で説明されているデータ ソースでのみ自動的に変更されます。

![[修正] を選択すると、モデル マッピング デザイナー ページで、WHERE 関数が FILTER 関数に自動的に置き換えられます](./media/er-components-inspections-07c.png)

### <a name="manual-resolution"></a>手動解決

**WHERE** 関数を **FILTER** 関数に置き換えることで、検証グリッド内のすべてのデータ ソースの式を手動で調整できます。

## <a name="preferability-of-allitemsquery-vs-allitems-function"></a><a id="i8"></a>ALLITEMSQUERY 関数 対 ALLITEMS 関数の優先度

組み込みの [ALLITEMS](er-functions-list-allitems.md) と [ALLITEMSQUERY](er-functions-list-allitemsquery.md) ER 関数は、指定したパスに一致するすべての項目を表すレコードの一覧から成るフラット化された **レコード リスト** の値を返します。 ER は、**ALLITEMS** 関数で参照されるデータ ソースに対して直接 SQL 呼び出しを確立できるかどうかを確認します。 直接呼び出しを確立できる場合、ER モデル マッピング デザイナーで検証警告が発生します。 受信するメッセージは、効率を向上させるために、**ALLITEMS** 関数の代わりに **ALLITEMSQUERY** 関数を使用することを推奨しています。

次の手順は、この問題がどのように発生するかを示しています。

1. ER モデル マッピング コンポーネントの構成を開始します。
2. **Dynamics 365 for Operations \\ テーブル レコード** タイプのデータ ソースを追加します。
3. 新しいデータ ソースに **Vendor** と名前を付けます。 **テーブル** フィールドで、**VendTable** を選択して、このデータ ソースが VendTable テーブルを要求するように指定します。
4. **計算済みフィールド** タイプのデータ ソースを追加して、複数の仕入先のレコードを取得します。
5. 新しいデータ ソースに **FilteredVendor** と名前を付けて、式 `FILTER(Vendor, OR(Vendor.AccountNum="US-101",Vendor.AccountNum="US-102"))` を含むように構成します。
6. **計算済みフィールド** タイプのデータ ソースを追加して、フィルターされたすべての仕入先のトランザクションを取得します。
7. 新しいデータ ソースに **FilteredVendorTrans** と名前を付けて、式 `ALLITEMS(FilteredVendor.'<Relations'.'VendTrans.VendTable_AccountNum')` を含むように構成します。
8. **検証** を選択して、**モデル マッピング デザイナー** ページで編集可能なモデル マッピング コンポーネントを検査します。

    ![モデル マッピング デザイナー ページ、[検証] ボタン](./media/er-components-inspections-08a.png)

9. 検証警告が発生することに注意してください。 このメッセージでは、**FilteredVendorTrans** データ ソースに **ALLITEMS** 関数の代わりに **ALLITEMSQUERY** 関数を使用することを推奨しています。

    ![モデル マッピング デザイナー ページの ER モデル マッピング コンポーネントで、ALLITEMS 関数の代わりに ALLITEMSQUERY 関数を使用する場合の検証警告](./media/er-components-inspections-08b.png)

### <a name="automatic-resolution"></a>自動解決

**修正** を選択して、このタイプの検査の **警告** タブにあるグリッドに表示されるすべてのデータ ソースの式で、**ALLITEMS** 関数を **ALLITEMSQUERY** 関数に自動的に置き換えます。

または、グリッドで 1 つの警告の行を選択し、**選択した修正** を選択することもできます。 この場合、式は、選択された警告で説明されているデータ ソースでのみ自動的に変更されます。

![モデル マッピング デザイナー ページで、[選択した修正] を選択する](./media/er-components-inspections-08c.png)

### <a name="manual-resolution"></a>手動解決

**ALLITEMS** 関数を **ALLITEMSQUERY** 関数に置き換えることで、検証グリッドに記載されているすべてのデータ ソースの式を手動で調整できます。

## <a name="consideration-of-empty-list-cases"></a><a id="i9"></a>空リストの場合の考慮

ER 形式またはモデル マッピング コンポーネントを構成して、**レコード リスト** タイプのデータ ソースのフィールド値を取得することができます。 ERは、存在しないレコードのフィールドから値がフェッチされるときのランタイム エラーを防ぐために、呼び出されるデータ ソースにレコードが含まれていない (つまり空である) 場合を考慮して設計されているかどうかを確認します。

次の手順は、この問題がどのように発生するかを示しています。

1. ER データ モデル、ER モデル マッピング、 ER 形式コンポーネントの構成を同時に開始します。
2. データ モデル ツリーで、**Root3** という名前のルート項目を追加します。
3. **レコード リスト** タイプの入れ子になった項目を追加して、**Root3** 項目を変更します。
4. 新しい入れ子になった項目 **Vendor** に名前を付けます。
5. 次の方法で **Vendor** 項目を変更します:

    - **文字列** タイプの入れ子になったフィールドを追加し、**Name** と名前を付けます。
    - **文字列** タイプの入れ子になったフィールドを追加し、**AccountNumber** と名前を付けます。

    ![データ モデル ページで入れ子になったフィールドの追加](./media/er-components-inspections-09a.png)

6. モデル マッピング データ ソース ペインで、**Dynamics 365 for Operations \\ テーブル レコード** タイプのデータ ソースを追加します。
7. 新しいデータ ソースに **Vendor** と名前を付けます。 **テーブル** フィールドで、**VendTable** を選択して、このデータ ソースが VendTable テーブルを要求するように指定します。
8. **全般 \\ ユーザー入力パラメーター** タイプのデータ ソースを追加し、ランタイム ダイアログ ボックスで仕入先アカウントを検索します。
9. 新しいデータ ソースに **RequestedAccountNum** と名前を付けます。 **ラベル** フィールドに、**仕入先番号** を入力します。 **操作のデータ型名** フィールドは、既定値の **説明** のままにします。
10. **計算済フィールド** タイプのデータ ソースを追加して、照会する仕入先をフィルター処理します。
11. 新しいデータ ソースに **FilteredVendor** と名前を付けて、式 `FILTER(Vendor, Vendor.AccountNum=RequestedAccountNum)` を含むように構成します。
12. 次の方法で、構成されたデータ ソースにデータ モデル項目をバインドします:

    - **FilteredVendor** を **Vendor** にバインドします。
    - **FilteredVendor.AccountNum** を **Vendor.AccountNumber** にバインドします。
    - **FilteredVendor.'name()'** を **Vendor.Name** にバインドします。

    ![モデル マッピング デザイナー ページでのデータ モデル項目のバインド](./media/er-components-inspections-09b.png)

13. 形式構造ツリーで、次の項目を追加して、仕入先の詳細を含む送信ドキュメントを XML 形式で生成します:

    1. **Statement** ルート XML 要素を追加します。
    2. **Statement** XML 要素の場合は、入れ子になった **Party** XML 要素を追加します。
    3. **Party** XML 要素の場合は、次の入れ子になった XML 属性を追加します:

        - 氏名
        - AccountNum

14. 次の方法で、形式要素を指定されたデータ ソースにバインドします:

    - **Statement\\Party\\Name** 形式要素を **model.Vendor.Name** データ ソース フィールドにバインドします。
    - **Statement\\Party\\AccountNum** 形式要素を **model.Vendor.AccountNumber** データ ソース フィールドにバインドします。

15. **検証** を選択して、**形式デザイナー** ページで編集可能な形式コンポーネントを検査します。

    ![形式デザイナー ページでデータ ソースにバインドした形式要素の検証](./media/er-components-inspections-09c.png)

16. 検証エラーが発生することに注意してください。 メッセージは、`model.Vendor` リストが空の場合、実行時に、構成済みの **Statement\\Party\\Name** と **Statement\\Party\\AccountNum** に対してエラーがスローされる可能性があることを示しています。

    ![構成済みの形式コンポーネントの潜在的なエラーを通知する検証エラー](./media/er-components-inspections-09d.png)

次の図は、警告を無視し、**実行** を選択して形式を実行し、存在しない仕入先のアカウント番号を選択した場合に発生するランタイム エラーを示しています。 要求された仕入先が存在しないため、`model.Vendor` リストは空になります (つまり、レコードが含まれていません)。

![形式マッピングの実行中に発生したランタイム エラー](./media/er-components-inspections-09e.png)

### <a name="automatic-resolution"></a>自動解決

**警告** タブのグリッドで選択した行に対して、**バインドの解除** を選択できます。 **パス** 列でポイントされているバインドは、形式要素から自動的に削除されます。

### <a name="manual-resolution"></a>手動解決

#### <a name="option-1"></a>オプション 1

**Statement\\Party\\Name** 形式要素を `model.Vendor` データ ソース項目にバインドできます。 実行時に、このバインドは `model.Vendor` データ ソースを最初に呼び出します。 `model.Vendor` が、空のレコード リストを返す場合、入れ子になった形式要素は実行されません。 したがって、この形式構成に対して検証警告は発生しません。

![形式デザイナー ページで形式要素をデータ ソース項目にバインドする](./media/er-components-inspections-09e.gif)

#### <a name="option-2"></a>オプション 2

**Statement\\Party\\Name** 形式要素のバインドを `model.Vendor.Name` から `FIRSTORNULL(model.Vendor).Name` に変更します。 更新されたバインドは、**レコード リスト** タイプの `model.Vendor` データ ソースの最初のレコードを、**レコード** タイプの新しいデータ ソースに条件付きで変換します。 この新しいデータ ソースには、同じセットのフィールドが含まれています。

- `model.Vendor` データ ソースに使用可能なレコードが少なくとも 1 つある場合、そのレコードのフィールドには、`model.Vendor` データ ソースの最初のレコードのフィールドの値が設定されます。 この場合、更新されたバインドは仕入先名を返します。
- それ以外の場合は、作成されたレコードのすべてのフィールドは、そのフィールドのデータ型の既定値が設定されます。 この場合は、**文字列** データ型の既定値として空白文字列を返します。

したがって、**Statement\\Party\\Name** の形式要素が、`FIRSTORNULL(model.Vendor).Name` 式にバインドされても、検証の警告は発生しません。

![変更されたバインドにより、形式デザイナー ページで検証の警告を解決する](./media/er-components-inspections-09f.gif)

#### <a name="option-3"></a>オプション 3

**レコード リスト** タイプの `model.Vendor` データ ソースが、レコードを返さないときに (テキスト この例では **使用できません**)、生成されるドキュメントに入力されるデータを明示的に指定する場合は、**Statement\\Party\\Name** 形式要素のバインドを `model.Vendor.Name` から `IF(NOT(ISEMPTY(model.Vendor)), model.Vendor.Name, "Not available")` に変更します。 式 `IF(COUNT(model.Vendor)=0, model.Vendor.Name, "Not available")` を使用することもできます。

### <a name="additional-consideration"></a><a id="i9a"></a>その他の考慮事項

検査では、別の潜在的な問題についても警告します。 既定では、**Statement\\Party\\Name** と **Statement\\Party\\AccountNum** の形式要素を **レコード リスト** タイプの `model.Vendor` データ ソースの適切なフィールドにバインドすると、これらのバインドが実行され、`model.Vendor` データ ソースの最初のレコードの適切なフィールドの値を取得します (リストが空でない場合)。

**Statement\\Party** 形式要素を `model.Vendor` データ ソースにバインドしていないため、形式の実行中に **Statement\\Party** 要素は、`model.Vendor` データ ソースの各レコードに対して反復処理されません。 代わりに、このリストに複数のレコードが含まれている場合、生成されるドキュメントには、レコード リストの最初のレコードからのみ情報が入力されます。 したがって、形式が `model.Vendor` データ ソースのすべての仕入先に関する情報で、生成されたドキュメントを埋めることが目的の場合に、問題が発生することがあります。 この問題を修正するには、**Statement\\Party** 要素を `model.Vendor` データ ソースにバインドします。

## <a name="executability-of-an-expression-with-filter-function-caching"></a><a id="i10"></a>FILTER 関数による式の実行可能性 (キャッシュ)

[FILTER](er-functions-list-filter.md) や [ALLITEMSQUERY](er-functions-list-allitemsquery.md) などの、複数の組み込み ER 関数は、アプリケーション テーブル、ビュー、またはデータ エンティティにアクセスするために使用され、1 回の SQL 呼び出しを行うことで、必要なデータをレコードの一覧として取得します。 **レコード リスト** タイプのデータソース は、これらの各関数の引数として使用され、呼び出しのアプリケーション ソースを指定します。 ERは、これらの関数の 1 つで参照されるデータ ソースに対して直接 SQL 呼び出しを確立できるかどうかを確認します。 データ ソースが [キャッシュ](trace-execution-er-troubleshoot-perf.md#improve-the-model-mapping-based-on-information-from-the-execution-trace) としてマークされているために直接呼び出しを確立できない場合、ER モデル マッピング デザイナーで検証エラーが発生します。 受信するメッセージは、これたの関数の 1 つを含む ER 式を実行時に実行できないことを示しています。

次の手順は、この問題がどのように発生するかを示しています。

1. ER モデル マッピング コンポーネントの構成を開始します。
2. **Dynamics 365 for Operations \\ テーブル レコード** タイプのデータ ソースを追加します。
3. 新しいデータ ソースに **Vendor** と名前を付けます。 **テーブル** フィールドで、**VendTable** を選択して、このデータ ソースが VendTable テーブルを要求するように指定します。
4. **全般 \\ ユーザー入力パラメーター** タイプのデータ ソースを追加し、ランタイム ダイアログ ボックスで仕入先アカウントを検索します。
5. 新しいデータ ソースに **RequestedAccountNum** と名前を付けます。 **ラベル** フィールドに、**仕入先番号** を入力します。 **操作のデータ型名** フィールドは、既定値の **説明** のままにします。
6. **計算済フィールド** タイプのデータ ソースを追加して、照会する仕入先をフィルター処理します。
7. 新しいデータ ソースに **FilteredVendor** と名前を付けて、式 `FILTER(Vendor, Vendor.AccountNum=RequestedAccountNum)` を含むように構成します。
8. 構成済み **Vendor** データ ソースをキャッシュとしてマークします。

    ![モデル マッピング デザイナー ページでモデル マッピング コンポーネントを構成する](./media/er-components-inspections-10a.gif)

9. **検証** を選択して、**モデル マッピング デザイナー** ページで編集可能なモデル マッピング コンポーネントを検査します。

    ![モデル マッピング デザイナー ページで、キャッシュ ベンダーのデータ ソースに適用されたフィルター機能を検証する](./media/er-components-inspections-10a.png)

10. 検証エラーが発生することに注意してください。 このメッセージは、**FILTER** 関数が、キャッシュされた **Vendor** データ ソースに適用できないことを示しています。

次の図は、警告を無視し **実行** を選択して、形式を実行した場合に、発生するランタイム エラーを示しています。

![形式デザイナー ページで形式マッピングの実行中に発生したランタイム エラー](./media/er-components-inspections-10b.png)

### <a name="automatic-resolution"></a>自動解決

この問題を自動的に修正するオプションはありません。

### <a name="manual-resolution"></a>手動解決

#### <a name="option-1"></a>オプション 1

**Vendor** データ ソースから **キャッシュ** フラグを削除します。 その後、**FilteredVendor** データ ソースは実行可能になりますが、VendTable テーブルで参照される **Vendor** データ ソースは、**FilteredVendor** データ ソースが呼び出されるたびにアクセスされます。

#### <a name="option-2"></a>オプション 2

**FilteredVendor** データ ソースの式を `FILTER(Vendor, Vendor.AccountNum="US-101")` から `WHERE(Vendor, Vendor.AccountNum="US-101")` に変更します。 この場合、VendTable テーブルで参照される **Vendor** データ ソースは、**Vendor** データ ソースの最初の呼び出し中にのみアクセスされます。 ただし、レコードの選択はメモリ内で行われます。 したがって、この方法ではパフォーマンスが低下する可能性があります。

## <a name="missing-binding"></a><a id="i11"></a>バインドの欠落

ER 形式コンポーネントを構成する場合、基本 ER データ モデルは ER 形式の既定のデータ ソースとして提供されます。 構成済み ER 形式を実行すると、基本モデルの [既定のモデル マッピング](er-country-dependent-model-mapping.md) が使用され、データ モデルにアプリケーション データが入力されます。 ER 形式デザイナーは、編集可能な形式の既定のモデル マッピングとして、現在選択されているモデル マッピングのどのデータ ソースにもバインドされていないデータ モデル項目に、形式要素をバインドした場合、警告を表示します。 このタイプのバインドは、実行される形式がバインド要素をアプリケーション データで埋めることができないため、実行時には実行できません。 したがって、実行時にエラーが発生します。

次の手順は、この問題がどのように発生するかを示しています。

1. ER データ モデル、ER モデル マッピング、 ER 形式コンポーネントの構成を同時に開始します。
2. データ モデル ツリーで、**Root3** という名前のルート項目を追加します。
3. **レコード リスト** タイプの新しい入れ子になった項目を追加して、**Root3** 項目を変更します。
4. 新しい入れ子になった項目 **Vendor** に名前を付けます。
5. 次の方法で **Vendor** 項目を変更します:

    - **文字列** タイプの入れ子になったフィールドを追加し、**Name** と名前を付けます。
    - **文字列** タイプの入れ子になったフィールドを追加し、**AccountNumber** と名前を付けます。

    ![データ モデル ページの仕入先項目に入れ子になったフィールドを追加します](./media/er-components-inspections-11a.png)

6. モデル マッピング データ ソース ペインで、**Dynamics 365 for Operations \\ テーブル レコード** タイプのデータ ソースを追加します。
7. 新しいデータ ソースに **Vendor** と名前を付けます。 **テーブル** フィールドで、**VendTable** を選択して、このデータ ソースが VendTable テーブルを要求するように指定します。
8. **全般 \\ ユーザー入力パラメーター** タイプのデータ ソースを追加し、ランタイム ダイアログ ボックスで仕入先アカウントについて照会します。
9 新しいデータ ソースに **RequestedAccountNum** と名前を付けます。 **ラベル** フィールドに、**仕入先番号** を入力します。 **操作のデータ型名** フィールドは、既定値の **説明** のままにします。
10. **計算済フィールド** タイプのデータ ソースを追加して、照会する仕入先をフィルター処理します。
11. 新しいデータ ソースに **FilteredVendor** と名前を付けて、式 `FILTER(Vendor, Vendor.AccountNum=RequestedAccountNum)` を含むように構成します。
12. 次の方法で、構成されたデータ ソースにデータ モデル項目をバインドします:

    - **FilteredVendor** を **Vendor** にバインドします。
    - **FilteredVendor.AccountNum** を **Vendor.AccountNumber** にバインドします。

    > [!NOTE]
    > **Vendor.Name** データ モデル フィールドはバインド解除されたままです。

    ![構成されたデータ ソースにバインドされたデータ モデル項目と、モデル マッピング デザイナー ページのデータ モード項目](./media/er-components-inspections-11b.png)

13. 形式構造ツリーで、次の項目を追加して、照会される仕入先の詳細を含む送信ドキュメントを XML 形式で生成します:

    1. **Statement** ルート XML 要素を追加します。
    2. **Statement** XML 要素の場合は、入れ子になった **Party** XML 要素を追加します。
    3. **Party** XML 要素の場合は、次の入れ子になった XML 属性を追加します:

        - 氏名
        - AccountNum

14. 次の方法で、形式要素を指定されたデータ ソースにバインドします:

    - **Statement\\Party** 形式要素を `model.Vendor` データ ソース項目にバインドします。
    - **Statement\\Party\\Name** 形式要素を **model.Vendor.Name** データ ソース フィールドにバインドします。
    - **Statement\\Party\\AccountNum** 形式要素を **model.Vendor.AccountNumber** データ ソース フィールドにバインドします。

15. **検証** を選択して、**形式デザイナー** ページで編集可能な形式コンポーネントを検査します。

    ![形式デザイナー ページで ER 形式コンポーネントを検証する](./media/er-components-inspections-11c.png)

16. 検証警告が発生することに注意してください。 メッセージは、**model.Vendor.Name** データ ソース フィールドが、形式で使用するように構成されているモデル マッピングのデータ ソースにバインドされていないことを示しています。 したがって、**Statement\\Party\\Name** 形式要素が実行時に入力されず、ランタイム例外が発生する可能性があります。

    ![形式デザイナー ページで ER 形式コンポーネントを検証する](./media/er-components-inspections-11d.png)

次の図は、警告を無視し **実行** を選択して、形式を実行した場合に、発生するランタイム エラーを示しています。

![形式デザイナー ページで編集可能な形式を実行する](./media/er-components-inspections-11e.png)

### <a name="automatic-resolution"></a>自動解決

この問題を自動的に修正するオプションはありません。

### <a name="manual-resolution"></a>手動解決

#### <a name="option-1"></a>オプション 1

**model.Vendor.Name** データ ソース フィールドにバインドを追加して、構成済みモデル マッピングを変更します。

#### <a name="option-2"></a>オプション 2

**Statement\\Party\\Name** 形式要素のバインドを削除することで、構成済みの形式を変更します。

## <a name="not-linked-template"></a><a id="i12"></a>リンクされていないテンプレート

テンプレートを使用して送信ドキュメントを生成するように ER 形式コンポーネントを [手動で](er-fillable-excel.md#manual-entry) 構成する場合は、**Excel\\File** 要素を手動で追加し、必要なテンプレートを編集可能なコンポーネントの添付ファイルとして追加して、追加された **Excel\\File** 要素で、その添付ファイルを選択する必要があります。 このようにして、実行時に追加された要素で選択したテンプレートを埋めるように指定します。 **ドラフト** [状態](general-electronic-reporting.md#component-versioning) で形式コンポーネントのバージョンを構成する場合は、編集可能なコンポーネントにテンプレートをいくつか追加し、**Excel\\File** 要素で各テンプレートを選択して、ER 形式を実行することができます。 このようにして、実行時にさまざまなテンプレートがどのように入力されるかを確認できます。 **Excel\\File** 要素で選択されていないテンプレートがある場合、ER 形式デザイナーは、編集可能な ER 形式コンポーネント バージョンの状態が **ドラフト** から **完了** に変更されるたときに、これらのテンプレートがそのバージョンから削除されることを警告します。

次の手順は、この問題がどのように発生するかを示しています。

1. ER 形式コンポーネントの構成を開始します。
2. 形式構造ツリーで、**Excel\\File** 要素を追加します。
3. 追加した **Excel\\File** 要素の場合、Excel ブック ファイル **A.xlsx** を添付ファイルとして追加します。 [ER パラメーター](electronic-reporting-er-configure-parameters.md#parameters-to-manage-documents) で構成されているドキュメント タイプを使用して、ER 形式テンプレートのストレージを指定します。
4. **Excel\\File** 要素の場合、別の Excel ブック ファイル **B.xlsx** を添付ファイルとして追加します。 ブック ファイル A に使用されているのと同じドキュメント タイプを使用します。
5. **Excel\\File** 要素で 、ブック ファイル A を選択します。
6. **検証** を選択して、**形式デザイナー** ページで編集可能な形式コンポーネントを検査します。

    ![形式デザイナー ページでブック ファイルの編集可能な形式コンポーネントを検証する](./media/er-components-inspections-12a.gif)

7. 検証警告が発生することに注意してください。 メッセージは、ブック ファイル **B.xlsx** がどのコンポーネントにもリンクされておらず、構成バージョンの状態が変更された後に削除されることを示しています。

### <a name="automatic-resolution"></a>自動解決

この問題を自動的に修正するオプションはありません。

### <a name="manual-resolution"></a>手動解決

**Excel\\File** 要素にリンクされていないテンプレートをすべて削除して、構成済みの形式を変更します。

## <a name="not-synced-format"></a><a id="i13"></a>未同期形式

Excel テンプレートを使用して送信ドキュメントを生成するように、ER 形式コンポーネントを [構成](er-fillable-excel.md) する場合は、**Excel\\File** 要素を手動で追加し、必要なテンプレートを編集可能なコンポーネントの添付ファイルとして追加して、追加された **Excel\\File** 要素で、その添付ファイルを選択できます。 このようにして、実行時に追加された要素で選択したテンプレートを埋めるように指定します。 追加した Excel テンプレートは外部で設計されているので、編集可能な ER 形式には、追加したテンプレートにない Excel 名が含まれる可能性があります。 ER 形式デザイナーは、追加した Excel テンプレートに含まれていない名前を参照する ER 形式要素のプロパティ間の不整合について警告します。

次の手順は、この問題がどのように発生するかを示しています。

1. ER 形式コンポーネントの構成を開始します。
2. 形式構造ツリーで、**Excel\\File** 要素 **Report** を追加します。
3. 追加した **Excel\\File** 要素の場合、Excel ブック ファイル **A.xlsx** を添付ファイルとして追加します。 [ER パラメーター](electronic-reporting-er-configure-parameters.md#parameters-to-manage-documents) で構成されているドキュメント タイプを使用して、ER 形式テンプレートのストレージを指定します。

    > [!IMPORTANT]
    > 追加した Excel ブックに名前 **ReportTitle** が含まれていないことを確認してください。

4. 次の **Excel\\Cell** 要素 **Title** を **Report** 要素の入れ子になった要素として追加します。 **Excel の範囲** フィールドに、**ReportTitle** を入力します。
5. **検証** を選択して、**形式デザイナー** ページで編集可能な形式コンポーネントを検査します。

    ![形式デザイナー ページで入れ子になった要素とフィールドを検証する](./media/er-components-inspections-13a.png)

6. 検証警告が発生することに注意してください。 メッセージは、名前 **ReportTitle** が、使用している Excel テンプレートのシート **Sheet1** に存在しないことを示しています。

    ![Excel テンプレートの Sheet1 に名前 ReportTitle が存在しないという検証警告](./media/er-components-inspections-13b.png)

### <a name="automatic-resolution"></a>自動解決

この問題を自動的に修正するオプションはありません。

### <a name="manual-resolution"></a>手動解決

#### <a name="option-1"></a>オプション 1

テンプレートから欠落している Excel 名を参照する要素をすべて削除して、構成済の形式を変更します。

#### <a name="option-2"></a>オプション 2

Excel テンプレートをインポートすることで、編集可能な ER 形式を [更新](er-fillable-excel.md#template-import) します。 編集可能な ER 形式の構造は、インポートした ER テンプレートの構造と [同期](modify-electronic-reporting-format-reapply-excel-template.md) されます。

### <a name="additional-consideration"></a>その他の考慮事項

[ビジネス ドキュメント管理](er-business-document-management.md) のテンプレート エディターで ER テンプレートと形式構造を同期する方法については、[ビジネス ドキュメント テンプレートの構造の更新](er-bdm-update-structure.md) を参照してください。

## <a name="additional-resources"></a>追加リソース

[ALLITEMS ER 関数](er-functions-list-allitems.md)

[ALLITEMSQUERY ER 関数](er-functions-list-allitemsquery.md)

[INT64VALUE ER 関数](er-functions-conversion-int64value.md)

[INTVALUE ER 関数](er-functions-conversion-intvalue.md)

[FILTER ER 関数](er-functions-list-filter.md)

[WHERE ER 関数](er-functions-list-where.md)

[JOIN データ ソースを使用して、ER モデル マッピングで複数のアプリケーション テーブルからデータを取得する](er-join-data-sources.md)

[電子申告形式の実行をトレースしてパフォーマンスの問題をトラブルシューティング](trace-execution-er-troubleshoot-perf.md)

[ビジネス ドキュメント管理の概要](er-business-document-management.md)


[!INCLUDE[footer-include](../../../includes/footer-banner.md)]