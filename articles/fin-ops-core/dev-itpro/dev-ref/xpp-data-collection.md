---
title: X++ コレクション クラス
description: このトピックでは、X++のコレクション クラスについて説明します。
author: RobinARH
manager: AnnBe
ms.date: 06/17/2019
ms.topic: article
ms.prod: ''
ms.service: dynamics-ax-platform
ms.technology: ''
audience: Developer
ms.reviewer: rhaertle
ms.search.scope: Operations
ms.custom: 150183
ms.assetid: 0ff4e759-851d-4b53-aa67-6f03eee53f02
ms.search.region: Global
ms.author: rhaertle
ms.search.validFrom: 2016-02-28
ms.dyn365.ops.version: AX 7.0.0
ms.openlocfilehash: e8336d8d05abe2267c24aa6aef89edf25dd7f814
ms.sourcegitcommit: 260a820038c29f712e8f1483cca9315b6dd3df55
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/08/2019
ms.locfileid: "2778691"
---
# <a name="x-collection-classes"></a>X++ コレクション クラス

[!include [banner](../includes/banner.md)]

このトピックでは、X++のコレクション クラスについて説明します。 

X++ 言語の構文には、配列とコンテナーという 2 種類の複合が用意されています。 これらの複合型は、プリミティブ型の値を集約するのに便利です。 ただし、配列またはコンテナーのクラス オブジェクトを格納することはできません。 

*コレクション クラス*はオブジェクトの格納に使用されます。 これらは、配列、リスト、セット、マップ、任意のデータ型を保持できる構造、オブジェクトさえも作成できます。 最大パフォーマンスについては、C++ (システム クラス) で、クラスが実装されます。 *ファンデーション クラス*と呼ばれていたコレクション クラス。 コレクション クラスは、**配列**、**リスト**、**マップ**、**設定**、および**構造体**です。

- **配列** - このクラスは、X++ 言語の**配列**タイプに似ていますが、単一タイプ、オブジェクトおよびレコードの値を保持できます。 オブジェクトは、特定の順序でアクセスされます。
- **リスト** – このクラスには、順にアクセスされる要素が含まれます。 配列とは異なり、**List** クラスは **addStart** メソッドを提供します。 **Set** クラスと同様に、**List** クラスは **getEnumerator** メソッドと **getIterator** メソッドを提供します。 反復子を使用して、**リスト** オブジェクトから項目を挿入および削除することができます。
- **マップ** – このクラスはキー値を別の値に関連付けます。
- **設定** – このクラスは、1 つのタイプの値を保持します。 値は、追加された順序で格納されません。 代わりに、**Set** オブジェクトは **in** メソッドのパフォーマンスを最適化するように値を格納します。 **セット**オブジェクトは、**セット**オブジェクトが既に格納している値を追加しようとする試みをすべて無視します。 **Set** クラスは、**Array** クラスとは異なり、**in** メソッドと **remove** メソッドを提供します。
- **構造体** – このクラスは、1 つ以上のタイプの値を含めることができます。 これは、特定のエンティティに関する情報をグループ化するために使用されます。

**構造体**を除くすべてのコレクション クラスのコンストラクターは、**型**システム列挙型の要素である型パラメーターをとります。 コレクション インスタンスは、その型のアイテムのみを格納できます。 **Types::AnyType** 列挙要素は、**Set** オブジェクトなどのコレクション オブジェクトを作成するために使用できない特殊なケースです。 **null** 値は、**Set** オブジェクトに要素として格納できません。 また、**マップ** オブジェクトで **null** はキーになることはできません。 反復子または列挙子を使用して、コレクション オブジェクトを介して反復することができます。 反復子を取得する方法を示す一般的な例を次に示します。

    new MapIterator(myMap)
    myMap.getEnumerator()

**設定**オブジェクトで、任意の要素が追加または反復子が作成された後に削除される場合、反復子インスタンスは読み取りまたはコレクションによるステップで使用されることはなくなります。 

**マップ**オブジェクトで、**設定**オブジェクトと同じように、任意の要素が削除されると、反復子が有効ではなくなります。 ただし、キーが新しいか、またはキーが既に存在していてその値のみが**マップ**要素で更新されているかどうかに関係なく、**Map.insert** メソッドへの呼び出し後も、**MapIterator** オブジェクトは有効です。 **Map.insert** を呼び出し、反復子オブジェクトが有効であることに依存するコードは、.NET Framework CIL として実行されると失敗する可能性があります。 

コレクション クラスを使用するとより複雑なクラスを作成することができます。 たとえば、リストの先頭に要素が常に追加されるリストを使用して、スタックを簡単に実装できます。 最新の要素がスタックの先頭を占めます。 

コレクション クラスを拡張することもできます。 たとえば、**リスト**クラスを拡張して、操作がタイプ セーフである顧客レコードの一覧を作成します。 この場合、派生したコレクション クラスは顧客レコードのみを受け入れます。
