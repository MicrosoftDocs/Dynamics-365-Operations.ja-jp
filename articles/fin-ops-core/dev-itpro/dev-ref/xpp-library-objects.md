---
title: X++ クラス ライブラリ
description: このトピックでは、X++ でのクラス ライブラリについて説明します。
author: RobinARH
ms.date: 06/18/2019
audience: Developer
ms.reviewer: rhaertle
ms.search.region: Global
ms.author: rhaertle
ms.search.validFrom: 2016-02-28
ms.dyn365.ops.version: AX 7.0.0
ms.openlocfilehash: b657ca5dd7d77f1a3cce59ae45237ab1e3151db38f97c5c32635a37b8cf648a6
ms.sourcegitcommit: 42fe9790ddf0bdad911544deaa82123a396712fb
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/05/2021
ms.locfileid: "6734680"
---
# <a name="x-class-library"></a>X++ クラス ライブラリ

[!include [banner](../includes/banner.md)]

このトピックでは、X++ でのクラス ライブラリについて説明します。 

*アプリケーション クラス* および *システム クラス* の、2 種類のクラスがあります。

- **アプリケーション クラス** - これらのクラスは X++ で実装されています。 これらはアプリケーション エクスプローラーの **コード > クラス** ノードで使用できます。
- **システム クラス** – これらのクラスは、*カーネル クラス* と呼ばれることもあります。 これは、アプリケーション エクスプローラーの **システム ドキュメント > クラス** ノードの下に一覧表示されます。 これらのクラスのソース コードは使用できません。 システム クラスの一覧については、[API、クラス、およびテーブルの参照](api-reference.md) を参照してください。

## <a name="typical-structure-of-an-application-class"></a>アプリケーション クラスの一般的な構造

次のコード ブロック タイプは、アプリケーション クラスの標準です。

- **クラスおよび変数宣言**: このクラス宣言には、**パブリック**、**プライベート**、および **拡張** などのクラス モディファイアーが含まれます。 
- **変数宣言**: これらは、このクラスから構築されたオブジェクトのフィールド メンバーです。 **this** というキーワードをクラス インスタンス変数に入力すると、IntelliSense でこのメンバーを一覧表示できます。
- **新規** メソッド: このメソッドは、クラスのインスタンスを作成します。 コンストラクターは、**新しい** キーワードを使用することによってのみ呼び出すことができます。 派生クラスは、**super** メソッドの参照を呼ぶことにとって、コントラクターの **新しい** メソッドを呼び出すことができます。 詳細については、[X++ 継承](xpp-inheritance.md)を参照してください。
- **ファイナライズ** メソッド: このメソッドは、クラスのインスタンスをファイナライズします。 このメソッドはデストラクター メソッドです。 ただし、規則のみのデストラクタです。 ガベージ コレクション中に **finalize** メソッドが自動的に呼び出されることはありません。

クラスの追加メソッドには、次のタイプがあります。

+ インスタンス メソッド
+ 静的メソッド
+ 主要メソッド

さまざまな種類の項目でメソッドを作成することができます。 次にいくつか例を挙げます。

+ クラス
+ マップ
+ ビュー
+ データ セット
+ フォーム
+ クエリ

## <a name="substituting-application-classes-for-system-classes"></a>システム クラス用のアプリケーション クラスの置き換え

拡張するシステム クラスの代わりに *アプリケーション クラスの置き換え* を使用する必要があります。 

アプリケーション エクスプローラーの、**システム ドキュメント > クラス** では、いくつかのカーネルまたはシステム クラスの名前は小文字の *x* で始まります。 これらのクラスは、*x-system classes* とも呼ばれています。 これらのシステム クラスの例には、**xApplication** および **xVersionControl** が存在します。 これらのクラスのいくつかは、アプリケーション クラスによって拡張されます。 たとえば、**アプリケーション** クラスは **xApplication** システム クラスを拡張します。 

X システム クラスから派生するクラスは、*アプリケーション クラスの代用* として知られています。 アプリケーション エクスプローラーの **クラス** ノードで、代替アプリケーション クラスの横にあるアイコンは標準のアイコンと異なります。

### <a name="x-system-classes"></a>x システム クラス

代替アプリケーション クラスの一部は、クラスのインスタンスを表す特殊なグローバル変数に関連付けられます。 たとえば、**appl** 変数は、**アプリケーション** クラスから事前にインスタンス化されたオブジェクトを参照します。 **appl** 変数の利点は、セッションの範囲全体にわたってシステムがオブジェクトを保持することです。 **Application** クラスのインスタンスを取得するために **new Application()** 構文を繰り返し使用した場合、コードの効率が低下します。 **xApplication** システム クラスは使用しないでください。 代わりに、**アプリケーション** の代替アプリケーション クラスを使用します。 

標準構文 **Application::checkForNewBatchJobs()** を使用することにより、**アプリケーション** クラスの静的メンバーを参照することができます。 ただし、**アプリケーション** クラスのインスタンス メンバーを参照するには、そのクラスの **appl** 変数 (存在する場合) を使用する必要があります。 このパターンは、ほとんどの x システム クラスに適用されます。 **セッション** 代替アプリケーション クラスは、**セッション** の特殊なグローバル変数がないため 1 つの例外です。 

次のテーブルは、対応するアプリケーション クラスの代用を持つ x システム クラスの一覧です。 特殊なグローバル変数は、それらを持つクラスに対しても表示されます。

| アプリケーション クラス | x システム クラス  | グローバル変数    |
|-------------------|-----------------|--------------------|
| 引数              | xArgs           | 該当なし     |
| 申請       | xApplication    | **appl**           |
| ClassFactory      | xClassFactory   | **classFactory**   |
| 法人           | xCompany        | **appl.company**   |
| グローバル            | xGlobal         | 該当なし     |
| 情報              | xInfo           | **情報ログ**        |
| MenuFunction      | xMenuFunction   | 該当なし     |
| セッション           | xSession        | 該当なし     |
| VersionControl    | xVersionControl | **versionControl** |

### <a name="example-of-x-system-classes"></a>x システム クラスの例

次の例は、代替アプリケーション クラスのインスタンスを参照するいくつかの特殊な変数を使用するための構文を示しています。

```xpp
TreeNode treeNode;
Args     args;
FormRun  formRun;

// appl variable
info(appl.buildNo());

// company variable
appl.company().reloadRights();

// infolog variable
treeNode = infolog.findNode("\\forms\\custTable");
info(treeNode.AOTgetProperty("Name"));
// Output is "CustTable".

// classFactory variable
args = new Args(formstr(Batch));
formRun = classFactory.formRunClass(args);
formRun.init();
formRun.run();
formRun.detach();
info("Method is ending. This is a message in the Infolog.");
// Output is "Method is ending. This is a message in the Infolog."
```

## <a name="batch-processing-classes"></a>バッチ処理クラス
クラスを実装するには、バッチ処理システムを使用し、**RunBase** および **RunBaseBatch** クラスを拡張します。 **バッチ処理** ダイアログ ボックスから **繰り返し** ボタンを削除するには、**Args::parmEnum** メソッドを使用します。 サーバー バインド バッチ メソッドとして実行するクラスを指定することをお勧めします。 サーバー バインド バッチ メソッドは、以下の理由のため、サーバー バインドでないバッチ メソッドより安全です。

-   このメソッドは、メソッドを送信したユーザーのアクセス許可を使用して実行されます。
-   このメソッドは、特定の **情報** および **グローバル** クラス メソッドのみを使用して、それを処理しているクライアントと対話できます。 この制限により、クライアントとのやり取りが制限されます。

### <a name="enable-a-class-to-run-as-a-server-bound-batch-method"></a>サーバー バインド バッチ メソッドとして実行するクラスを有効化

1.  **RunBaseBatch** クラスを拡張するクラスを作成します。
2.  次の例に示すように、**RunBaseBatch.runsImpersonated** メソッドをオーバーライドし、値 **true** を返します。

    ```xpp
    public boolean runsImpersonated()
    {
        return true;
    }
    ```
    
3.  クラスが次の **情報** および **グローバル** クラスのメソッドのみを呼び出すことを確認します。
    -   追加
    -   Info.copy
    -   Info.cut
    -   Info.import
    -   Info.export
    -   Info.line
    -   Info.num
    -   Global::error
    -   Global::info
    -   Global::warning

    **Info.line** および **Info.num** メソッドは、**xInfo** クラスから継承されます。

### <a name="removing-the-recurrence-button-from-the-batch-processing-dialog-box"></a>バッチ処理ダイアログ ボックスから定期的なアイテムを削除

バッチ処理システムを使用してクラスを実装するときは、**Args.parmEnum** メソッドを呼び出し、**NoYes::Yes** システム列挙値を渡して、**再実行** ボタンを削除できます。 **NoYes** システム列挙は、**繰り返し** ボタンがダイアログ ボックスから削除されるかどうかを決定します。 既定値は **NoYes::No** です。 

次の例では、**InventTransferMultiShip** クラスが実装されています。 **BatchDialog::main** メソッドは、**バッチ処理** ダイアログ ボックスを作成します。

```xpp
static void noRecurrenceButton(Args _args)
{
    Args a;
    InventTransferMultiShip inventTransferMultiShip;
    a = new Args();
    inventTransferMultiShip = InventTransferMultiShip::construct();
    a.caller(inventTransferMultiShip);
    a.parmEnum(NoYes::Yes);
    BatchDialog::main(a);
}
```

## <a name="image-manipulation-classes"></a>イメージ操作クラス
**Image** と **Imagelist** の 2 つのシステム クラスにより、グラフィックスとアイコンを操作できます。

- **Image** – このクラスでは、個々の画像の読み込み、保存、操作などができます。 たとえば、画面をキャプチャして画像として保存し、画像をトリミングまたは回転させる、または色深度を操作します。
- <strong>Imagelist</strong> - このクラスを使用すると、サイズや透明色などの一般的なプロパティを持つ一連の画像を操作できます。 **ImageListAppl** アプリケーション クラスで使用されるイメージ リストを表示できます。

## <a name="query-object-model"></a>クエリ オブジェクト モデル
クエリ オブジェクト モデルには、クエリの定義と実行に使用されるクラスが含まれています。 クエリ オブジェクトは、クエリ データ ソース、返されるフィールド、レコード範囲、子データ ソースとの関係を定義するために使用されます。 動的クエリをコードで作成すると、クエリ クラスの可視性が高まります。さらに、これらは、アプリケーション エクスプローラーで静的クエリを作成するときにもシーン裏で使用されます。 

次のテーブルでは、クエリ オブジェクト モデルのクラスについて説明します。

| システム クラス         | 説明      |
|----------------------|------------------|
| QueryRun             | このクラスは、クエリを実行し、データをフェッチします。 |
| クエリ                | このクラスはいくつかのプロパティを保持し、1 つ以上の関連するデータ ソースを持ちます。 クエリの定義の最上位です。    |
| QueryBuildDataSource | このクラスは、クエリ内の単一のデータ ソースへのアクセスを定義します。 クエリに同じレベルの 1 つ以上のデータ ソースある場合、独立した SQL ステートメントが生産され、順番に実行されます。 データ ソースが別のデータ ソースの子である場合は、2 つのデータ ソース間に結合が作成されます。 |
| QueryBuildFieldList  | このクラスは、データベースから返されるフィールドを定義します。 既定では、フィールド リストは動的であり、すべてのフィールドはデータ ソース テーブル、マップ、またはビューから戻されます。 各データ ソースには、**QueryBuildFieldList** オブジェクトが 1 つだけあります。 このオブジェクトには、選択したすべてのフィールドに関する情報が含まれます。 フィールド リスト オブジェクトで、**SUM**、**COUNT**、および **AVG** などの、集計関数を指定することができます。 |
| QueryBuildRange      | このクラスは、単一フィールドに基づいて、返されるレコードのサブセットを定義します。 範囲は、クエリ SQL ステートメントの **WHERE** 句に変換されます。 クエリを制限するために 1 つ以上のフィールドが使用されている場合 (**WHERE** 句)、データ ソースには 1 つ以上の範囲が含まれます。 |
| QueryBuildDynalink   | このクラスには、外部レコードとの関係 (制限) に関する情報が含まれます。 クエリを実行すると、この情報は、クエリ SQL ステートメントの **WHERE** 句内で追加のエントリに変換されます。 このクラスは、クエリの親データ ソースにのみ存在できます。 フォームは、2 つのデータ ソースが同期されるときにこの機能を使用します。 子データ ソースは、親データ ソース に対する 1 つ以上の DLL を格納します。 この関数は、2 つのデータソースが 2 つの異なる形式になっていて、まだ同期されている場合でも使用されます。 |
| QueryBuildLink       | このクラスは、結合に 2 つのデータ ソースの間の関係を指定します。 このクラスは、子データ ソースにのみ存在できます。 |

また、[SysDa API](sysda.md)を使用してデータを照会することもできます。

## <a name="system-classes-overview"></a>システム クラスの概要
システム クラスのこのソースは使用できません。 システム クラスは、次の特性を持つことができます。

+ 静的メソッド (またはクラス メソッド)
+ 動的メソッド
+ プロパティ - これらのプロパティは、プロパティを設定するために使用されるメンバー関数です。 たとえば **LeftMargin** です。

システム クラスのメソッドをオーバーライドすることはできません。 最初からアプリケーション オブジェクトをデザインするためにシステム クラスを使用することを意図していません。 代わりに、アプリケーション エクスプローラーで既存の機能を拡張または変更するために使用します。 たとえば、既存のレポートに追加情報を動的に追加することができます。 または、前のページでのユーザーの選択に基づいて、ページ上で使用可能なオプションを変更することができます。

### <a name="collection-classes"></a>コレクション クラス

*コレクション クラス* を使用すると、リスト、セット、構造体、マップ、および配列を作成できます。

### <a name="application-object-classes"></a>アプリケーション オブジェクト クラス

これらのシステム クラスは、アプリケーション エクスプローラーを使用してアプリケーションを作成するたびにアクティブ化される関数を保持します。 たとえば、システムは、アプリケーション エクスプローラーの **設計** ノードでフォームのレイアウトを定義する時、**FormDesign** クラスを使用します。 これらのクラスを使用すると、アプリケーション オブジェクトを作成したり変更したりすることもできます。

### <a name="integration-classes"></a>統合クラス

環境との統合は、通常、クラスによって実装されます。 このカテゴリ内のクラスの例を次に示します。

-   **COM** - COM オブジェクトのメソッドの呼び出しです。
-   **DLL** – Microsoft Windows DLL 関数の呼び出し。
-   **IO** – 外部ファイルの読み取りと書き込みを行います。
-   **ODBCConnection** – 外部データベースへの Open Database Connectivity (ODBC) インターフェイス。



[!INCLUDE[footer-include](../../../includes/footer-banner.md)]