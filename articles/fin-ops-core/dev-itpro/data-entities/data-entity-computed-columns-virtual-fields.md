---
title: データ エンティティの列と仮想フィールドを計算する
description: この記事では、計算されたフィールドと仮想フィールドに関する情報を提供します。これは、データ エンティティが持つことができる 2 つのタイプのマッピングされていないフィールドです。
author: Sunil-Garg
ms.date: 06/20/2017
ms.topic: article
ms.prod: ''
ms.technology: ''
audience: Developer
ms.reviewer: sericks
ms.custom: 17891
ms.assetid: 88d230af-7d3d-49b3-bf19-69ecf81ed751
ms.search.region: Global
ms.author: sunilg
ms.search.validFrom: 2016-02-28
ms.dyn365.ops.version: AX 7.0.0
ms.openlocfilehash: 380069b50f57be1639e40ad8556c8bfc161549d4
ms.sourcegitcommit: 074b6e212d19dd5d84881d1cdd096611a18c207f
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/31/2021
ms.locfileid: "5751014"
---
# <a name="computed-columns-and-virtual-fields-in-data-entities"></a><span data-ttu-id="05013-103">データ エンティティの列と仮想フィールドを計算する</span><span class="sxs-lookup"><span data-stu-id="05013-103">Computed columns and virtual fields in data entities</span></span>

[!include [banner](../includes/banner.md)]

<span data-ttu-id="05013-104">この記事では、計算されたフィールドと仮想フィールドに関する情報を提供します。これは、データ エンティティが持つことができる 2 つのタイプのマッピングされていないフィールドです。</span><span class="sxs-lookup"><span data-stu-id="05013-104">This article provides information about computed and virtual fields, which are the two types of unmapped fields that a data entity can have.</span></span> <span data-ttu-id="05013-105">この記事には、マップされていないフィールドのプロパティに関する情報と、それらの作成、使用、テストの方法を示す例が含まれています。</span><span class="sxs-lookup"><span data-stu-id="05013-105">The article includes information about the properties of unmapped fields, and examples that show how to create, use, and test them.</span></span>

<span data-ttu-id="05013-106">サンプルコードは、ユーザーが所有しているソリューションの一部であるエンティティの作成または変更を行う用途で使用します。</span><span class="sxs-lookup"><span data-stu-id="05013-106">The sample code is targeted towards creating or modifying an entity that is a part of solution that you own.</span></span>  <span data-ttu-id="05013-107">既存のエンティティを拡張するには、若干の変更を加える必要があります。</span><span class="sxs-lookup"><span data-stu-id="05013-107">Extending an existing entity requires slight modifications.</span></span>

## <a name="overview"></a><span data-ttu-id="05013-108">概要</span><span class="sxs-lookup"><span data-stu-id="05013-108">Overview</span></span>

<span data-ttu-id="05013-109">データ エンティティは、データ ソースのフィールドに直接マップされているフィールド以外に *マップされていない* フィールドを追加で持つことができます。</span><span class="sxs-lookup"><span data-stu-id="05013-109">A data entity can have additional *unmapped* fields beyond those that are directly mapped to fields of the data sources.</span></span> <span data-ttu-id="05013-110">マップされていないフィールドの値を生成するメカニズムは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="05013-110">There are mechanisms for generating values for unmapped fields:</span></span>

- <span data-ttu-id="05013-111">カスタム X++ コード</span><span class="sxs-lookup"><span data-stu-id="05013-111">Custom X++ code</span></span>
- <span data-ttu-id="05013-112">Microsoft SQL Server で実行される SQL</span><span class="sxs-lookup"><span data-stu-id="05013-112">SQL executed by Microsoft SQL Server</span></span>

<span data-ttu-id="05013-113">マップされていない2種類のフィールドは、計算と仮想です。</span><span class="sxs-lookup"><span data-stu-id="05013-113">The two types of unmapped fields are computed and virtual.</span></span> <span data-ttu-id="05013-114">マップされていないフィールドは常に読み取り操作をサポートしますが、機能仕様では、書き込み操作をサポートするための開発作業は必要とされない場合があります。</span><span class="sxs-lookup"><span data-stu-id="05013-114">Unmapped fields always support read actions, but the feature specification might not require any development effort to support write actions.</span></span>

### <a name="computed-field"></a><span data-ttu-id="05013-115">計算フィールド</span><span class="sxs-lookup"><span data-stu-id="05013-115">Computed field</span></span>

- <span data-ttu-id="05013-116">値は、SQL ビューの計算列によって生成されます。</span><span class="sxs-lookup"><span data-stu-id="05013-116">Value is generated by an SQL view computed column.</span></span>
- <span data-ttu-id="05013-117">読み取り中に、データは SQL によって計算され、ビューから直接フェッチされます。</span><span class="sxs-lookup"><span data-stu-id="05013-117">During read, data is computed by SQL and is fetched directly from the view.</span></span>
- <span data-ttu-id="05013-118">書き込みについては、カスタム X++ コードは入力値を解析し、データ エンティティの通常のフィールドに解析された値を書き込む必要があります。</span><span class="sxs-lookup"><span data-stu-id="05013-118">For writes, custom X++ code must parse the input value and then write the parsed values to the regular fields of the data entity.</span></span> <span data-ttu-id="05013-119">値はエンティティのデータ ソースの通常のフィールドに格納されます。</span><span class="sxs-lookup"><span data-stu-id="05013-119">The values are stored in the regular fields of the data sources of the entity.</span></span>
- <span data-ttu-id="05013-120">計算フィールドは主に読み取りに使用されます。</span><span class="sxs-lookup"><span data-stu-id="05013-120">Computed fields are used mostly for reads.</span></span>
- <span data-ttu-id="05013-121">可能であれば、計算された列は SQL Server レベルで計算されている一方、仮想フィールドは、X++ の行ごとに計算された行であるため、可能な限り仮想フィールドではなく計算された列を使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="05013-121">If possible, it's a good idea to use computed columns instead of virtual fields, because they are computed at the SQL Server level, whereas, virtual fields are computed row by row in X++.</span></span>

### <a name="virtual-field"></a><span data-ttu-id="05013-122">仮想フィールド</span><span class="sxs-lookup"><span data-stu-id="05013-122">Virtual field</span></span>

- <span data-ttu-id="05013-123">保持されないフィールドです。</span><span class="sxs-lookup"><span data-stu-id="05013-123">Is a non-persisted field.</span></span>
- <span data-ttu-id="05013-124">カスタム X++ コードによって制御されます。</span><span class="sxs-lookup"><span data-stu-id="05013-124">Is controlled by custom X++ code.</span></span>
- <span data-ttu-id="05013-125">読み取り/書き込みは、カスタム X++ コードを通じて発生します。</span><span class="sxs-lookup"><span data-stu-id="05013-125">Read and write happens through custom X++ code.</span></span>
- <span data-ttu-id="05013-126">仮想フィールドは 通常X++ コードを使用して計算される入力値に使用され、計算された列に置き換わることはできません。</span><span class="sxs-lookup"><span data-stu-id="05013-126">Virtual fields are typically used for intake values that are calculated by using X++ code and can't be replaced by computed columns.</span></span>

### <a name="properties-of-unmapped-fields"></a><span data-ttu-id="05013-127">マップされていないフィールドのプロパティ</span><span class="sxs-lookup"><span data-stu-id="05013-127">Properties of unmapped fields</span></span>

<table>
<thead>
<tr>
<th><span data-ttu-id="05013-128">カテゴリ</span><span class="sxs-lookup"><span data-stu-id="05013-128">Category</span></span></th>
<th><span data-ttu-id="05013-129">氏名</span><span class="sxs-lookup"><span data-stu-id="05013-129">Name</span></span></th>
<th><span data-ttu-id="05013-130">種類</span><span class="sxs-lookup"><span data-stu-id="05013-130">Type</span></span></th>
<th><span data-ttu-id="05013-131">既定値</span><span class="sxs-lookup"><span data-stu-id="05013-131">Default value</span></span></th>
<th><span data-ttu-id="05013-132">動作</span><span class="sxs-lookup"><span data-stu-id="05013-132">Behavior</span></span></th>
</tr>
</thead>
<tbody>
<tr>
<td><span data-ttu-id="05013-133">データ</span><span class="sxs-lookup"><span data-stu-id="05013-133">Data</span></span></td>
<td><span data-ttu-id="05013-134">IsComputedField</span><span class="sxs-lookup"><span data-stu-id="05013-134">IsComputedField</span></span></td>
<td><span data-ttu-id="05013-135">NoYes</span><span class="sxs-lookup"><span data-stu-id="05013-135">NoYes</span></span></td>
<td><span data-ttu-id="05013-136">有</span><span class="sxs-lookup"><span data-stu-id="05013-136">Yes</span></span></td>
<td><ul>
<li><span data-ttu-id="05013-137"><strong>はい:</strong> - フィールドは、SQL ビューの計算済み列として同期されます。</span><span class="sxs-lookup"><span data-stu-id="05013-137"><strong>Yes</strong> – The field is synchronized as a SQL view computed column.</span></span> <span data-ttu-id="05013-138">列の SQL 定義文字列を計算するために X++ メソッドが必要です。</span><span class="sxs-lookup"><span data-stu-id="05013-138">Requires an X++ method to compute the SQL definition string for the column.</span></span> <span data-ttu-id="05013-139">仮想列の定義は静的であり、エンティティが同期されているときに使用されます。</span><span class="sxs-lookup"><span data-stu-id="05013-139">The virtual column definition is static and is used when the entity is synchronized.</span></span> <span data-ttu-id="05013-140">その後は、 X++ メソッドは、実行時に呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="05013-140">After that, the X++ method is not called at run time.</span></span></li>
<li><span data-ttu-id="05013-141"><strong>いいえ</strong> - フィールドは、入庫および出荷の値がカスタム コードによって完全に制御される真の仮想フィールドです。</span><span class="sxs-lookup"><span data-stu-id="05013-141"><strong>No</strong> – The field is a true virtual field, where inbound and outbound values are fully controlled through custom code.</span></span></li>
</ul></td>
</tr>
<tr>
<td><span data-ttu-id="05013-142">データ</span><span class="sxs-lookup"><span data-stu-id="05013-142">Data</span></span></td>
<td><span data-ttu-id="05013-143">ComputedFieldMethod</span><span class="sxs-lookup"><span data-stu-id="05013-143">ComputedFieldMethod</span></span></td>
<td><span data-ttu-id="05013-144">文字列</span><span class="sxs-lookup"><span data-stu-id="05013-144">String</span></span></td>
<td></td>
<td><span data-ttu-id="05013-145">フィールド定義を生成する SQL 式を構築するための X++ の静的 <strong>DataEntity</strong> メソッド。</span><span class="sxs-lookup"><span data-stu-id="05013-145">A static <strong>DataEntity</strong> method in X++ to build the SQL expression that will generate the field definition.</span></span> <span data-ttu-id="05013-146">プロパティ <strong>IsComputedField</strong> が <strong>いいえ</strong> に設定されている場合、このプロパティは無効で無関係です。</span><span class="sxs-lookup"><span data-stu-id="05013-146">This property is disabled and irrelevant if the property <strong>IsComputedField</strong> is set to <strong>No</strong>.</span></span> <span data-ttu-id="05013-147">このメソッドは、プロパティ <strong>IsComputedField</strong> が <strong>はい</strong> に設定されている場合に必要です。</span><span class="sxs-lookup"><span data-stu-id="05013-147">The method is required if the property <strong>IsComputedField</strong> is set to <strong>Yes</strong>.</span></span></td>
</tr>
<tr>
<td><span data-ttu-id="05013-148">データ</span><span class="sxs-lookup"><span data-stu-id="05013-148">Data</span></span></td>
<td><span data-ttu-id="05013-149">ExtendedDataType</span><span class="sxs-lookup"><span data-stu-id="05013-149">ExtendedDataType</span></span></td>
<td><span data-ttu-id="05013-150">文字列</span><span class="sxs-lookup"><span data-stu-id="05013-150">String</span></span></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

## <a name="example-create-a-computed-field"></a><span data-ttu-id="05013-151">例: 計算フィールドを作成</span><span class="sxs-lookup"><span data-stu-id="05013-151">Example: Create a computed field</span></span>
<span data-ttu-id="05013-152">この例では、**FMCustomerEntity** エンティティに計算フィールドを追加します。</span><span class="sxs-lookup"><span data-stu-id="05013-152">In this example, you add a computed field to the **FMCustomerEntity** entity.</span></span> <span data-ttu-id="05013-153">読み取りについては、このフィールドは、顧客の名前と住所を適切な形式に結合します。</span><span class="sxs-lookup"><span data-stu-id="05013-153">For reads, the field combines the name and address of the customer into a nice format.</span></span> <span data-ttu-id="05013-154">書き込みについては、X++ コードは複合値を個別の名前および住所の値に解析し、それからコードが通常の名前や住所フィールドを更新します。</span><span class="sxs-lookup"><span data-stu-id="05013-154">For writes, your X++ code parses the combined value into its separate name and address values, and then the code updates the regular name and address fields.</span></span>

1. <span data-ttu-id="05013-155">Microsoft Visual Studio で、プロジェクトを右クリックし、既存の **FMCustomerEntity** を追加します。</span><span class="sxs-lookup"><span data-stu-id="05013-155">In Microsoft Visual Studio, right-click your project, and add the existing **FMCustomerEntity**.</span></span>
2. <span data-ttu-id="05013-156">ソリューション エクスプローラーで、**FMCustomerEntity** ノードを右クリックしてから **開く** をクリックします。</span><span class="sxs-lookup"><span data-stu-id="05013-156">In Solution Explorer, right-click the **FMCustomerEntity** node, and then click **Open**.</span></span>
3. <span data-ttu-id="05013-157">**FMCustomerEntity** のデザイナービューで、 **Fields** ノードを右クリックし、 **New** &gt; **String Unmapped Field** とクリックします。</span><span class="sxs-lookup"><span data-stu-id="05013-157">In the designer for **FMCustomerEntity**, right-click the **Fields** node, and then click **New** &gt; **String Unmapped Field**.</span></span>

    <span data-ttu-id="05013-158">[![新しくマップされていない文字列フィールドを作成](./media/computedcolumnsandvirtualfields11.png)](./media/computedcolumnsandvirtualfields11.png)</span><span class="sxs-lookup"><span data-stu-id="05013-158">[![Creating a new string unmapped field](./media/computedcolumnsandvirtualfields11.png)](./media/computedcolumnsandvirtualfields11.png)</span></span>

4. <span data-ttu-id="05013-159">新しいフィールドの名前を **NameAndAddress** に変更します。</span><span class="sxs-lookup"><span data-stu-id="05013-159">Rename the new field **NameAndAddress**.</span></span>
5. <span data-ttu-id="05013-160">次のスクリーンショットに示すように、マッピングされていない **NameAndAddress** フィールドのプロパティを更新します。</span><span class="sxs-lookup"><span data-stu-id="05013-160">Update properties of the **NameAndAddress** unmapped field, as shown in the following screenshot.</span></span>

    <span data-ttu-id="05013-161">[![NameAndAddress のマップされていないフィールドのプロパティの更新](./media/computedcolumnsandvirtualfields21.png)](./media/computedcolumnsandvirtualfields21.png)</span><span class="sxs-lookup"><span data-stu-id="05013-161">[![Updating the properties of the NameAndAddress unmapped field](./media/computedcolumnsandvirtualfields21.png)](./media/computedcolumnsandvirtualfields21.png)</span></span>

6. <span data-ttu-id="05013-162">**FMCustomerEntity** &gt; **メソッド** に移動します。</span><span class="sxs-lookup"><span data-stu-id="05013-162">Go to **FMCustomerEntity** &gt; **Methods**.</span></span> <span data-ttu-id="05013-163">**メソッド** ノードを右クリックし、**新規** をクリックします。</span><span class="sxs-lookup"><span data-stu-id="05013-163">Right-click the **Methods** node, and then click **New**.</span></span> <span data-ttu-id="05013-164">メソッド名が、マップされていない計算されたフィールドの **DataEntityView方法** のプロパティ値と一致していることを、確認します。</span><span class="sxs-lookup"><span data-stu-id="05013-164">Ensure that the method name matches the **DataEntityView Method** property value of the unmapped computed field.</span></span>
7. <span data-ttu-id="05013-165">次の X++ コードをメソッドに貼り付けます。</span><span class="sxs-lookup"><span data-stu-id="05013-165">Paste the following X++ code into the method.</span></span> <span data-ttu-id="05013-166">このメソッドは、結合されて書式設定された **NameAndAddress** 値を返します。</span><span class="sxs-lookup"><span data-stu-id="05013-166">The method returns the combined and formatted **NameAndAddress** value.</span></span>

    > [!NOTE]
    > <span data-ttu-id="05013-167">**サーバー** キーワードが必要です。</span><span class="sxs-lookup"><span data-stu-id="05013-167">The **server** keyword is required.</span></span>

    ```xpp
    private static server str formatNameAndAddress()   // X++
    {
        DataEntityName      dataEntityName= tablestr(FMCustomerEntity);
        List                fieldList = new List(types::String);
        ////Format name and address to look like following
        ////John Smith, 123 Main St, Redmond, WA 98052
        fieldList.addEnd(SysComputedColumn::returnField(DataEntityName, identifierstr(FMCustomer), fieldstr(FMCustomer, FirstName)));
        fieldList.addEnd(SysComputedColumn::returnLiteral(" "));
        fieldList.addEnd(SysComputedColumn::returnField(DataEntityName, identifierstr(FMCustomer), fieldstr(FMCustomer, LastName)));
        fieldList.addEnd(SysComputedColumn::returnLiteral("; "));
        fieldList.addEnd(SysComputedColumn::returnField(DataEntityName, identifierstr(FMAddressTable), fieldstr(FMAddressTable, AddressLine1)));
        fieldList.addEnd(SysComputedColumn::returnLiteral(", "));
        fieldList.addEnd(SysComputedColumn::returnField(DataEntityName, identifierstr(FMAddressTable), fieldstr(FMAddressTable, City)));
        fieldList.addEnd(SysComputedColumn::returnLiteral(", "));
        fieldList.addEnd(SysComputedColumn::returnField(DataEntityName, identifierstr(FMAddressTable), fieldstr(FMAddressTable, State)));
        fieldList.addEnd(SysComputedColumn::returnLiteral(", "));
        fieldList.addEnd(SysComputedColumn::cast(
            SysComputedColumn::returnField(DataEntityName, identifierstr(FMAddressTable), fieldstr(FMAddressTable, ZipCode)), "NVARCHAR"));
        return SysComputedColumn::addList(fieldList);
    }

    T-SQL for the computed column.

    ( Cast (( ( T1.firstname ) + ( N' ' ) + ( T1.lastname ) + ( N'; ' ) +
        ( T5.addressline1 )
        + ( N', ' ) + ( T5.city ) + ( N', ' ) + ( T5.state ) + (
        N', '
        ) +
        ( Cast(T5.zipcode AS NVARCHAR) ) ) AS NVARCHAR(100))
    )
    AS
    NAMEANDADDRESS
    ```

    > [!TIP]
    > <span data-ttu-id="05013-168">計算列のためにデータ エンティティの同期にエラーが発生した場合、X++ で使用する前に、Microsoft SQL Server Management Studio (SSMS) で SQL 定義を用意することは簡単です。</span><span class="sxs-lookup"><span data-stu-id="05013-168">If you receive error in data entity synchronization because of computed columns, it's easier to come up with the SQL definition in Microsoft SQL Server Management Studio (SSMS) before using it in X++.</span></span>

8. <span data-ttu-id="05013-169">プロジェクトをリビルドします。</span><span class="sxs-lookup"><span data-stu-id="05013-169">Rebuild the project.</span></span>
9. <span data-ttu-id="05013-170">データベースを同期させます。</span><span class="sxs-lookup"><span data-stu-id="05013-170">Synchronize the database.</span></span> <span data-ttu-id="05013-171">この手順を忘れないでください。</span><span class="sxs-lookup"><span data-stu-id="05013-171">Don't forget this step.</span></span> <span data-ttu-id="05013-172">**Dynamics 365 &gt; データベースの同期 &gt; 同期** に移動することによりこれを実行することができます。</span><span class="sxs-lookup"><span data-stu-id="05013-172">You can do this by going to **Dynamics 365 &gt; Synchronize database &gt; Synchronize**.</span></span>

## <a name="example-create-a-virtual-field"></a><span data-ttu-id="05013-173">例: 仮想フィールドを作成</span><span class="sxs-lookup"><span data-stu-id="05013-173">Example: Create a virtual field</span></span>
<span data-ttu-id="05013-174">この例では、**FMCustomerEntity** エンティティに仮想フィールドを追加します。</span><span class="sxs-lookup"><span data-stu-id="05013-174">In this example, you add a virtual field to the **FMCustomerEntity** entity.</span></span> <span data-ttu-id="05013-175">このフィールドには、姓と名の組み合わせとしてフルネームが表示されます。</span><span class="sxs-lookup"><span data-stu-id="05013-175">This field displays the full name as a combination of the last name and first name.</span></span> <span data-ttu-id="05013-176">X++ コードは複合値を生成します。</span><span class="sxs-lookup"><span data-stu-id="05013-176">X++ code generates the combined value.</span></span>

1. <span data-ttu-id="05013-177">**FMCustomerEntity** エンティティのデザイナーで、**フィールド** ノードを右クリックしてから、**新規 &gt; マップされていない文字列フィールド** をクリックします。</span><span class="sxs-lookup"><span data-stu-id="05013-177">In the designer for the **FMCustomerEntity** entity, right-click the **Fields** node, and then click **New &gt; String Unmapped Field**.</span></span>
2. <span data-ttu-id="05013-178">マップされていないフィールドのプロパティ ウィンドウで、**名前** プロパティを **FullName** に設定します。</span><span class="sxs-lookup"><span data-stu-id="05013-178">In the properties pane for the unmapped field, set the **Name** property to **FullName**.</span></span>
3. <span data-ttu-id="05013-179">**計算フィールドかどうか** プロパティ **いいえ** に設定します。</span><span class="sxs-lookup"><span data-stu-id="05013-179">Set the **Is Computed Field** property to **No**.</span></span> <span data-ttu-id="05013-180">**DataEntityView メソッド** が空のままであることを確認します。</span><span class="sxs-lookup"><span data-stu-id="05013-180">Notice that you leave the **DataEntityView Method** empty.</span></span>

    <span data-ttu-id="05013-181">[![マップされていないフィールドのプロパティの設定](./media/computedcolumnsandvirtualfields31.png)](./media/computedcolumnsandvirtualfields31.png)</span><span class="sxs-lookup"><span data-stu-id="05013-181">[![Setting the properties for the unmapped field](./media/computedcolumnsandvirtualfields31.png)](./media/computedcolumnsandvirtualfields31.png)</span></span>

4. <span data-ttu-id="05013-182">**FMCustomerEntity** デザイナーで、**メソッド** ノードを右クリックしてから、**オーバーライド &gt; postLoad** とクリックします。</span><span class="sxs-lookup"><span data-stu-id="05013-182">In the **FMCustomerEntity** designer, right-click the **Methods** node, and then click **Override &gt; postLoad**.</span></span> <span data-ttu-id="05013-183">このメソッドの X++ コードは、仮想フィールドの値を生成します。</span><span class="sxs-lookup"><span data-stu-id="05013-183">Your X++ code in this method will generate the values for the virtual field.</span></span>
5. <span data-ttu-id="05013-184">次の X++ コードを **postLoad** オーバーライドに貼り付けます。</span><span class="sxs-lookup"><span data-stu-id="05013-184">Paste the following X++ code in for the **postLoad** override.</span></span> <span data-ttu-id="05013-185">**postLoad** メソッドが **void** を返すことに注意します。</span><span class="sxs-lookup"><span data-stu-id="05013-185">Notice that the **postLoad** method returns **void**.</span></span>

    ```xpp
    public void postLoad()
    {
        super();
        //Populate virtual field once entity has been loaded from database
        //Format full name - "Doe, John"
        this.FullName = this.LastName + ", " + this.FirstName;
    }
    ```

6. <span data-ttu-id="05013-186">プロジェクトをコンパイルします。</span><span class="sxs-lookup"><span data-stu-id="05013-186">Compile your project.</span></span>

## <a name="example-use-a-virtual-field-to-receive-and-parse-an-inbound-field"></a><span data-ttu-id="05013-187">例: 受信フィールドを受信および解析する仮想フィールドを使用</span><span class="sxs-lookup"><span data-stu-id="05013-187">Example: Use a virtual field to receive and parse an inbound field</span></span>
<span data-ttu-id="05013-188">外部システムが、システムに送信する 1 つのフィールドに姓と名を組み合わせた複合値として人物の名前を送信する場合を考えてみましょう。</span><span class="sxs-lookup"><span data-stu-id="05013-188">Imagine that an external system sends the name of a person as a compound value that combines the last and first names in one field that comes into our system.</span></span> <span data-ttu-id="05013-189">ただし、システムは姓と名を個別に格納します。</span><span class="sxs-lookup"><span data-stu-id="05013-189">However, our system stores the last and first names separately.</span></span> <span data-ttu-id="05013-190">このシナリオでは、作成した **FullName** 仮想フィールド使用することができます。</span><span class="sxs-lookup"><span data-stu-id="05013-190">For this scenario, you can use the **FullName** virtual field that you created.</span></span> <span data-ttu-id="05013-191">この例で、主要な追加は **mapEntityToDataSource** メソッドのオーバーライドです。</span><span class="sxs-lookup"><span data-stu-id="05013-191">In this example, the major addition is an override of the **mapEntityToDataSource** method.</span></span> <span data-ttu-id="05013-192">**更新** が呼び出されると、各データ ソースごとに **mapEntityToDataSource** メソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="05013-192">When **update** is called, **mapEntityToDataSource** methods are invoked for each data source.</span></span>

1. <span data-ttu-id="05013-193">**FMCustomerEntity** のデザイナーで、**メソッド** ノードを右クリックしてから、**オーバーライド &gt; mapEntityToDataSource** とクリックします。</span><span class="sxs-lookup"><span data-stu-id="05013-193">In the designer for the **FMCustomerEntity**, right-click the **Methods** node, and then click **Override &gt; mapEntityToDataSource**.</span></span>
2. <span data-ttu-id="05013-194">次の X++ コードを **mapEntityToDataSource** メソッドに貼り付けます。</span><span class="sxs-lookup"><span data-stu-id="05013-194">Paste the following X++ code in for the **mapEntityToDataSource** method.</span></span>

    ```xpp
    public void mapEntityToDataSource(DataEntityRuntimeContext entityCtx, DataEntityDataSourceRuntimeContext dataSourceCtx)
    {
        super(entityCtx, dataSourceCtx);
        //Check if desired data source context is available
        if (dataSourceCtx.name() == "FMCustomer")
        {
            FMCustomer dsCustomer = dataSourceCtx.getBuffer();
            //Find position of "," to parse full name format "Doe, John"
            int commaPosition = strfind(this.FullName, ",",0,strlen(this.FullName));
            //Update FirstName and LastName in the data source buffer to update
            dsCustomer.LastName = substr(this.FullName,0,commaPosition-1);
            dsCustomer.FirstName = substr(this.FullName, commaPosition+1, strlen(this.FullName));
        }
    }
    ```

## <a name="test-the-computed-and-virtual-fields"></a><span data-ttu-id="05013-195">計算フィールドと仮想フィールドのテスト</span><span class="sxs-lookup"><span data-stu-id="05013-195">Test the computed and virtual fields</span></span>
<span data-ttu-id="05013-196">次の **main** メソッドは、計算フィールドと仮想フィールドをテストします。</span><span class="sxs-lookup"><span data-stu-id="05013-196">The following **main** method tests your computed and virtual fields.</span></span> <span data-ttu-id="05013-197">両方のフィールドは読み取りアクションでテストされ、仮想フィールドは更新アクションでテストされます。</span><span class="sxs-lookup"><span data-stu-id="05013-197">Both fields are tested in a read action, and the virtual field is tested in an update action.</span></span>

1. <span data-ttu-id="05013-198">この例では、**フリート管理 (移行済)** というデータ セットがあることを確認します。</span><span class="sxs-lookup"><span data-stu-id="05013-198">For this example, ensure that you have the data set named **Fleet Management (migrated)**.</span></span> <span data-ttu-id="05013-199">データ セットはブラウザーのダッシュボードから利用できます。</span><span class="sxs-lookup"><span data-stu-id="05013-199">The data set is available from the dashboard in the browser.</span></span> <span data-ttu-id="05013-200">右上隅にあるメニュー アイコンをクリックし、**アプリのリンク** メニューをクリックしてスクロールし、**フリート管理 (移行)** という名前のデータセットを見つけます</span><span class="sxs-lookup"><span data-stu-id="05013-200">Click the menu icon in the upper-right corner, click the **APP LINKS** menu, and then scroll to find the data set named **Fleet Management (migrated)**.</span></span>
2. <span data-ttu-id="05013-201">次の X++ コードをプロジェクトのスタートアップ オブジェクトに貼り付けます。</span><span class="sxs-lookup"><span data-stu-id="05013-201">Paste the following X++ code into the startup object of your project.</span></span> <span data-ttu-id="05013-202">プロジェクトを実行します。</span><span class="sxs-lookup"><span data-stu-id="05013-202">Run your project.</span></span>

    ```xpp
    public static void main(Args _args)   // X++
    {
        FMCustomerEntity customer;
        //Using transactions to avoid committing updates to database
        ttsbegin;
        //SELECT single customer entity record from the database
        select customer
            where customer.Email == "phil.spencer@adatum.com";
        //Read full name (Virtual Field)
        info(customer.FullName);
        //Read formatted NameAndAddress(computed Field)
        info(customer.NameAndAddress);
        //UPDATE full name (virtual field)
        customer.FullName = "Doe, John";
        customer.update();
        //Reselect data from database to get updated information
        select customer
            where customer.Email == "phil.spencer@adatum.com";
        //Read full name (virtual field)
        info(customer.FullName);
        ttsabort;
    }
    ```
    
### <a name="note-on-computed-column-generation-failures"></a><span data-ttu-id="05013-203">計算列の生成に失敗した場合の注意事項</span><span class="sxs-lookup"><span data-stu-id="05013-203">Note on computed column generation failures</span></span>
<span data-ttu-id="05013-204">計算列の SQL を生成する X++ メソッドが例外をスローした場合、DbSync は例外をキャッチし、**その列の値を `NULL` に設定** して、*警告* を記録します。</span><span class="sxs-lookup"><span data-stu-id="05013-204">If the X++ method that generates the SQL for a computed column throws an exception, DbSync catches the exception, **sets the value of that column to `NULL`**, and logs a *warning*.</span></span>

<span data-ttu-id="05013-205">開発者は、計算列のメソッドでコンフィギュレーション キーを手動でチェックして、生成に失敗した場合に `NULL` 値がヒットされないようにすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="05013-205">Developers are advised to check configuration keys manually in computed column methods to avoid hitting a `NULL` value, if the generation failed.</span></span>


[!INCLUDE[footer-include](../../../includes/footer-banner.md)]