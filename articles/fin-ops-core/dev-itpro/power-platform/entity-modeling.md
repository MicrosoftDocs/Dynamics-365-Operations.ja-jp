---
title: エンティティ モデリング
description: この記事では、財務と運用エンティティの仮想エンティティを使用したリレーショナル モデリングの概念について説明します。
author: Sunil-Garg
ms.date: 09/16/2022
ms.topic: article
ms.prod: ''
ms.technology: ''
audience: Developer, IT Pro
ms.reviewer: johnmichalak
ms.search.region: Global
ms.author: sunilg
ms.search.validFrom: 2020-05-31
ms.dyn365.ops.version: 10.0.12
ms.openlocfilehash: 9fa1151daeaa5d23f58b71d3a0011373062aa8fd
ms.sourcegitcommit: 346a9ca833237836d5e4ca496aeb2b5b24bdb27b
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/23/2022
ms.locfileid: "9583801"
---
# <a name="entity-modeling"></a>エンティティ モデリング

[!include[banner](../includes/banner.md)]



> [!IMPORTANT]
> この機能を使用するには、財務と運用アプリのバージョン 10.0.12 が必要ですが、Microsoft Dataverse にはサービス更新プログラム 189 が必要です。 Dataverse のリリース情報は、[最新バージョンの利用可能性](/business-applications-release-notes/dynamics/released-versions/dynamics-365ce#all-version-availability)ページに発行されています。
>
> 財務と運用仮想エンティティの Dataverse メタデータで公開されるパブリック エンティティ名は、財務と運用エンティティの物理名を使用します。 これは、OData メタデータによって公開されるエンティティのパブリック名とは異なる場合があります。

アプリを作成するには、アプリで使用されているエンティティの間でリレーショナル モデリングを実行する機能が必要です。 仮想エンティティのコンテキストでは、Dataverse の仮想エンティティとネイティブ エンティティが連携して、目的のユーザー エクスペリエンスを実現する必要があります。 この記事では、財務と運用の仮想エンティティを使用して実装できるリレーショナル モデリングの概念について説明します。

## <a name="generating-virtual-entities"></a>仮想エンティティの生成

既定では、財務と運用アプリの仮想エンティティは Dataverse に存在しません。 ユーザーは、財務と運用アプリのリンクされたインスタンスで使用可能なエンティティを表示するために、カタログ エンティティをクエリする必要があります。 カタログから、ユーザーは 1 つ以上のエンティティを選択し、Dataverse が仮想エンティティを生成するように要求できます。 この手順については、後のセクションで説明します。

## <a name="entity-fields"></a>エンティティ フィールド

財務と運用エンティティに対して仮想エンティティが生成されると、システムは Dataverse に対応する仮想エンティティに財務と運用エンティティの各フィールドの作成を試みます。 理想的なケースでは、財務と運用アプリと Dataverse の間でサポートされているデータ型に不一致がない限り、両方のエンティティでフィールドの総数が同じになります。 サポートされているデータ型は、財務と運用アプリのプロパティを基に Dataverse のフィールド プロパティが設定されています。

このセクションの残りの部分では、サポートされるデータ型とサポートされないデータ型について説明します。 Dataverse にあるフィールドの詳細については、[フィールドの概要](/powerapps/maker/common-data-service/fields-overview)を参照してください。

| 財務と運用のデータ型 | Dataverse のモデル化されたデータ型 |
|-------------------------------------|------------------------------------------|
| 実績                                | 小数<br><br>考えられる不一致の詳細については、次の表を参照してください。</p> |
| 長い                                | 精度が 0 (ゼロ) に等しい 10 進数 |
| Int                                 | 整数 |
| 文字列 (memo 以外), 文字列 (memo)    | 文字列 – 1 行のテキスト、文字列 – 複数行テキスト |
| UtcDateTime                         | DateTime (DateTimeFormat.DateAndTime, DateTimeBehavior.TimeZoneIndependent)<br><br>財務と運用の空の日付 (1900 年 1 月 1 日) は、Dataverse では null 値として表されます。 |
| 日付                                | DateTime - (DateTimeFormat.DateOnly, DateTimeBehavior.TimeZoneIndependent)<br><br>財務と運用の空の日付 (1900 年 1 月 1 日) は、Dataverse では空の値として表されます。 |
| 列挙                                | 候補リスト<br><br>財務と運用の列挙 (列挙型) は、Dataverse ではグローバル OptionSet として生成されます。 システム間のマッチングは、値の **外部名** プロパティを使用して行われます。 Dataverse における列挙型整数値は、システム間で固定されているとは限りません。 したがって、これらの列挙型にも固定 ID が含まれていないので、依存することは避けてください (特に拡張可能な列挙型の場合)。 OptionSet を使用するエンティティが更新されると、OptionSet メタデータが更新されます。 |

財務と運用アプリの *real* および *long* データ型のフィールドは、Dataverse の *decimal* データ型としてモデル化されます。 2 つのデータ型の間では、精度と小数点部桁数の不一致があるため、次の動作を考慮する必要があります。

| ユース ケース                                     | 結果の動作 |
|----------------------------------------------|--------------------|
| Dataverse のほうが精度が高くなります。    | メタデータが同期していない場合、このユース ケースは発生しません。 |
| 財務と運用アプリのほうが精度は高くなります。 | 読み取り操作時は、Dataverse では、値が最も近い精度値に丸められます。 値が Dataverse で編集された場合、値が最も近い精度値に丸められます。 財務と運用アプリはより高い精度をサポートしているため、書き込み操作中に、Dataverse で指定された値が書き込まれます。 |
| Dataverse のほうがスケールが大きくなります。        | 該当なし |
| 財務と運用アプリのほうがスケールは大きくなります。     | Dataverse は、1,000 億を超えている場合でも、財務と運用の値を示しています。 ただし、精度は低下します。 たとえば、987,654,100,000,000,000 は Dataverse では "987,654,099,999,999,900" として表示されます。 このフィールドの値が Dataverse で編集されている場合、Dataverse 検証では、財務と運用アプリに送信される前に、値が最大値を超えていますというエラーがスローされます。 |

財務と運用アプリの次のデータ型は、Dataverse ではサポートされていません。 財務と運用エンティティのこれらのデータ型のフィールドは、Dataverse の対応する仮想エンティティでは使用できません。 これらのデータ型のフィールドを Open Data Protocol (OData) アクションのパラメーターとして使用した場合は、それらのアクションを対応する仮想エンティティで使用することはできません。 OData アクションの詳細については、この記事で後述する [OData アクション](#odata-actions) セクションを参照してください。

- AnyType
- BLOB
- クラス
- コンテナー
- Guid
- レコード
- 時刻
- UserType
- VarArg
- Void (OData アクションの Void 戻り値の型はサポートされています)。

Dataverse ではサポートされているものの、財務と運用アプリではサポートされていないデータ型は、財務と運用アプリの仮想エンティティではサポートされていません。

## <a name="entity-keyprimary-key"></a>エンティティ キー/主キー

財務と運用では、エンティティはエンティティ キーとしてさまざまなデータ型の 1 つ以上のフィールドを持つことができます。 エンティティ キーは、財務と運用エンティティ内のレコードを一意に識別します。 さらに、エンティティのレコードは、Int64 型のレコード ID 主キーによって一意に識別できます。

Dataverse では、主キーは常にグローバル一意識別子 (GUID) になります。 GUID ベースの主キーを使用すると、Dataverse 内のエンティティ内のレコードを一意に識別できます。

財務と運用アプリと Dataverse の間の実装ギャップを埋めるため、財務と運用アプリの仮想エンティティの主キーは GUID になります (Dataverse に準拠するため)。 この GUID は、最初の 4 バイトのデータ エンティティ ID と、最後の 8 バイトとしてエンティティ内のルート データ ソースのレコード ID で構成されます。 この設計では、GUID をエンティティ キーとして使用するという Dataverse の要件が満たされています。 また、テーブル ID とレコード ID を使用して、財務と運用のエンティティ レコードを一意に識別することもできます。

財務と運用アプリでエンティティを使用する場合、ルート データ ソースには常に一意の RecID があることを確認します。 このデザインに違反すると、Dataverse には対応する仮想エンティティに対して重複するGUID が表示されます。 集計ビューには一意の RecID がない可能性があるという同じ理由で、集計ビューは仮想エンティティ経由ではサポートされません。

## <a name="primary-field"></a>基本フィールド

Dataverse では、各エンティティに基本フィールドが必要です。 このフィールドには、文字列型の単一のフィールドを指定する必要があります。 基本フィールドは、次の場合に Dataverse で使用されます。

- エンティティに対して作成される既定のビューには、基本フィールドがあります。
- エンティティのクイック ビュー フォームには、基本フィールドが含まれています。
- 別のエンティティへのルックアップがページに追加され、基本フィールドのデータが表示されます。

Dataverse の基本フィールドのこの使用に基づき、財務と運用の仮想エンティティの基本フィールドは、財務と運用アプリの対応するエンティティのエンティティ キーを使用するように設計されています。

Dataverse の基本フィールドには文字列型のフィールドが 1 つだけあることが想定されていますが、財務と運用のエンティティ キーにはさまざまなデータ型の複数のフィールドがあるため、エンティティ キー フィールドは文字列に変換されます。 文字列は、連結され、パイプ (\|) によって区切られており、最大 255 文字です。 255 文字を超える値はすべて切り捨てられます。 基本フィールドを表すこの仮想エンティティ フィールドの名前は、**mserp\_primaryfield** になります。

> [!NOTE]
> 関連付けられた Dataverse 環境に財務と運用アプリの仮想エンティティが生成された後、主キーとプライマリ フィールドを変更することはできません。 プライマリ フィールドを変更するには、Dataverse 環境からエンティティを削除する必要があります。 仮想エンティティを無効にし、Dataverse 環境からエンティティ メタデータを削除する方法の詳細については、[仮想エンティティの無効化](enable-virtual-entities.md#disable-virtual-entities) を参照してください。 財務および運用アプリでプライマリ フィールドが変更された後、エンティティを再び有効化できます。 詳細については、[仮想エンティティの生成](enable-virtual-entities.md#generate-virtual-entities) を参照してください。

## <a name="relations"></a>リレーション

> [!IMPORTANT]
> 仮想エンティティとネイティブ エンティティを横断する書き込みトランザクションには対応していません。 整合性の確保を保証する方法がないため、この形式のトランザクションは使用しないことを推奨します。

財務と運用エンティティのリレーションは、一対多 (1:n) または多対一 (n:1) のリレーションとしてモデル化されます。 これらのリレーションは、Dataverse の仮想エンティティのリレーションシップとしてモデル化されています。 多対多 (n:n) リレーションは、財務と運用ではサポートされていないことに注意してく運用ださい。

たとえば、財務と運用アプリでは、エンティティ A がエンティティ B への外部キーを持っている場合、このリレーションは、Dataverse の仮想エンティティ エンティティ A で n:1 のリレーションシップとしてモデル化されます。 Dataverse でのこのリレーションシップのスキーマ名は、名前付け規則 **mserp\_FK\_\<source entity name\>\_\<relation name\>** を使用します。 この名前付け規則では、最大文字列長が 92 文字になっています。 スキーマ名が 92 文字を超える名前を生成するリレーションは、Dataverse の仮想エンティティで生成されません。

このリレーションシップの外部名は、名前付け規則 **FK\_\<relation name\>** を使用します。 外部名は、送信され構築されるクエリのときに、財務と運用アプリのリレーションを決定するために使用されます。

Dataverse の仮想エンティティに対してリレーションシップが生成されると、そのルックアップタイプの新しいフィールドがソース エンティティにも追加されます。 前の例では、リレーションシップが作成されると、名前付け規則 **mserp\_fk\_\<target\_entity\>\_id** を使用する新しいルックアップ フィールドがソース エンティティのエンティティ A に追加されます。財務と運用のエンティティに複数のリレーションが存在する可能性があるため、ソース仮想エンティティには、同じ数のルックアップ フィールド (関連エンティティごとに 1 つ) が作成されます。 このルックアップ フィールドがページまたはビューに追加されると、関連するエンティティの基本フィールドの値が表示されます。

Dataverse の仮想エンティティ内のリレーションシップは、Dataverse の仮想エンティティとしてに既にリレーション内の関連エンティティが存在する場合にのみ生成され ます。 前の例では、エンティティ B が Dataverse の仮想エンティティとしてに存在しない場合、エンティティ A が仮想エンティティとして生成されたときに、エンティティ B へのリレーションがエンティティ A に作成されません。 このリレーションは、エンティティ B が仮想エンティティとして生成された場合にのみエンティティ A に追加されます。 したがって、財務と運用アプリの仮想エンティティが生成されると、検証が行われ、生成されている仮想エンティティで完全で機能的なリレーションシップのみが生成されることが確認されます。

簡単に言うと、次のいずれかの理由により、別の財務と運用仮想エンティティとのリレーションシップが仮想エンティティに存在しない場合があります。

- リレーションシップに参加している財務と運用エンティティが、仮想エンティティとして存在しません。
- リレーションシップの名前の長さは、92 文字を超えています。

Dataverse で財務と運用の仮想エンティティの一部を生成する際にエラーが発生した場合、仮想エンティティはまったく作成されないことに注意してください。 上記のいずれかの理由でリレーションシップが存在しない場合は、エラーとは見なされません。

### <a name="native-entitytonative-entity-relationships"></a>ネイティブ エンティティ - ネイティブ エンティティ リレーションシップ

ネイティブ エンティティ - ネイティブ エンティティ リレーションシップは、関連するエンティティの GUID を使用してリレーションシップを解決する Dataverse の標準機能です。 (この GUID はエンティティ キーです)。GUID によって、関連するエンティティの固有のエンティティ レコードが識別されます。

### <a name="virtual-tabletovirtual-table-relationships"></a>仮想テーブル - 仮想テーブル リレーションシップ

2 つの財務と運用の仮想エンティティ間のリレーションシップは、財務と運用エンティティの関連メタデータによって駆動されます。 前に説明したように、これらのリレーションは、仮想エンティティが生成されたときに Dataverse でリレーションシップとして生成されます。 Dataverse のネイティブ エンティティの動作と同様に、これらのリレーションシップは GUID を使用して財務と運用のエンティティ キーの固有レコードを識別します。 意味的には、財務と運用仮想エンティティの GUID は、ネイティブ Dataverse テーブル上で GUID と同じように動作します。 財務と運用の仮想エンティティでの GUID の実装については、この記事で前述した[エンティティ キー/主キー](entity-modeling.md#entity-keyprimary-key) セクションを参照してください。

前の例では、関連するエンティティの GUID はエンティティ B のエンティティ キーであり、財務と運用アプリでレコードを識別するクエリを作成するために使用されます。 エンティティ A とエンティティ B のリレーションが使用されます。

したがって、実質的に、エンティティ名は、財務と運用アプリから取得されるリレーションで使用される唯一の情報です。 エンティティ名によって、関連エンティティの基本フィールドにアクセスできるようになり、ルックアップにそのエンティティを表示できるようになります。 また、関連するエンティティの GUID にアクセスできるため、前に説明したように、他のクエリで使用することができます。 財務と運用エンティティで構築される実際のフィールドは、まったく使用されません。

### <a name="virtual-tabletonative-table-relationship"></a>仮想テーブル - ネイティブ テーブル リレーションシップ

前に説明したように、GUID は、ネイティブ Dataverse テーブル (ネイティブ エンティティ - ネイティブ エンティティ リレーションシップを含む) または財務と運用の仮想エンティティ (仮想エンティティ - 仮想エンティティ リレーションシップを含む) 内のレコードを一意に識別するために使用される唯一の情報です。 しかし、Dataverse のアカウント A の財務と運用の販売注文を表示する例を考えてみましょう。 このリレーションシップのために財務と運用アプリに送信されるクエリには、Dataverse の特定のアカウントに対して販売注文がフィルター処理される必要があるため、Dataverse のネイティブ アカウント エンティティのエンティティ キーの GUID に WHERE 句があります。 ただし、財務と運用アプには Dataverse のエンティティの GUID に関する情報が含まれていないため、クエリが販売注文を返すことはありません。 クエリは、WHERE 句に財務と運用が理解するフィールドに基づく条件がある場合にのみ成功します。

そのため、財務と運用アプリに送信されるクエリが正しい販売注文のリストを返すように、Dataverse のアカウント エンティティの GUID を、財務と運用フィールドに置き換えるにはどうすればよいですか?

この問題を解決して、仮想エンティティ - ネイティブ エンティティのリレーションシップが許可される豊富なシナリオ セットを実現するには、このタイプのエンティティにリレーションシップを追加します。 このリレーションは、仮想エンティティが同期されるときにリレーションシップとして表示されます。

上の例では、SalesOrderHeader 仮想エンティティとアカウント ネイティブエンティティの間のリレーションシップは、アカウント番号と会社フィールドに基づいている必要があります。 既定では、Dataverse のネイティブ アカウント エンティティには会社フィールドがありません。 この例では、new_testcompany という会社ルックアップ フィールドを、ネイティブ アカウント エンティティに追加します。

次に、new_accountcompanyidx という名前の新しいキーを追加します。このキーは、accountnumber (new_testcompany) と Dataverse におけるそのアカウント エンティティの固有の行を表します。

次の手順では、X++ でこのリレーションシップを定義します。 次の例は、サンプル X++ コードを示しています。 フィールド、インデックス、およびマッピングの情報の名前は、Dataverse で作成されたフィールドとインデックスの名前と一致している必要があります。 この例では、"synthaccount" という名前のリレーションシップが、仮想 SalesorderHeader エンティティと Dataverse 内のネイティブ アカウント エンティティの間に作成されます。 マップされたフィールドは、new_accountcompanyidx インデックスを構成します。 リレーションシップの表示名は @SYS11307 になります。 表示名の先頭に円記号があることを確認します。 これにより、ラベルがリレーションシップを定義して適切に変換されるようになります。

フィールド マッピングは、仮想エンティティのフィールドが、ネイティブ エンティティのフィールドにマップされていることを示します。 フィールド マッピングでは、キーが仮想エンティティ フィールドである、値がネイティブ エンティティ フィールドです。

```x++
[CDSVirtualEntitySyntheticRelationshipAttribute('synthaccount', 'account', 'accountcompanyidx', '\@SYS11307')]
    public static Map syntheticAccountRelationship()
    {
        Map fieldMapping = new Map(Types::String, Types::String);

        // Assumes the Dataverse account entity has a key on [msdyn_accountnumber, msdyn_companyid]
        // Also assumes that the Dataverse cdm_Company entity has a key on [msdyn_companycode]
        fieldMapping.insert(fieldStr(CDSVirtualEntityTestEntity, StringField), 'msdyn_accountnumber');
        fieldMapping.insert(fieldStr(CDSVirtualEntityTestEntity, DataAreaId), 'msdyn_companyid');

        return fieldMapping;
    }
```
次の手順では、仮想エンティティを生成または更新して、新しいリレーションシップを取得します。 仮想エンティティとネイティブ エンティティ間のリレーションシップは、作成された後 Dataverse では更新できないことに注意してください。 更新を行う唯一の方法は、リレーションシップを物理的に削除し、エンティティを更新した後、問題を解決するためにそのエンティティを再度追加して再関連付けする方法です。

このリレーションシップは一般的な GUID ベースのリレーションシップに似ていますが、リレーションシップのクエリ フィルターをバッキング フィールドの制限に変換するための追加のメタデータがあります。 これで生成されたクエリには、財務と運用アプリが認識するフィールドに基づく WHERE 句が含められるようになります。 その後、クエリによって、フィルター処理された販売注文の一覧が正常に返されます。

### <a name="native-entitytovirtual-entity-relationships"></a>ネイティブ エンティティ - 仮想エンティティ リレーションシップ

ネイティブ エンティティ - 仮想エンティティ リレーションシップは、ネイティブ エンティティ - ネイティブ エンティティ リレーションシップと同じように機能します。 ユーザーは財務と運用の仮想レコードにネイティブ レコードを関連付け、仮想エンティティの GUID がネイティブ エンティティ レコードに保存されます。 既に説明したように、リレーションシップに参加するエンティティには、関連するエンティティの GUID フィールドが含まれます。 したがって、Dataverse の見積が財務と運用の仮想エンティティ内の顧客に関連付けられている場合は、顧客の仮想エンティティの GUID が見積エンティティに保存されます。 この動作により、標準の Dataverse 機能を使用してレコードを予想どおりに取得できます。

## <a name="enums"></a>列挙

財務と運用の列挙型は、Dataverse の OptionSet としてモデル化されます。 財務と運用の仮想エンティティが生成されると、必要な列挙型は OptionSet として生成されます。 OptionSet が既に存在する場合は、代わりに使用されます。

## <a name="company"></a>法人

財務と運用のエンティティは、会社にバインドすることも、グローバルにすることもできます。 会社にバインドされている財務と運用エンティティの仮想エンティティは、Dataverse の cdm\_company エンティティとのリレーションシップを持ちます。 cdm\_company エンティティは、Dataverse におけるネイティブ エンティティで あり、Dynamics365Company ソリューションの一部です。 通常と同様、リレーションシップが作成されると、関連するエンティティ (この場合は cdm\_company) の仮想エンティティにも検索フィールドが作成されます。 このルックアップ フィールドは **会社** という名前であり、ユーザーがリストの値を選択したり、関連するレコードの詳細に移動したりできるように、最適なユーザー エクスペリエンスを提供するために使用する必要があります。 **会社コード** と呼ばれるフィールドは、仮想エンティティにも追加されます。 この値は 4 文字の文字列です。 このフィールドは、プログラミングで使用する必要があります。

## <a name="attachments"></a>アタッチメント

財務と運用エンティティの添付ファイルは、エンティティごとにサポートされます。 たとえば、請求書ヘッダー エンティティは、[エンティティを通じて添付ファイルを有効](../../fin-ops/organization-administration/configure-document-management.md#how-can-attachments-be-extracted-from-the-system)にするために、請求書に関連する添付ファイル エンティティを実装します。

このタイプのエンティティは、財務と運用アプリの対応する添付ファイル エンティティと関係があります。 したがって、これらは前に説明した他の関係と同じパターンに従います。 つまり、添付ファイル機能が実装されている財務と運用エンティティは、仮想エンティティを使用して添付ファイルを使用できるようにします。 添付ファイルをサポートしていない財務と運用エンティティは、Dataverse で仮想化された添付ファイルもサポートしていません。

財務と運用の仮想エンティティでサポートされるのは、添付ファイルの読み取りだけであることに注意してください。 現在、仮想エンティティを使用した添付ファイルの作成、更新、または削除はサポートされていません。

## <a name="odata-actions"></a>OData アクション

財務と運用エンティティの OData アクションは、Dataverse のカスタム アクションとして使用できるようになります。 カスタム アクションと Dataverse での使用方法の詳細については、[カスタム アクション](/powerapps/developer/common-data-service/custom-actions)を参照してください。

次のタイプの入力パラメーターと出力パラメーターがサポートされています。 入力または出力パラメーターのタイプが異なる場合、OData アクションは Dataverse の SDK メッセージとして表示されません。

- 整数
- 文字列
- Guid
- ブール値
- Date/Datetime

以下は、財務と運用エンティティでサポートされているものの、Dataverse の対応する仮想エンティティではサポートされていない OData アクションの例です。

- RetailStoreTenderTypeTable.queryDistinctTenderTypeIdAndName (RetailStoreTenderTypeTable エンティティのコレクション)
- DocumentRoutingClientApp.syncPrinters (DocumentRoutingClientApp エンティティ)
- DocumentRoutingClientApp.updateJobStatus (DocumentRoutingJobStatus 列挙)
- DimensionCombination.getCombinationDisplayValue (LedgerJournalACType 列挙)

## <a name="labels-and-localization"></a>ラベルとローカライズ

財務と運用アプリのエンティティ名やフィールド名など、メタデータに定義されているラベルは、Dataverse で仮想エンティティが生成されるときに取得されます。 ラベルは、Dataverse にインストールされている言語ロケールの一覧を渡すことによって取得されます。 財務と運用アプリは、Dataverse でラベル インスタンスを構築するために使用される、ロケール/値セットの一覧として各ラベルを返します。 エンティティの生成または更新時に存在する言語パックのみが含まれます。 また、財務と運用アプリが翻訳を提供したラベルのみが含まれます。 欠落している翻訳がある場合、ラベル ID に戻されます (**\@SYS:DataEntity** など)。 新しい言語パックが Dataverse にインストールされた後、その言語のラベルが財務と運用アプリに存在する場合は、新しいラベル情報を取得するために既存のエンティティを更新する必要があります。

ランタイム ラベルは、現在のユーザー コンテキストの言語で返されます。 つまり、財務と運用アプリでそのユーザーの UserInfo レコードに指定されている言語で返されます。 この動作は、エラー メッセージにも適用されます。

## <a name="error-handling"></a>エラー処理

財務と運用アプリは、エンティティのビジネス ロジックの作成、読み取り、更新、削除 (CRUD) を実行し、Dataverse の仮想エンティティを介して呼び出されたときにバッキング テーブルを実行します。 なんらかの例外が財務と運用アプリ側でスローされた場合は、エラー ログの最後のメッセージが Dataverse に返され、財務と運用アプリからのメッセージを含む InvalidPluginExecutionException 例外としてスローされます。 アプリ コードはユーザーのコンテキストで実行されるため、エラー メッセージの言語は、アプリの UserInfo レコードで指定されている言語に基づきます。 財務と運用の情報ログに書き込まれたメッセージが例外にならない場合、Dataverse には表示されません。

## <a name="calculatedunmapped-fields"></a>計算済み/マップ解除済みフィールド

財務と運用エンティティの計算されたフィールドとマップされていないフィールドは、Dataverse の対応する仮想エンティティでも使用できます。


[!INCLUDE[footer-include](../../../includes/footer-banner.md)]
