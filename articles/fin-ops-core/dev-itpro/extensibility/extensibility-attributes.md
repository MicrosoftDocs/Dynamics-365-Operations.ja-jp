---
title: メソッドを拡張可能にする属性
description: このトピックでは、メソッドを拡張可能にする属性について説明します。
author: MichaelFruergaardPontoppidan
ms.date: 03/11/2019
ms.topic: article
ms.prod: ''
ms.technology: ''
audience: Developer
ms.reviewer: rhaertle
ms.custom: 268724
ms.assetid: ''
ms.search.region: Global
ms.author: mfp
ms.search.validFrom: 2018-09-09
ms.dyn365.ops.version: Platform update 20
ms.openlocfilehash: 705c6e16dde82771dadffcf9c057a1713fda5d14
ms.sourcegitcommit: 74e47075eab2b0b28f82b0d57f439719847ecb01
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/07/2021
ms.locfileid: "6193632"
---
# <a name="attributes-that-make-methods-extensible"></a>メソッドを拡張可能にする属性

[!include [banner](../includes/banner.md)]

このトピックでは、メソッドの拡張性機能を制御するために使用できるさまざまな属性について説明します。

次の表は、メソッドの拡張性およびアクセシビリティの既定のサポートの概要を提供します。 さらに、メソッド シグネチャの変更に関するガイダンスも提供します。

| 属性  | フック可能 | 折り返し可能 | 置き換え可能 | アクセシビリティ | 署名 | 
|---|----------|-----------|-------------|---------------|-----------|
| **プライベート** | 無 | 該当なし | 該当なし | 定義されているクラス内からアクセスできます。 | シグネチャは変更可能 |
| **保護された内部** | いいえ | はい。プラットフォーム更新 25 以降から | いいえ | 定義されているクラスから、および同じモデル内の派生クラスからアクセス可能です。 | シグネチャでは互換性が維持されている必要があります |
| **内部** | 無 | 無 | 無 | 同じモデルでアクセスできます。 | シグネチャは変更可能 |
| **保護** | いいえ | はい。最終とマークされている場合以外 | いいえ | 定義されているクラスから、および派生クラスからアクセス可能です。 | シグネチャでは互換性が維持されている必要があります |
| **パブリック** | はい | はい。最終とマークされている場合以外 | いいえ | 定義されたクラス、派生クラス、および定義するクラスにアクセスできるその他のクラスからアクセス可能です。 | シグネチャでは互換性が維持されている必要があります |

## <a name="hookable"></a>フック可能
メソッドがフック可能な場合、拡張担当者はプリイベントとポストイベントにサブスクライブできます。

パブリック メソッドの場合、メソッドに **\[Hookable(false)\]** を追加することでオプトアウトできます。

**\[Hookable(true)\]** をメソッドに追加して、プライベートおよび保護されたメソッドをオプトインできます。

メソッドが明示的に **\[Hookable(false)\]** とマークされている場合、折り返しはできません。

### <a name="best-practices-when-you-write-code"></a>コードの作成時のベスト プラクティス
メソッドがフック可能な場合、コンパイラは拡張ポイントでメソッドを有効にするために特別な中間言語 (IL) コードを生成します。 余分なコードにはパフォーマンスのオーバーヘッドがありますが、このオーバーヘッドはほとんどの場合は無視できます。 ただし、パフォーマンスが重要なメソッドでは、フック不能としてメソッドをマーキングすることを検討してください。

## <a name="wrappable"></a>折り返し可能
メソッドが折り返し可能な場合は、拡張担当者はコマンド チェーン (CoC) を使用して折り返すことができます。 拡張担当者は、CoC を中断することが許可されていないため、次を呼び出す必要があります。

保護されたパブリック メソッドの場合、メソッドに **\[Wrappable(false)\]** を追加することでオプトアウトできます。

プライベート メソッドをオプトインすることはできません。

### <a name="best-practices-when-you-write-code"></a>コードの作成時のベスト プラクティス
CoC は、さまざまな点で継承に似ています。 通常、他のユーザーが変更するのではなくメソッドを呼び出すことができるようにするには、最終としてメソッドをマークします。 これらのメソッドを折り返し不可またはフック不可としてマーキングすることを検討してください。

## <a name="replaceable"></a>置き換え可能 
メソッドが置き換え可能な場合は、拡張担当者は CoC を使用して折り返しできますが、無条件に次を呼び出す必要はありません。 拡張担当者は CoC を中断できますが、条件がある場合のみ中断することが期待されます。 コンパイラは、次の呼び出しを強制しません。

置き換え可能にするには、メソッドも折り返し可能である必要があります。

折り返し可能なメソッドの場合、メソッドに **\[Replaceable\]** を追加することでオプトインできます。

### <a name="best-practices-when-you-write-code"></a>コードの作成時のベスト プラクティス
メソッドの置き換え可能な場合、CoC を使用して拡張することができ、次の実行をスキップできます。 メソッドを置き換え可能にできるようにする前に、拡張担当者がメソッドの実行をスキップした場合の機能への影響を十分に評価する必要があります。
            
+ **\[Replaceable\]** を持つメソッドに、メソッドの責任を説明する XML ドキュメントがあることを確認 **します**。
+ 顧客が置き換えられたロジックをスキップして何もしないようにすうるには、**\[Replaceable\]** を使用 **しません**。
+ **SysExtension** を代わりに使用可能な場合は、ファクトリ メソッドに **\[Replaceable\]** を使用 **しません**。
+ メソッドがデータベースまたはクラスの状態を変更する場合、**\[Replaceable\]** の使用を **回避します**。
+ メソッドが複数の工程を実行し、複数の責任を持つ場合、**\[Replaceable\]** の使用を **回避します**。 代わりに、それぞれが単一の責任を持つ別個のメソッドにメソッドをリファクタリングし、どのメソッドを実際に置き換え可能にする必要があるかを検討します。
+ 変換を解決するために、**\[Replaceable\]** の使用を **検討します**。 

    **例:** 既定のブロックがスローを持つ列挙値より切り替えステートメントを使う列挙変換。

+ ルックアップと jumpref をオーバーライドするために **\[Replaceable\]** を使用することを **検討します**。
 
### <a name="best-practices-for-extenders"></a>拡張担当者のベスト プラクティス
+ 置き換えるロジックとは異なる責任を持つロジックを記述し **ません**。
+ 置き換えロジックが適用されない場合、基本機能を呼び出し **ます** (次を呼び出し)。
+ 基本機能 (次を呼び出し) を呼び出さずにロジックを完全に置き換えることを **回避します**。


[!INCLUDE[footer-include](../../../includes/footer-banner.md)]