---
title: ワークスペースのタイルおよびリストのキャッシュ
description: このトピックでは、タイルとリストに使用されるデータをキャッシュするためのフレームワーク サポートについて説明します。これにより、ワークスペースが正常に動作し、応答可能になります。
author: jasongre
ms.date: 06/20/2017
ms.topic: article
ms.prod: ''
ms.technology: ''
audience: Developer
ms.reviewer: rhaertle
ms.custom: 16341
ms.assetid: c84d7929-4662-4abb-b345-ccc539d809d0
ms.search.region: Global
ms.author: jasongre
ms.search.validFrom: 2016-02-28
ms.dyn365.ops.version: AX 7.0.0
ms.openlocfilehash: 749257e5717c7324e6475a2ea506297e080e370e
ms.sourcegitcommit: 074b6e212d19dd5d84881d1cdd096611a18c207f
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/31/2021
ms.locfileid: "5744149"
---
# <a name="tile-and-list-caching-for-workspaces"></a>ワークスペースのタイルおよびリストのキャッシュ

[!include [banner](../includes/banner.md)]

ワークスペースが正常に機能し、応答可能である (つまり、ワークスペースに表示されるデータが期待どおりに更新され、最新の状態である) ことが重要です。 このトピックでは、タイルとリストに使用されるデータをキャッシュするためのフレームワークのサポートについて説明します。

<a name="introduction"></a>はじめに
------------

ワークスペースは大半のユーザーにとって活動のハブとなるように意図されています。 さまざまな情報源から収集された豊富な情報を表示します。 したがって、ワークスペースが正常に動作し、応答性があることを確認する必要があります (つまり、ワークスペースに表示されたデータが予想どおりに更新され、最新の状態に維持される)。 キャッシュは、パフォーマンスの低いクエリからのデータが得られた場合にワークスペースの優れたパフォーマンスを保証できるようにします。また、複数のユーザーが同じデータ セットに同時にアクセスする必要がある場合に特に便利です。 たとえば、フォーム上のグリッドが複合 (つまり、低いパフォーマンス) クエリを使用する場合、フォームの以後の積荷に使用できるように結果をキャッシュすることができます。 この記事では、タイルとリストに使用されるデータをキャッシュするためのフレームワークのサポートについて説明します。 応答しやすいワークスペースの観点から、ユーザーがワークスペースに移動した (またはそこに戻った) ときに、ワークスペース内のデータが比較的に最新の状態であることを期待します。 たとえば、ユーザーがワークスペースでリストまたはタイルのデータを変更するアクションを実行する場合、ワークスペースはアクションが実行された直後 (アクションがワークスペースから直接実行された場合)、またはユーザーがワークスペース フォームに返す際に (アクションが異なるフォームで実行された場合)、その変更を反映する必要があります。 この記事では、タイルとリストの両方について、このタイプのデータ更新が (メタデータとコードの両方で) 行われるようにするための手法について説明します。

## <a name="count-tiles"></a>カウント タイル
### <a name="automatic-data-caching"></a>自動データ キャッシング

フレームワークは、定義されたカウント タイルの背後に自動的にデータ キャッシングを設定します。 したがって、この場合には余分なコードは必要ありません。 タイル内の **更新頻度** のメタデータ プロパティは、タイルのカウントが自動的に更新される頻度を決定します。 次のテーブルでは、このプロパティのオプションとガイダンスについて説明しています。

| 先頭値                              | 使用時                                                                                                                |
|------------------------------------|----------------------------------------------------------------------------------------------------------------------------|
| できる限り速く (5 秒) | クエリの実行時間は 25 ミリ秒以下であり、常に更新された値を表示する必要があります。                          |
| 10 分                         | クエリの実行時間は 250 ミリ秒未満であり、更新されたデータを定期的に表示する必要があります                                       |
| 24 時間                           | クエリの実行時間は 2000 ミリ秒未満であり、カウントの変更は予期されていないか、最新のカウントが重要です。 |

### <a name="refresh-management"></a>更新管理

保留中の作業を表す値を示すカウント タイルは、かなり反応的でなければなりません。 理想的には、ワークスペース タイルに表示されるカウントが常に最新の 5 秒以内になるように、可能な限り早いリフレッシュ頻度をこれらのタイルに対して定義する必要があります。 このクイック更新頻度はパフォーマンス クエリ (実行時間が 25 ミリ秒未満のクエリ) でのみ設定する必要があるため、最初の推奨事項はカウント タイルのクエリのパフォーマンスを操作して、25 ミリ秒のしきい値未満でクエリの実行を取得するために試行することです。 一般に、この実行速度を実現するためには、次の 2 つが必要です。

-   クエリで選択的な WHERE 条件であるクエリの条件は、できれば結果セットを 500 レコード未満に、理想的には 100 行未満に減らす必要があります。
-   選択的な WHERE 条件に対応できるインデックス構造

これらの実行速度を達成するためにクエリのパフォーマンスを改善する方法については、「よくある間違いとクエリを最適化するためのヒント」セクションを参照してください。 クエリのバッキングがあり、25 ミリ秒実行速度のしきい値を満たすことができないタイルについては、タイルでの更新頻度を低い値のいずれかに設定する必要があります (たとえば、10 分または 24 時間)。 より効率の低いクエリ (まれである) を持つタイルの値を頻繁に更新する必要がある場合は、次のコードを追加して、キャッシュされたセットに影響するアクションが発生したときにキャッシュを手動で更新できます。

```xpp
TileDataService::forceRefresh(tilestr(<tileName>), formRun)
```

頻繁に変更されないデータ セットの例としては、コンフィギュレーションがない製品です。 このカウントを示すタイルは、10 分の更新頻度があります。 ただし、以前にコンフィギュレーションされていなかった製品に対するコンフィギュレーションが定義される場合、データ キャッシュを強制更新するよう商品フォームが計測されると、タイル カウントは依然として応答しているように見える場合があります。

## <a name="workspace-lists"></a>ワークスペース リスト
フレームワークは自動的にカウント タイルのためのデータ キャッシュを設定しますが、データ キャッシュを使用する必要のあるリストでは手動の設定が必須です。 一覧のキャッシュされたデータを導入するための高レベルの手順を次に示します。

1.  キャッシュされたデータ セットに必要なすべての列を参照するクエリを作成します。
2.  キャッシュするすべてのフィールドを含むテーブルを作成します。
3.  キャッシュ クエリとキャッシュ テーブルの間のマッピングを定義するクラスを作成します。
4.  フォームのデータ ソースとしてキャッシュされたテーブルを追加/参照します。

これらの手順はそれぞれ、次のセクションで詳細が説明され、フリート ワークスペース (予約管理) の例と対になります。

### <a name="cache-query"></a>キャッシュ クエリ

最初に、キャッシュ テーブルを設定するために使用するクエリを作成する必要があります。 このクエリには、次の特性が必要です。

-   これはキャッシュ データを取得するテーブルに対して設定する必要があります。
-   実際に興味のある結果に結果を制限する必要があります。
-   キャッシュするフィールドのみを選択する必要があります。 **注記:** 無関係のフィールドを避けるには、各データソースで **DynamicFields**=**いいえ** とする必要があります。

### <a name="cache-table"></a>キャッシュ テーブル

次に、キャッシュ クエリのフィールドと一致するフィールドのセットが含まれるテーブルを定義する必要があります。 これらのフィールドに加えて、**SysDataCacheContextId** (Int64) という名前のフィールドも追加する必要があります。 このフィールドは、キャッシュ行を基本キャッシュ テーブルにマッピングするために使用されます。 SysDataSetCacheTableMap テーブルの **Id** と **SysDataCacheContextId** フィールド間、およびキャッシュ テーブルの **RecId** と **SysDataCacheContextId** フィールド間のそれぞれのマッピングを、テーブル上で定義します。 また、キャッシュされるフィールドを使用するデータ メソッドに加え、このテーブルと他のテーブル間の関係を定義することができます。

### <a name="cache-class"></a>キャッシュ クラス

3 番目のステップは、キャッシュ クエリとキャッシュ テーブルの間のリレーションシップを定義するクラスを作成することです。 このクラスでは、いくつかの属性を定義する必要があり、適切なフレームワーク データ キャッシング クラスを拡張して実装する必要があります。 次のコードは、予約管理ワークスペースの対応するクラスを示しています。

```xpp
[SysDataSetExtension(classStr(FMPickupAndReturn)), // The name of this class
SysDataSetCacheTableExtension(tableStr(FMPickupAndReturnCache))] // The name of the cache table
class FMPickupAndReturn extends SysDataSetQuery implements SysIDataSet
{
    public SysDataCacheRefreshFrequency parmRefreshFrequency()
    {
        return 600; // Cache refresh frequency, in seconds.
    }
    public SysQueryableIdentifier parmQueryableIdentifier()
    {
        return queryStr(FMPickupAndReturnQuery); // The name of the query.
    }
    public SysDataCacheTypeId parmCacheTypeId()
    {
        return tableNum(FMPickupAndReturnCache); // The name of the table.
    }
    public static FMPickupAndReturn construct()
    {
        return new FMPickupAndReturn();
    }
}
```

状況によっては、**parmQueryableToCacheMapping()** メソッドを実装しなければならない場合もあります。 このメソッドは、キャッシュ テーブル内の少なくとも 1 つの列名が、バッキング テーブル内の対応する列の名前と一致しない場合に必要です (たとえば、名前は同じですが異なるテーブルの 2 つのフィールドを追加する必要がある場合など)。 この場合、キャッシュ テーブルとバッキング テーブルの間で列マッピングを定義するためにこのメソッドを実装することができます。 構文は、**Query::Insert\_RecordSet()** メソッド (<https://msdn.microsoft.com/library/query.insert_recordset.aspx>) の構文と同じです。

```xpp
public Map parmQueryableToCacheMapping()
{
    Map sourceToTargetMap = super();
    return sourceToTargetMap;
}
```

### <a name="form-implementation"></a>フォーム実装

キャッシュ クエリ、テーブル、およびクラスを作成した後、フォーム上でキャッシュを使用できるようになります。 データ ソースとして、フォームにキャッシュ テーブルを追加し、その他のデータ ソースを参照する場合と同様に、それを参照します。 フォームが正しくキャッシュを利用するには、いくつかのコードが必要です。

1.  **registerDatasourceOnQueryingEvent()** メソッドで、**prepareDataSet** を呼び出すデータ ソースの **OnQueryExecuting** イベントにイベント ハンドラーを追加します。 これには、フォーム クラスが **SysIDataSetConsumerForm** を実装する必要があります。
2.  **registerDatasourceOnQueryingEvent()** メソッドで、フォームでフィルタリングを使用するようにするには、**OnQueryExecuting** イベントで **applyFilter** を登録します。 これには、フォーム クラスが **SysIFilterConsumerForm** を実装する必要があります。
3.  フォームが、親フォームのフィルター (例えば、ワークスペース全体のフィルター) の変更時に対応する必要がある場合、**SysIFilterEventHandler** をフォーム クラスに含め、キャッシュ データ ソースで **executeQuery()** メソッドを呼び出す **onFilterChanged()** を含めます。

次のコードは、**FMPickingUpTodayPart** フォームの例です。これは、予約管理ワークスペースのタブ付きリストの1つです。

```xpp
[Form]public class FMPickingUpTodayPart extends FormRun
implements SysIFilterConsumerForm, SysIDataSetConsumerForm, SysIFilterEventHandler
{
    public void registerDatasourceOnQueryingEvent()
    {    
        FMPickupAndReturnCache_DS.OnQueryExecuting += eventhandler(this.parmDataSetFormQueryEventHandler().prepareDataSet);    
        FMPickupAndReturnCache_DS.OnQueryExecuting +=eventhandler(this.parmFilterFormQueryEventHandler().applyFilter);    
    }
    public void onFilterChanged()
    {    
        FMPickupAndReturnCache_DS.executeQuery();    
    }    
}
```

### <a name="additional-examples"></a>追加の例

前の例に加えて、**SysFoundationTestOpenHeaderDataset** を参照でき、これは **SysFoundationTestOpenHeadersFormPart** (**SysFoundationTestWorkspace** で参照されているそのもの) で使用されます。 このフォームは、前述の同じメソッドを使用しますが、クエリ集計カウントのキャッシュも含まれています。

### <a name="refresh-management"></a>更新管理

ワークスペース内のデータのリストは、特にユーザー アクションによってレコードがリストで表示する基準を満たさなくなった場合に、ユーザー アクションに対して応答する必要もあります。 たとえば、今日開始予定のレンタカーの一覧があります。 従業員が顧客と一緒にそのリストからレンタル・レコードを開始するたびに、そのレコードはワークスペース・リストに表示されなくなります。 この一覧を最新の状態に保つために、2 つのメカニズムが利用できます。

-   ユーザーが、一覧からレコードを削除するアクションをとると、データ ソースを更新することで、リストが直ちに更新されることを保証するコードを追加できます。 データ ソースがキャッシュのデータ ソースであり、更新の頻度が遅い場合は、**更新** を呼び出す前に、キャッシュ データ ソースから対応するレコードを削除すれば、キャッシュを強制的にリフレッシュする必要がなくなります。
-   最初のオプションが要件を満たしていない場合は、時間間隔でフォーム パーツを非同期で更新できます。 このオプションは、FormPart コントロールの **AutoRefreshInterval** プロパティを使用して設定できます。
    -   ユーザー操作のあるワークスペースについては、キャッシュの更新頻度をクエリ パフォーマンスに基づいて設定する必要があります。 この場合、現在の推奨は **AutoRefreshInterval** を設定しないことです。 代わりに、ユーザーに依存してより多くのデータをもたらすためにワークスペースを手動で更新します。 または、頻度の低い自動更新の使用を考慮します。 ただし、この場合は、ユーザーがやり取りしている間にリストが更新される場合、ユーザーの現在の選択内容は保持されません。
    -   ワークスペースの小さなパーセンテージは、表示のみを目的としています (ユーザーの操作なし)。 これらのワークスペースでは、**AutoRefreshInterval** プロパティをプログラムで設定して、バックアップ キャッシュの現在の更新頻度を一致させる必要があります。 (実行時にシステム管理者によって変更できるため、**SysIDataCacheConfiguration.parmRefreshFrequency()** を使用してキャッシュの現在の更新頻度を取得します。)
    -   グラフがある FormParts は **AutoRefreshInterval** プロパティを設定し、定期的に更新されたグラフ データをを表示する必要があります。

## <a name="common-mistakes-and-tips-for-query-optimization"></a>クエリの最適化に関するよくある間違いやヒント
クエリを最適化するときに考慮するいくつかの一般的なガイドラインを次に示します。 これは、クエリ最適化の広範なガイドではありませんが、いくつかの簡単なガイドラインを示しています。

-   **SQL プロファイラーを使用して、明細書を追跡してください。** Microsoft SQL Server プロファイラーをデータ ベースに接続し、最適化する SQL ステートメントをキャプチャします。 既定のインストールで提供されている調整テンプレートを使用することができます。 興味のある明細書を入手した際は、トレースを無効にすることを忘れないでください。 詳細については、「<https://msdn.microsoft.com/library/ms175047.aspx>」を参照してください。
-   **クエリ計画を常に確認します。** Microsoft SQL Server Management Studio で、**実際の実行計画を含む** を有効にしたことを確認します。 クエリ プランを確認し、警告に注意します。 矢印の太さは、フェッチされて次のステップに移動された行の数を示します。
-   **CPU のミリ秒と論理 I/O を比較します。** 特定の SQL ステートメントへの変更が、ステートメントを改善したかどうかを決定する良い方法の 1 つは、論理 I/O と CPU のミリ秒を確認することです。 これらの数値を取得するには、クエリ エディターで次のステートメントを使用します。
    -   set statistics time on
    -   set statistics io on
-   **明細書を測定するときは、常にキャッシュをクリアします。** Microsoft SQL Server がキャッシュされた実行計画を使用していないことを確認するには、命令文を再実行するときにキャッシュをフラッシュすることをお勧めします。 キャッシュをフラッシュするには、次の 2 つのコマンドを実行します。
    -   dbcc dropCleanBuffers
    -   dbcc freeProcCache
-   **注意すべきいくつかの一般的なパターンを次に示します。**
    -   **インデックスがありません:** WHERE 条件を分析して、選択したインデックスが存在するかどうかを確認します。
    -   **同じテーブル/行の多数の処理:** 特に結合するときは、繰り返しをしないでください。 同じテーブル/行を処理する必要がある回数を最小化します。 結果セットの一部であるはずのテーブルがあり、結果セットを絞り込むために使用されていない場合は、(特にユニオン クエリーでは) それらを可能な限り遠くに移動します。
-   **データの量をテスト。** クエリの問題を特定するには、常にボリューム データに対して実行します。






[!INCLUDE[footer-include](../../../includes/footer-banner.md)]