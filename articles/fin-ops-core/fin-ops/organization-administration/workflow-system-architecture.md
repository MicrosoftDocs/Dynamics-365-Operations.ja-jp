---
title: ワークフロー システムのアーキテクチャ
description: この記事では、ワークフロー システムのアーキテクチャについて説明します。
author: ChrisGarty
ms.date: 08/18/2017
ms.topic: article
ms.prod: ''
ms.technology: ''
audience: Developer, IT Pro
ms.reviewer: sericks
ms.custom: 56351
ms.assetid: 107a3f9f-aa1d-4087-9b35-196d8b82b0fb
ms.search.region: Global
ms.author: cgarty
ms.search.validFrom: 2016-02-28
ms.dyn365.ops.version: AX 7.0.0
ms.openlocfilehash: 072722c59fe12cf5a6c0d56f3ce0b87e2132eaa8
ms.sourcegitcommit: 074b6e212d19dd5d84881d1cdd096611a18c207f
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/31/2021
ms.locfileid: "5747139"
---
# <a name="workflow-system-architecture"></a>ワークフロー システムのアーキテクチャ

[!include [banner](../includes/banner.md)]

この記事では、ワークフロー システムのアーキテクチャについて説明します。

ワークフロー インフラストラクチャは、Application Object Server (AOS) でホストされる 2 つのコンポーネント (X++ ワークフロー ランタイムおよび管理ワークフロー ランタイム) から構成されます。

X++ ワークフロー ランタイムは、次のコンポーネントで構成されます。

- ワークフロー ランタイム アプリケーション プログラミング インターフェイス (API)
- メッセージング バッチ ジョブ
- メッセージ キュー

必要に応じて、メッセージング バッチ ジョブまたはワークフロー ランタイム API のいずれかがアプリケーション コードを呼び出すことができます。 X++ ワークフロー ランタイムは、Microsoft .NET フレームワークの CIL (共通中間言語) にコンパイルされます。

管理型ワークフロー ランタイムは、Windows Workflow Foundation と Finance and Operations アプリの機能拡張で構成されます。

論理的には、ワークフロー インフラストラクチャは拡張であり、ユーザーにとって透過的です。 物理的には、X++ ワークフローおよび管理ワークフローのランタイムは両方とも AOS でホストされます。 ワークフロー インフラストラクチャは AOS と .NET Interop でバッチ処理を使用して、その 2 つのサブシステムを統合し、片方のサブシステムからもう一方のサブシステムにメッセージを渡します。 バッチ プロセッサで実行される X++ コードは、.NET CIL にコンパイルされます。 バッチ処理は、.NET 共通言語ランタイム (CLR) で実行されます。

次の図に、ワークフロー インフラストラクチャの高レベル アーキテクチャの概要を示します。

[![ワークフロー\_architecturediagram2016](./media/workflow_architecturediagram2016.png)](./media/workflow_architecturediagram2016.png)

ユーザーは、 ワークフロー ページとコントロールを使用して、業務プロセスに参加できます。

開発者は、追加済のオブジェクトのワークフローを作成できます。 次の表は、ユーザーが経費精算書を承認のためにワークフロー システムに提出したときに発生するワークフロー ステップを示します。

| ステップ | ランタイム                  | 活動 |
|------|--------------------------|----------|
| 1    | X++ ワークフロー ランタイム     | ユーザーは、ワークフローのいずれかの制御で **送信** をクリックして、経費精算書を送信します。 このアクションにより、X++ コードはワークフロー ランタイム API を呼び出し、ワークフロー インスタンスが有効になります。 ワークフロー ランタイム API は、メッセージをメッセージ キューに書き込みます。 メッセージング バッチ ジョブは、メッセージを読み取り、ワークフローのアクティブ化要求を管理ワークフロー ランタイムに送信します。<blockquote>[!NOTE] メッセージング バッチ ジョブは 1 分間隔でメッセージ キューを処理します。</blockquote> |
| 2    | 管理されるワークフロー ランタイム | X++ からの .NET Interop は、メッセージを受け取り、新しいワークフロー インスタンスを Windows Workflow Foundation 経由で開始します。 このワークフロー インスタンスは、X++ への.NET Interop CIL 経由でX++ ワークフロー ランタイム API のコールバックを実行し、ワークフローが起動されたことを示すメッセージを書き込みます。<p>メッセージが転記されると、管理ワークフロー ランタイムは、アイドル状態のワークフロー インスタンスをデータベースに保存します。 その後、ランタイムはメモリからワークフロー インスタンスを削除します。 管理ワークフロー ランタイムが、このワークフロー インスタンスに対する別のメッセージを X++ ワークフロー ランタイムから受け取ると、ワークフロー インスタンスはメモリーに復元され、再開されます。</p><p>各ワークフロー インスタンスは固有です。 2 人のユーザーが承認のために経費精算書を提出すると、2 つのワークフロー インスタンスが開始されます。</p> |
| 3    | X++ ワークフロー ランタイム     | メッセージング バッチ ジョブが、**ワークフローで開始された** メッセージをメッセージ キューから読み取り、**ワークフローで開始された** イベントを処理するアプリケーション イベント ハンドラーを開始します。 次に、バッチ ジョブは、イベントが処理されたことを示す確認メッセージを書き込みます。 |
| 4    | 両方                     | この同じメッセージング パターンが、ワークフロー インスタンスのライフサイクル全体で必要に応じて繰り返されます。 |

このワークフロー アーキテクチャは、信頼できる堅牢なメッセージ システムを提供し、また、ワークフローの状態とアプリケーションの状態を常に同期させるために役立ちます。 ハードウェアやソフトウェアに予期しない障害が発生すると、ワークフロー インスタンスの状態は最後に保存された既知の点まで戻され、メッセージはキュー内に保持されます。 したがって、アーキテクチャから見ると、復旧モデルは、問題の解決とワークフローの再開です。


[!INCLUDE[footer-include](../../../includes/footer-banner.md)]